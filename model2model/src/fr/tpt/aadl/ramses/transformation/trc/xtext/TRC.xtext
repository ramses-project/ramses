grammar fr.tpt.aadl.ramses.transformation.trc.xtext.TRC with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate tRC "http://www.tpt.fr/aadl/ramses/transformation/trc/xtext/TRC"

TrcSpecification :
		moduleList         += ModuleList
		transformationList += TransformationList
		dependencyList     += TransformationDependencyList
;
   
trcRule:
	name=EString
;  

ModuleList :
'Modules'
	'{'
		modules+=Module ( ";" modules+=Module)*
	'}'
;

QualifiedName:
ID ('.' ID)*;

Module:
{Module}
		(name=EString ':' rules+=trcRule ( "," rules+=trcRule)*)?
;

TransformationList:
	'Transformations'
	'{'
		transformations+=Transformation ( "," transformations+=Transformation)*
	'}'
; 
	
Transformation:
		name=EString
		'{'
			'modules' ':' modules+=[Module] ( "," modules+=[Module])*
			('impacts' ':'  impacts+=TransformationImpact ( "," impacts+=TransformationImpact)* )?
		'}'
;

TransformationImpact:
	'('
		(qualityAttributeName=EString ',')? 
		impactValue=EInt
	')'
;

TransformationDependencyList:
		'Dependencies' 
		'{'
		 	name=EString
		 	'{'
				transformationDependencies+=TransformationDependency ( ";" transformationDependencies+=TransformationDependency)* 
			'}'
		'}' 
;

TransformationDependency :
	'Apply'
	'('
		appliedTransformation=[Transformation|EString]'.'appliedRule=[trcRule|QualifiedName] ','
		'{' fields+=EString ( "," fields+=EString)* '}'
	')'
	'['	
	requiredTransformations+=RuleDependency boolOP=BooleanOperations (requiredTransformations+=RuleDependency)*  
	']'
;


BooleanOperations returns BooleanOperations:
	name=('and'|'or');

RuleDependency :
		kw=KeyWord red+=requiresOrExcludeDependency (boolOP=BooleanOperations red+=requiresOrExcludeDependency)?
;

KeyWord returns KeyWord :
	name = ('requires' | 'excludes')
;

requiresOrExcludeDependency :
	'('
		requiredTransformation+=[Transformation|EString]'.'requiredRule+=[trcRule|QualifiedName]','fields=EString":"oclExpression+=oclExpr
	')'
; 


oclExpr :
	ClassifierContextDeclCS | ExpressCS
	//| ExpressCS
;
//TransformationElement :
//	'TransformationElement'
//;
//
//SpecificationElement :
//	'SpecificationElement'
//;

EString returns ecore::EString:
STRING | ID;

EInt returns ecore::EInt:
'-'? INT;

EBoolean returns ecore::EBoolean:
'true' | 'false';

ClassifierContextDeclCS :
	'context' (selfName=UnrestrictedName)?
//	pathName=PathNameCS
	(('inv' invariants+=ConstraintCS)
	| definitions+=DefCS
	)+
;

OperationContextDeclCS returns OperationContextDeclCS:
	'context' pathName=PathNameCS '(' 
	(parameters+=ParameterCS (',' parameters+=ParameterCS)*)?
	')' ':' (ownedType=TypeExpCS)?
	(('pre' preconditions+=ConstraintCS)
	| ('post' postconditions+=ConstraintCS)
	| ('body' UnrestrictedName? ':' bodies+=SpecificationCS)
	)*
	;

ParameterCS returns ParameterCS:
	(name=UnrestrictedName ':')? ownedType=TypeExpCS;

//ConstraintCS returns base::ConstraintCS:
ConstraintCS returns ConstraintCS:
	(name=UnrestrictedName ('(' messageSpecification=SpecificationCS ')')?)? ':' specification+=SpecificationCS (specification+=SpecificationCS)*;

EssentialOCLUnrestrictedName returns ecore::EString:
	Identifier;

Identifier:
	ID;
	

UnrestrictedName returns ecore::EString: // Intended to be overridden
	EssentialOCLUnrestrictedName;

DefCS returns DefCS:
//	DefOperationCS
	//|
	DefPropertyCS
;
	
DefPropertyCS returns DefPropertyCS:
	(static?='static')? 'def' UnrestrictedName? 
	':' name=UnrestrictedName ':' 
	ownedType=TypeExpCS
	'=' specification=SpecificationCS
;

//TypeExpCS returns base::TypedRefCS:
TypeExpCS returns TypedRefCS:	
	(
	TypeNameExpCS 
//	| 
//	TypeLiteralCS
	)
	multiplicity=MultiplicityCS?;

MultiplicityCS returns MultiplicityCS:
	'[' (MultiplicityBoundsCS | MultiplicityStringCS) ']';

MultiplicityStringCS returns MultiplicityStringCS:
	stringBounds=('*'|'+'|'?');

MultiplicityBoundsCS returns MultiplicityBoundsCS:
	lowerBound=LOWER ('..' upperBound=UPPER)?;

LOWER returns ecore::EInt:
	INT
;

UPPER returns ecore::EInt:
	INT
;

NamedElement :  // to be extended
	NameSpace |
	(
	isStatic = EBoolean
	name = EString
	)
;

NameSpace :
	ID = EString  /// not complete
;

TypeNameExpCS returns TypeNameExpCS:
	pathName=PathNameCS;

//PathNameCS returns base::PathNameCS:
PathNameCS returns PathNameCS:
	path+=FirstPathElementCS ('::' path+=NextPathElementCS)*;
	
//FirstPathElementCS returns base::PathElementCS:
FirstPathElementCS returns PathElementCS:	
	element=[NamedElement|UnrestrictedName];
	
NextPathElementCS returns PathElementCS:
	element=[NamedElement|UnreservedName];

UnreservedName returns ecore::EString: // Intended to be overridden
	EssentialOCLUnreservedName;

EssentialOCLUnreservedName returns ecore::EString:
UnrestrictedName
|	CollectionTypeIdentifier
|	PrimitiveTypeIdentifier
|	'Tuple'
;

PrimitiveTypeIdentifier:
	'Boolean'
	| 'Integer'
	| 'Real'
	| 'String'
	| 'UnlimitedNatural'
	| 'OclAny'
	| 'OclInvalid'
	| 'OclVoid';

CollectionTypeIdentifier returns ecore::EString:
	'Set'
	| 'Bag'
	| 'Sequence'
	| 'Collection'
	| 'OrderedSet';


SpecificationCS returns SpecificationCS:
	ownedExpression+=ContextCs
	| exprString=UNQUOTED_STRING;



terminal UNQUOTED_STRING:	// Never forward parsed; just provides a placeholder
	'£$%^£$%^'				//  for reverse serialisation of embedded OCL 
;

EssentialOCLInfixOperatorCS returns EssentialOCLInfixOperatorCS:
	{EssentialOCLInfixOperatorCS}
	name=('*' | '/' | '+' | '-' | '>' | '<' | '>=' | '<=' | '=' | '<>' | 'and' | 'or' | 'xor' | 'implies');

BinaryOperatorCS returns BinaryOperatorCS:
	EssentialOCLInfixOperatorCS | NavigationOperatorCS;
	
NavigationOperatorCS returns NavigationOperatorCS:
	name=('.' | '->');
	
 ContextCs :
 //	ownedOperator+=UnaryOperatorCS+
 	ownedExpression+=LetExpCS
 	|
 	(B=BinaryOperatorCS)? ('self.'? ID (BO=BinaryOperatorCS) 'self.'? ID) 
// 	| ID
 ;
  

 ExpressCS:
( (ownedExpression+=PrefixedExpCS ownedOperator+=BinaryOperatorCS)+
ownedExpression+=PrefixedExpOrLetExpCS)
| (ownedOperator+=EssentialOCLPrefixOperator ownedExpression+=PrimaryExpOrLetExpCS)
| PrimaryExpOrLetExpCS
;


PrefixedExpCS :
//PrimaryExpCS // <----- the location of the warnings showed after compilation of the grammar
//| 
({PrefixExpCS} ownedOperator+=EssentialOCLPrefixOperator //ownedExpression=PrimaryExpCS
);

EssentialOCLPrefixOperator:
	name = ('-' | 'not');
//
PrefixedExpOrLetExpCS :
PrimaryExpOrLetExpCS
| ({PrefixExpCS} ownedOperator+=EssentialOCLPrefixOperator
	ownedExpression=PrimaryExpOrLetExpCS
);

PrimaryExpCS :	// These rules are ordered most rejectable first
({IndexExpCS} pathName=PathNameCS '[' firstIndexes+=ExpressCS (',' firstIndexes+=ExpressCS)* ']'
('[' secondIndexes+=ExpressCS (',' secondIndexes+=ExpressCS)* ']')? (atPre?='@' 'pre')?)
|	({ConstructorExpCS} pathName=PathNameCS
'{' ((ownedParts+=ConstructorPartCS (',' ownedParts+=ConstructorPartCS)*) | (value=ID)) '}')
| ({InvocationExpCS} pathName=PathNameCS (atPre?='@' 'pre')?
'(' (argument+=NavigatingArgCS (argument+=NavigatingCommaArgCS)*
(argument+=NavigatingSemiArgCS (argument+=NavigatingCommaArgCS)*)?
(argument+=NavigatingBarArgCS (argument+=NavigatingCommaArgCS)*)?)?
')')
|	({NameExpCS} pathName=PathNameCS (atPre?='@' 'pre')?)
|	SelfExpCS
| PrimitiveLiteralExpCS
| TupleLiteralExpCS
| CollectionLiteralExpCS
| TypeLiteralExpCS
| IfExpCS
| NestedExpCS;

ConstructorPartCS returns ConstructorPartCS:
property=UnrestrictedName '=' initExpression=ExpressCS
//UnrestrictedName =? [Property|UnrestrictedName]
;

TypeLiteralWithMultiplicityCS :
TypeLiteralCS multiplicity=MultiplicityCS?;

TypeLiteralCS :
PrimitiveTypeCS
| CollectionTypeCS
| TupleTypeCS;

TupleTypeCS :
name='Tuple' ('(' (ownedParts+=TuplePartCS (',' ownedParts+=TuplePartCS)*)? ')')?;

TuplePartCS :
name=UnrestrictedName ':' ownedType=TypeExpCS;

PrimitiveTypeCS :
name=PrimitiveTypeIdentifier;

TypeLiteralExpCS returns TypeLiteralExpCS:
ownedType=TypeLiteralWithMultiplicityCS;

CollectionLiteralExpCS returns CollectionLiteralExpCS:
ownedType=CollectionTypeCS
'{' (ownedParts+=CollectionLiteralPartCS
(',' ownedParts+=CollectionLiteralPartCS)*)?
'}';

CollectionLiteralPartCS returns CollectionLiteralPartCS:
expressionCS=ExpressCS ('..' lastExpressionCS=ExpressCS)?;

CollectionTypeCS returns CollectionTypeCS:
name=CollectionTypeIdentifier ('(' ownedType=TypeExpCS ')')?;

NestedExpCS returns NestedExpCS:
'(' source=ExpressCS ')'
;

SelfExpCS returns SelfExpCS:
{SelfExpCS} 'self';

PrimaryExpOrLetExpCS :
LetExpCS;

LetExpCS returns LetExpCS:
'let' variable+=LetVariableCS (',' variable+=LetVariableCS)*
'in' in=ExpressCS;

LetVariableCS returns LetVariableCS:
name=UnrestrictedName (':' ownedType=TypeExpCS)? '=' initExpression=ExpressCS;

NavigatingArgCS returns NavigatingArgCS:
name=NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' init=ExpressCS)?)?;	

NavigatingBarArgCS returns NavigatingArgCS:
prefix='|' name=NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' init=ExpressCS)?)?;

NavigatingSemiArgCS returns NavigatingArgCS:
prefix=';' name=NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' init=ExpressCS)?)?;

NavigatingArgExpCS returns ExpCS: // Intended to be overridden
ExpressCS
// '?' -- defined by Complete OCL
;

NavigatingCommaArgCS returns NavigatingArgCS:
prefix=',' name=NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' init=ExpressCS)?)?;

IfExpCS returns IfExpCS:
'if' condition=ExpressCS
'then' thenExpression=ExpressCS
'else' elseExpression=ExpressCS
'endif';

TupleLiteralExpCS returns TupleLiteralExpCS:
'Tuple' '{' ownedParts+=TupleLiteralPartCS (',' ownedParts+=TupleLiteralPartCS)* '}';

TupleLiteralPartCS returns TupleLiteralPartCS:
name=UnrestrictedName (':' ownedType=TypeExpCS)? '=' initExpression=ExpressCS;

PrimitiveLiteralExpCS returns PrimitiveLiteralExpCS:
NumberLiteralExpCS
| StringLiteralExpCS
| BooleanLiteralExpCS
| UnlimitedNaturalLiteralExpCS
| InvalidLiteralExpCS
| NullLiteralExpCS;

NumberLiteralExpCS returns NumberLiteralExpCS:
name=NUMBER_LITERAL;

NUMBER_LITERAL returns BigNumber: // Not terminal to allow parser backtracking to sort out "5..7"
number=INT; // EssentialOCLTokenSource pieces this together ('.' INT)? (('e' | 'E') ('+' | '-')? INT)?;

StringLiteralExpCS returns StringLiteralExpCS:
name+=ID+;

BooleanLiteralExpCS returns BooleanLiteralExpCS:
name='true'
| name='false';

UnlimitedNaturalLiteralExpCS returns UnlimitedNaturalLiteralExpCS:
{UnlimitedNaturalLiteralExpCS} '*';

InvalidLiteralExpCS returns InvalidLiteralExpCS:
{InvalidLiteralExpCS} 'invalid';

NullLiteralExpCS returns NullLiteralExpCS:
{NullLiteralExpCS} 'null';
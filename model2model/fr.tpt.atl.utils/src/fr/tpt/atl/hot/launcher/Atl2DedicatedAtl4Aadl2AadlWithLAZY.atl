-- @atlcompiler atl2006
-- Generated by: $Id$
module Atl2DedicatedAtl4Aadl2Aadl;

create OUT : MM_ATL from IN : MM_ATL, IN2 : MM_TIP;

helper def : inElements : Set(MM_ATL!LocatedElement) = MM_ATL!LocatedElement.allInstancesFrom('IN');

--returns module name of the IN model
helper def : getModuleName : String = MM_ATL!Module.allInstancesFrom('IN')->first().name;

helper def : getTransformationId(transformationName : String) : String =
	thisModule.getModuleName+'.'+transformationName;
	
--gets the last iteration object
helper def : getLastIteration() : MM_TIP!Iteration = 
MM_TIP!Iteration.allInstancesFrom('IN2')->last();

--gets transformation Name from the transformation ID
helper def : getTransformationNameFromID(transformationID : String) : String = 
	transformationID.substring(transformationID.lastIndexOf('.')+1, transformationID.size());

--gets all the transformation names from the last iteration elements 
helper def : inTransformationsInTip : Set (String) = thisModule.getLastIteration().elements 
	-> select (e | e.transformationId.substring(1, e.transformationId.lastIndexOf('.')) = thisModule.getModuleName)
	-> collect (e | e.transformationId.substring(e.transformationId.lastIndexOf('.')+2, e.transformationId.size()));

--gets all the elements names which have the same transformation to be executed
helper def : getElementsNamesFromGivenSet(transformationID : String) : Set (String) = 
	thisModule.getLastIteration().elements -> select(e | e.transformationId = transformationID) -> collect (e | e.elementId);


--helper def : getFilterExpression(ruleName : String) : Sequence (MM_ATL!OclExpression) = 
--		thisModule.getElementsNamesFromGivenSet(thisModule.getModuleName+'.'+ruleName) 
--		-> iterate (e ; expressionsSequence : Sequence (MM_ATL!OclExpression) = Sequence {} | expressionsSequence.append());
--
--
--
--helper def : assignVar(expressions : Set (MM_ATL!OclExpression), svar : MM_ATL!VariableExp ) : Set (MM_ATL!OclExpression) = 
--	expressions -> collect(e | e.arguments)

rule Unit {
    from s : MM_ATL!"ATL::Unit" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(MM_ATL!"ATL::Unit")
		else false endif)
    to t : MM_ATL!"ATL::Unit" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        libraries <- s.libraries)
}

rule Library {
    from s : MM_ATL!"ATL::Library" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::Library" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        libraries <- s.libraries,
        helpers <- s.helpers)
}

rule Query {
    from s : MM_ATL!"ATL::Query" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::Query" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        libraries <- s.libraries,
        body <- s.body,
        helpers <- s.helpers)
}

rule Module {
    from s : MM_ATL!"ATL::Module" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::Module" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isRefining <- s.isRefining,
        libraries <- s.libraries,
		inModels <- s.inModels,
        outModels <- s.outModels,
        elements <- s.elements)
}

rule Helper {
    from s : MM_ATL!"ATL::Helper" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::Helper" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        definition <- s.definition)
}

rule MatchedRule {
    from s : MM_ATL!"ATL::MatchedRule" (
    		--here an argument for the transformationID matching should be added
		(if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(MM_ATL!"ATL::MatchedRule")
		else false endif) 
    		and (thisModule.inTransformationsInTip->includes(s.name)) 
			)
    to t : MM_ATL!"ATL::MatchedRule" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isRefining <- s.isRefining,
        isNoDefault <- s.isNoDefault,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
		inPattern <- ip, 
        children <- s.children,
        superRule <- s.superRule),
		
		ip : MM_ATL!InPattern (
			elements <- element
			--filter <- ifilter
		),
		element : MM_ATL!SimpleInPatternElement(
			varName <- s.inPattern.elements->first().varName,
			type <- ipet
		),
		ipet : MM_ATL!OclModelElement (
			name <- s.inPattern.elements->first().type.name,
			model <- s.inPattern.elements->first().type.model
		),

		ifilter : MM_ATL!OperatorCallExp(
			operationName <- '=',
			source <- sourcecall,
			arguments <- argcall--thisModule.getElementsNamesFromGivenSet(s.name)->collect(e|thisModule.createOperatorCallExp(e))
		),
		sourcecall: MM_ATL!StringExp(--OperationCallExp(
			stringSymbol <- thisModule.getElementsNamesFromGivenSet(s.name)->first()
		),

--		ifilter : MM_ATL!OperatorCallExp(
--			operationName <- '=',
--			source <- sourcecall,
--			arguments <- argcall
--		),

		argcall: MM_ATL!OperationCallExp(
			operationName <- 'getInstanceObjectPath',
			source <- argcallsrc			
		),
		argcallsrc : MM_ATL!VariableExp(
			referredVariable <- s.inPattern.elements->first()
		)
		
--		argcall : MM_ATL!StringExp(
--			stringSymbol <- thisModule.getElementsNamesFromGivenSet(thisModule.getModuleName+'.'+s.name)->first()
--		)
 	do {
 		ip.filter <- thisModule.initFilter(thisModule.getElementsNamesFromGivenSet(thisModule.getModuleName+'.'+s.name).debug('LIST !!!!!! ')->excluding(thisModule.getElementsNamesFromGivenSet(s.name)->first().debug('FIRST ?????? ')), ifilter, s);
 		
 	}
}

rule initFilter(names: Set(String), filterElement : MM_ATL!OperatorCallExp, inputElem : MM_ATL!"ATL::MatchedRule") {
 using {
 	 local : MM_ATL!OperatorCallExp = OclUndefined;
 	 result : MM_ATL!OperatorCallExp = filterElement;
 }	
 do {
 	if (names->size() > 0) {
  		local <- thisModule.createOperatorCallExp(names->first(), filterElement, inputElem);
  		result <- thisModule.initFilter(names->excluding(names->first()), local, inputElem);	
 	}
 	result;
 }	
}

lazy rule createOperatorCallExp {
    from
    	s : MM_ATL!StringType,
		filterElement : MM_ATL!OperatorCallExp,
		inputElem : MM_ATL!"ATL::MatchedRule"
    to
		result: MM_ATL!OperatorCallExp (
        	operationName <- 'or',
			source <-new,
			arguments <- filterElement
		),
        new: MM_ATL!OperatorCallExp (
        	operationName <- '=',
			source <-sourcecall,
			arguments <- argcall
		),
		sourcecall: MM_ATL!StringExp(--OperationCallExp(
			stringSymbol <- s
--			operationName <- 'getInstanceObjectPath',
--			source <- argcallsrc			
		),
--		argcallsrc : MM_ATL!VariableExp(
--			referredVariable <- s.inPattern.elements->first()
--		),
		
		argcall: MM_ATL!OperationCallExp(
			operationName <- 'getInstanceObjectPath',
			source <- argcallsrc			
		),
		argcallsrc : MM_ATL!VariableExp(
			referredVariable <- inputElem.inPattern.elements ->first()
		)
    do
    {
        result;
    }
}

--lazy rule fillOclExpression {
--    from
--    	s : MM_ATL!"ATL::MatchedRule"
--    to
--        result: MM_ATL!OperatorCallExp (
--        	operationName <- '=',
--			source <-sourcecall
--		),
--		sourcecall: MM_ATL!OperationCallExp(
--			operationName <- 'getInstanceObjectPath',
--			source <- argcallsrc			
--		),
--		argcallsrc : MM_ATL!VariableExp(
--			referredVariable <- s.inPattern.elements->first()
--		),
--		
--		argcall : MM_ATL!StringExp(
--			stringSymbol <- thisModule.getElementsNamesFromGivenSet(thisModule.getModuleName+'.'+s.name)->first()
--		)
--    do
--    {
--        result;
--    }
--}

rule LazyMatchedRule {
    from s : MM_ATL!"ATL::LazyMatchedRule" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::LazyMatchedRule" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isRefining <- s.isRefining,
        isNoDefault <- s.isNoDefault,
        isUnique <- s.isUnique,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
        inPattern <- s.inPattern,
        children <- s.children,
        superRule <- s.superRule)
}

rule CalledRule {
    from s : MM_ATL!"ATL::CalledRule" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::CalledRule" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isEntrypoint <- s.isEntrypoint,
        isEndpoint <- s.isEndpoint,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
        parameters <- s.parameters)
}

rule InPattern {
    from s : MM_ATL!"ATL::InPattern" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::InPattern" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        elements <- s.elements,
        filter <- s.filter)
}

rule OutPattern {
    from s : MM_ATL!"ATL::OutPattern" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::OutPattern" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        elements <- s.elements)
}

rule SimpleInPatternElement {
    from s : MM_ATL!"ATL::SimpleInPatternElement" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::SimpleInPatternElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        "mapsTo" <- s."mapsTo",
        models <- s.models)
}

rule SimpleOutPatternElement {
    from s : MM_ATL!"ATL::SimpleOutPatternElement" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::SimpleOutPatternElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        sourceElement <- s.sourceElement,
        bindings <- s.bindings,
        model <- s.model,
        reverseBindings <- s.reverseBindings)
}

rule ForEachOutPatternElement {
    from s : MM_ATL!"ATL::ForEachOutPatternElement" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::ForEachOutPatternElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        sourceElement <- s.sourceElement,
        bindings <- s.bindings,
        model <- s.model,
        collection <- s.collection,
        iterator <- s.iterator)
}

rule Binding {
    from s : MM_ATL!"ATL::Binding" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::Binding" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        propertyName <- s.propertyName,
        value <- s.value)
}

rule RuleVariableDeclaration {
    from s : MM_ATL!"ATL::RuleVariableDeclaration" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::RuleVariableDeclaration" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule LibraryRef {
    from s : MM_ATL!"ATL::LibraryRef" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::LibraryRef" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name)
}

rule ActionBlock {
    from s : MM_ATL!"ATL::ActionBlock" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::ActionBlock" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        statements <- s.statements)
}

rule ExpressionStat {
    from s : MM_ATL!"ATL::ExpressionStat" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::ExpressionStat" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        expression <- s.expression)
}

rule BindingStat {
    from s : MM_ATL!"ATL::BindingStat" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::BindingStat" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        propertyName <- s.propertyName,
        source <- s.source,
        value <- s.value)
}

rule IfStat {
    from s : MM_ATL!"ATL::IfStat" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::IfStat" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        condition <- s.condition,
        thenStatements <- s.thenStatements,
        elseStatements <- s.elseStatements)
}

rule ForStat {
    from s : MM_ATL!"ATL::ForStat" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::ForStat" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        iterator <- s.iterator,
        collection <- s.collection,
        statements <- s.statements)
}

rule VariableExp {
    from s : MM_ATL!"OCL::VariableExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::VariableExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        referredVariable <- s.referredVariable)
}

rule SuperExp {
    from s : MM_ATL!"OCL::SuperExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::SuperExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type)
}

rule StringExp {
    from s : MM_ATL!"OCL::StringExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::StringExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        stringSymbol <- s.stringSymbol,
        type <- s.type)
}

rule BooleanExp {
    from s : MM_ATL!"OCL::BooleanExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::BooleanExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        booleanSymbol <- s.booleanSymbol,
        type <- s.type)
}

rule RealExp {
    from s : MM_ATL!"OCL::RealExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::RealExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        realSymbol <- s.realSymbol,
        type <- s.type)
}

rule IntegerExp {
    from s : MM_ATL!"OCL::IntegerExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::IntegerExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        integerSymbol <- s.integerSymbol,
        type <- s.type)
}

rule BagExp {
    from s : MM_ATL!"OCL::BagExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::BagExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule OrderedSetExp {
    from s : MM_ATL!"OCL::OrderedSetExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OrderedSetExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule SequenceExp {
    from s : MM_ATL!"OCL::SequenceExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::SequenceExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule SetExp {
    from s : MM_ATL!"OCL::SetExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::SetExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule TupleExp {
    from s : MM_ATL!"OCL::TupleExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::TupleExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        tuplePart <- s.tuplePart)
}

rule TuplePart {
    from s : MM_ATL!"OCL::TuplePart" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::TuplePart" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule MapExp {
    from s : MM_ATL!"OCL::MapExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::MapExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule MapElement {
    from s : MM_ATL!"OCL::MapElement" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::MapElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        key <- s.key,
        value <- s.value)
}

rule EnumLiteralExp {
    from s : MM_ATL!"OCL::EnumLiteralExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::EnumLiteralExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule OclUndefinedExp {
    from s : MM_ATL!"OCL::OclUndefinedExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OclUndefinedExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type)
}

rule NavigationOrAttributeCallExp {
    from s : MM_ATL!"OCL::NavigationOrAttributeCallExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::NavigationOrAttributeCallExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        source <- s.source)
}

rule OperationCallExp {
    from s : MM_ATL!"OCL::OperationCallExp" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(MM_ATL!"OCL::OperationCallExp")
		else false endif)
    to t : MM_ATL!"OCL::OperationCallExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        operationName <- s.operationName,
        type <- s.type,
        source <- s.source,
        arguments <- s.arguments)
}

rule OperatorCallExp {
    from s : MM_ATL!"OCL::OperatorCallExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OperatorCallExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        operationName <- s.operationName,
        type <- s.type,
        source <- s.source,
        arguments <- s.arguments)
}

rule CollectionOperationCallExp {
    from s : MM_ATL!"OCL::CollectionOperationCallExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::CollectionOperationCallExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        operationName <- s.operationName,
        type <- s.type,
        source <- s.source,
        arguments <- s.arguments)
}

rule IterateExp {
    from s : MM_ATL!"OCL::IterateExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::IterateExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        source <- s.source,
        body <- s.body,
        iterators <- s.iterators,
        result <- s.result)
}

rule IteratorExp {
    from s : MM_ATL!"OCL::IteratorExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::IteratorExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        source <- s.source,
        body <- s.body,
        iterators <- s.iterators)
}

rule LetExp {
    from s : MM_ATL!"OCL::LetExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::LetExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        variable <- s.variable,
        in_ <- s.in_)
}

rule IfExp {
    from s : MM_ATL!"OCL::IfExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::IfExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        thenExpression <- s.thenExpression,
        condition <- s.condition,
        elseExpression <- s.elseExpression)
}

rule VariableDeclaration {
    from s : MM_ATL!"OCL::VariableDeclaration" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(MM_ATL!"OCL::VariableDeclaration")
		else false endif)
    to t : MM_ATL!"OCL::VariableDeclaration" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule Iterator {
    from s : MM_ATL!"OCL::Iterator" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::Iterator" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule Parameter {
    from s : MM_ATL!"OCL::Parameter" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::Parameter" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule CollectionType {
    from s : MM_ATL!"OCL::CollectionType" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(MM_ATL!"OCL::CollectionType")
		else false endif)
    to t : MM_ATL!"OCL::CollectionType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule "OclType" {
    from s : MM_ATL!"OCL::OclType" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(MM_ATL!"OCL::OclType")
		else false endif)
    to t : MM_ATL!"OCL::OclType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule StringType {
    from s : MM_ATL!"OCL::StringType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::StringType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule BooleanType {
    from s : MM_ATL!"OCL::BooleanType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::BooleanType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule IntegerType {
    from s : MM_ATL!"OCL::IntegerType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::IntegerType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule RealType {
    from s : MM_ATL!"OCL::RealType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::RealType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule BagType {
    from s : MM_ATL!"OCL::BagType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::BagType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule OrderedSetType {
    from s : MM_ATL!"OCL::OrderedSetType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OrderedSetType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule SequenceType {
    from s : MM_ATL!"OCL::SequenceType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::SequenceType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule SetType {
    from s : MM_ATL!"OCL::SetType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::SetType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule OclAnyType {
    from s : MM_ATL!"OCL::OclAnyType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OclAnyType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule "TupleType" {
    from s : MM_ATL!"OCL::TupleType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::TupleType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        attributes <- s.attributes)
}

rule TupleTypeAttribute {
    from s : MM_ATL!"OCL::TupleTypeAttribute" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::TupleTypeAttribute" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule OclModelElement {
    from s : MM_ATL!"OCL::OclModelElement" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OclModelElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        model <- s.model)
}

rule MapType {
    from s : MM_ATL!"OCL::MapType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::MapType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        valueType <- s.valueType,
        keyType <- s.keyType)
}

rule OclFeatureDefinition {
    from s : MM_ATL!"OCL::OclFeatureDefinition" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OclFeatureDefinition" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        feature <- s.feature,
        context_ <- s.context_)
}

rule OclContextDefinition {
    from s : MM_ATL!"OCL::OclContextDefinition" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OclContextDefinition" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        context_ <- s.context_)
}

rule Attribute {
    from s : MM_ATL!"OCL::Attribute" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::Attribute" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        initExpression <- s.initExpression,
        type <- s.type)
}

rule Operation {
    from s : MM_ATL!"OCL::Operation" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::Operation" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        parameters <- s.parameters,
        returnType <- s.returnType,
        body <- s.body)
}

rule OclModel {
    from s : MM_ATL!"OCL::OclModel" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OclModel" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        metamodel <- s.metamodel,
        elements <- s.elements,
        model <- s.model)
}


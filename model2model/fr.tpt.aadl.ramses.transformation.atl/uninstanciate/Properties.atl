--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLI=http:///AADL2/instance

module Properties;

-- TODO
--  ClassifierValue property kind

create 
	OUT 			: AADLBA
from 
	IN 				: AADLI;

uses AADLCopyHelpers;
uses AADLICopyHelpers;

-------------------------
-- PROPERTIES
-------------------------

helper def: PropertyAssociation(p : AADLI!PropertyAssociation, referencesOnly:Boolean) : AADLI!PropertyAssociation = 
	let content :Sequence(AADLBA!ModalPropertyValue) = p.ownedValue->collect(e|thisModule.ModalPropertyValue(e, referencesOnly))->select(e| not e.oclIsUndefined())
	in
	if(not content->isEmpty() and not content->oclIsUndefined())
	then
		thisModule.PropertyAssociationRule(p,content, referencesOnly)
	else
		OclUndefined
	endif
;

lazy rule PropertyAssociationRule {
	from
		p : AADLI!PropertyAssociation,
		content: Sequence(AADLBA!ModalPropertyValue),
		referencesOnly:Boolean
	to
		p2 : AADLBA!PropertyAssociation (
			property <- p.property.debug('  property'),
			constant <- p.constant,
			append <- p.append,
			ownedValue <- content.debug('  value')
		)
	do
	{
		if(referencesOnly)
		{
			p2.appliesTo.add(thisModule.createContainedNamedElement(p.eContainer().getSubcomponentImg()));
		}
		p2;
	}
}

lazy rule createContainedNamedElement
{
	from
		ne: AADLBA!NamedElement
	to
		cne: AADLBA!ContainedNamedElement
		(containmentPathElement <- Sequence{cpe}),
		cpe: AADLBA!ContainmentPathElement
		(namedElement<-ne)
	do
	{
		cne;
	}
}

helper def:ModalPropertyValue(v : AADLI!ModalPropertyValue, referencesOnly:Boolean) : AADLBA!ModalPropertyValue =
	let content: AADLBA!PropertyExpression = v.ownedValue.PropertyExpression(referencesOnly)
	in
	if(not content.oclIsUndefined()) then
		thisModule.ModalPropertyValueRule(v, content)
	else
		OclUndefined
	endif
;

lazy rule ModalPropertyValueRule {
	from
		v : AADLI!ModalPropertyValue,
		content: AADLBA!PropertyExpression
	to
		v2 : AADLBA!ModalPropertyValue (
			ownedValue <- content
	)
	do { v2; }
}


-------------------------------------------------------------------------------------
--  RULES FOR KINDS OF PROPERTY VALUES
-------------------------------------------------------------------------------------

-- PropertyExpression: PropertyValue: 
-- 			Operation
--			ListValue
-- PropertyValue: 
--			NumberValue
--			ClassifierValue
--			ReferenceValue
--			BooleanLiteral
--			RangeValue
--			RecordValue
--			ComputedValue
--			NamedValue
--			StringLiteral


helper context AADLI!ListValue def: PropertyExpression(referencesOnly:Boolean) : AADLBA!ListValue =
	let elements : Sequence(AADLBA!PropertyExpression) = self.ownedListElement->collect(e|e.PropertyExpression(referencesOnly))
						->select(e| not e.oclIsUndefined()) in 
	if(not elements->isEmpty()) then
		thisModule.ListValue(self, elements)
	else
		OclUndefined
	endif
;

lazy rule ListValue {
	from
		l : AADLI!ListValue,
		elts: AADLBA!PropertyExpression
	to
		l2 : AADLBA!ListValue (
			ownedListElement <- elts
		)
	do { l2; }
}

helper context AADLI!Operation def: PropertyExpression(referencesOnly:Boolean) : AADLBA!Operation =
	if(referencesOnly)then
		OclUndefined
	else
	let content : Sequence(AADLBA!PropertyExpression) = self.ownedPropertyExpressions->collect(pe|pe.PropertyExpression(referencesOnly))->select(e| not e.oclIsUndefined()) in
	if (not content->isEmpty()) then
		thisModule.Operation(self, content)
	else
		OclUndefined
	endif
	endif
;

lazy rule Operation {
	from
		l : AADLI!Operation,
		content: Sequence(AADLBA!PropertyExpression)
	to
		l2 : AADLBA!Operation (
			op <- l.op,
			ownedPropertyExpressions <- content
		)
	do { l2; }
}

helper context AADLI!BooleanLiteral def: PropertyExpression(referencesOnly:Boolean) : AADLBA!BooleanLiteral =
	if(referencesOnly)then
		OclUndefined
	else
		thisModule.BooleanLiteral(self)
	endif
;

lazy rule BooleanLiteral {
	from
		l : AADLI!BooleanLiteral
	to
		l2 : AADLBA!BooleanLiteral (value <- l.value)
	do { l2; }
}

helper context AADLI!ClassifierValue def: PropertyExpression(referencesOnly:Boolean) : AADLBA!ClassifierValue =
	if(referencesOnly)then
		OclUndefined
	else
		thisModule.ClassifierValue(self)
	endif
;

lazy rule ClassifierValue {
	from
		l : AADLI!ClassifierValue
	to
		l2 : AADLBA!ClassifierValue(classifier <- l.classifier.getClassifierImg())
	do 
	{
		l2; 
	}
}

helper context AADLI!Classifier def: getClassifierImg() : AADLBA!ClassifierValue =
	if(not self.oclIsKindOf(AADLBA!Subprogram)) then
		self
	else
		if(self.oclIsTypeOf(AADLBA!SubprogramType)) then
			thisModule.Type(OclUndefined, self)
		else
			thisModule.Implementation(OclUndefined, thisModule.SubprogramType(self.type), self)
		endif
	endif
;


helper context AADLI!ComputedValue def: PropertyExpression(referencesOnly:Boolean) : AADLBA!ComputedValue =
	if(referencesOnly)then
		OclUndefined
	else
		thisModule.ClassifierValue(self)
	endif
;

lazy rule ComputedValue {
	from
		l : AADLI!ComputedValue
	to
		l2 : AADLBA!ComputedValue (function <- l.function)
	do { l2; }
}

helper context AADLI!PropertyConstant def: PropertyExpression(referencesOnly:Boolean) : AADLBA!PropertyConstant =
	if(referencesOnly)then
		OclUndefined
	else
		thisModule.PropertyConstant(self)
	endif
;

lazy rule PropertyConstant {
	from
		l : AADLI!PropertyConstant
	to
		l2 : AADLBA!PropertyConstant (constantValue <- l.constantValue) -- not containment
	do { l2; }
}

helper context AADLI!NamedValue def: PropertyExpression(referencesOnly:Boolean) : AADLBA!NamedValue =
	if(referencesOnly)then
		OclUndefined
	else
		thisModule.NamedValue(self)
	endif
;

lazy rule NamedValue {
	from
		l : AADLI!NamedValue
	to
		l2 : AADLBA!NamedValue (namedValue <- l.namedValue)
	do { l2; }
}

helper context AADLI!ReferenceValue def: PropertyExpression(referencesOnly:Boolean) : AADLBA!ReferenceValue =
	if(referencesOnly)then
		if( not self.getOwnerComponent().oclIsUndefined() )
		then
			thisModule.ReferenceValue(self)
		else
			OclUndefined
		endif
	else
		OclUndefined
	endif
;

lazy rule ReferenceValue {
	from
		l : AADLI!ReferenceValue
	using
	{
		ref : AADLI!Subcomponent = l.containmentPathElement->first().namedElement;
			
		o : AADLI!ComponentInstance = l.getOwnerComponent();
		subi : AADLI!ComponentInstance = o.getReferenceValueContainer(l);
		sub : AADLBA!Subcomponent = thisModule.resolveTemp(subi,'sub');
	}
	to
		l2 : AADLBA!ReferenceValue (containmentPathElement <- Sequence {cpe2,cpe1}),
		cpe1 : AADLBA!ContainmentPathElement (namedElement <- sub),
		cpe2 : AADLBA!ContainmentPathElement (namedElement <- o.getSubcomponentImg())
	do {
		ref.debug('REF');
		sub.debug('SUB');
		o.debug('OWNER');
		l2;
	}
}

helper context AADLI!ComponentInstance def:getReferenceValueContainer(l: AADLI!ReferenceValue) : AADLI!ComponentInstance =
  let ref : AADLI!Subcomponent = l.containmentPathElement->first().namedElement in
  	self.componentInstance->any(subc|subc.name=ref.name)
;

helper context AADLI!InstanceReferenceValue def: PropertyExpression(referencesOnly:Boolean) : AADLBA!InstanceReferenceValue =
	if(referencesOnly)then
		let fake: Boolean = thisModule.getInstanceReferenceInContainmentPath(true, self.getContainerInstance(), self.referencedInstanceObject)  
		in
		
		if(thisModule.ContainmentPathOrder=1)
		then
			thisModule.FirstOrderInstanceReferenceValue(self)
		else if (thisModule.ContainmentPathOrder=2)
			then
				thisModule.SecondOrderInstanceReferenceValue(self)
			else if (thisModule.ContainmentPathOrder>2) then
				OclUndefined.debug('ERROR: Only Second Order RefenrenceValue have been implemented')
			else
				OclUndefined
			endif
		endif
	endif
	else
		OclUndefined
	endif
;

helper context AADLI!Element def: getContainerInstance(): AADLI!InstanceObject = 
	let container : AADLI!InstanceObject = self.eContainer() in
	if(container.oclIsTypeOf(AADLI!ComponentInstance)
			or container.oclIsTypeOf(AADLI!SystemInstance)
			or  container.oclIsTypeOf(AADLI!ConnectionInstance)) then
		container
	else
		container.getContainerInstance()
	endif
;

helper def : ContainmentPathOrder : Integer = 0;

rule getInstanceReferenceInContainmentPath (first: Boolean, container: AADLI!InstanceObject, ref: AADLBA!InstanceObject)
{
	do
	{
		if(first)
		{
			thisModule.ContainmentPathOrder<-0;
		}
		if(container = ref.eContainer())
		{
			thisModule.ContainmentPathOrder<-0;
		}
		else
		{
		if(container.eContainer().oclIsKindOf(AADLI!ComponentInstance))
		{
			if(container.eContainer().componentInstance->contains(ref))
			{
				thisModule.ContainmentPathOrder<-thisModule.ContainmentPathOrder+1;
			}
			else
			{
				if(not ref.eContainer().oclIsUndefined())
				{
					thisModule.ContainmentPathOrder<-thisModule.ContainmentPathOrder+1;
					thisModule.getInstanceReferenceInContainmentPath(false, container, ref.eContainer());
				}
				else
				thisModule.ContainmentPathOrder<-0;
				
			}
		}
	 		
		else
		{
			thisModule.ContainmentPathOrder<-0;
			true.debug('ERROR: Container of ComponentInstance, SystemInstance, or 
				ConnectionInstance is not of subtype of ComponentInstance');
		}
		}
		false;
	}
}

lazy rule FirstOrderInstanceReferenceValue {
	from
		l : AADLI!InstanceReferenceValue
	to
		l2 : AADLBA!ReferenceValue(containmentPathElement <- Sequence{path}),
		path : AADLBA!ContainmentPathElement (namedElement <- l.referencedInstanceObject.getSubcomponentImg())
}

lazy rule SecondOrderInstanceReferenceValue {
	from
		l : AADLI!InstanceReferenceValue
	to
		l2 : AADLBA!ReferenceValue(containmentPathElement <- Sequence{path1,path2}),
		path1 : AADLBA!ContainmentPathElement (namedElement <- l.referencedInstanceObject.eContainer().getSubcomponentImg()),
		path2 : AADLBA!ContainmentPathElement (namedElement <- l.referencedInstanceObject.getSubcomponentImg())
}

helper context AADLI!IntegerLiteral def: PropertyExpression(referencesOnly:Boolean) : AADLBA!IntegerLiteral =
	if(referencesOnly)then
		OclUndefined
	else
		thisModule.IntegerLiteral(self)
	endif
;

lazy rule IntegerLiteral {	
	from
		l : AADLI!IntegerLiteral
	to
		l2 : AADLBA!IntegerLiteral (
			unit <- l.unit,
			value <- l.value,
			base <- l.base)
	do { l2; }
}

helper context AADLI!RealLiteral def: PropertyExpression(referencesOnly:Boolean) : AADLBA!RealLiteral =
	if(referencesOnly)then
		OclUndefined
	else
		thisModule.RealLiteral(self)
	endif
;

lazy rule RealLiteral {
	from
		l : AADLI!RealLiteral
	to
		l2 : AADLBA!RealLiteral (
			unit <- l.unit,
			value <- l.value)
	do { l2; }
}

helper context AADLI!RangeValue def: PropertyExpression(referencesOnly:Boolean) : AADLBA!RangeValue =
	if(referencesOnly)then
		OclUndefined
	else
		thisModule.RangeValue(self)
	endif
;

lazy rule RangeValue {
	from
		l : AADLI!RangeValue,
		referencesOnly:Boolean
	to
		l2 : AADLBA!RangeValue (
			minimum <- l.minimum.PropertyExpression(referencesOnly), 
			maximum <- l.maximum.PropertyExpression(referencesOnly), 
			delta <- l.delta
		)
	do { l2; }
}

helper context AADLI!RecordValue def: PropertyExpression(referencesOnly:Boolean) : AADLBA!RecordValue =
	if(referencesOnly)then
		OclUndefined
	else
		thisModule.RecordValue(self, referencesOnly)
	endif
;

lazy rule RecordValue {
	from
		l : AADLI!RecordValue,
		referencesOnly:Boolean
	to
		l2 : AADLBA!RecordValue (
			ownedFieldValue <- l.ownedFieldValue->collect(fv|thisModule.BasicPropertyAssociation(fv, referencesOnly))
		)
	do { l2; }
}

lazy rule BasicPropertyAssociation {
	from
		bpa : AADLI!BasicPropertyAssociation,
		referencesOnly:Boolean
	to
		bpa2 : AADLBA!BasicPropertyAssociation (
			property <- bpa.property,
			ownedValue <- bpa.ownedValue.PropertyExpression(referencesOnly)
		)
	do { bpa2; }
}

helper context AADLI!StringLiteral def: PropertyExpression(referencesOnly:Boolean) : AADLBA!StringLiteral =
	if(referencesOnly)then
		OclUndefined
	else
		thisModule.StringLiteral(self)
	endif
;

lazy rule StringLiteral{
	from
		l : AADLI!StringLiteral
	to
		l2 : AADLBA!StringLiteral (value <- l.value)
	do { l2; }
}

helper context AADLI!UnitLiteral def: PropertyExpression(referencesOnly:Boolean) : AADLBA!UnitLiteral =
	if(referencesOnly)then
		OclUndefined
	else
		thisModule.UnitLiteral(self)
	endif
;

lazy rule UnitLiteral{
	from
		l : AADLI!UnitLiteral
	to
		l2 : AADLBA!UnitLiteral (name <- l.name)
	do { l2; }
}
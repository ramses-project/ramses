--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLI=http:///AADL2/instance

module Types;

-- TODO
--  ClassifierValue property kind

create 
	OUT 			: AADLBA
from 
	IN 				: AADLI;

uses AADLCopyHelpers;
uses AADLICopyHelpers;

-- Cannot be a matched rule since ComponentType does not appears as a member of the instance tree.
-- Must be called from the component instance which has a reference to it.
rule Type (c : AADLI!ComponentInstance,
		   type : AADLI!ComponentType) {
	using
	{
		typeImg : AADLBA!ComponentType = type.getComponentType();
	}
	do
	{
		if(typeImg.oclIsUndefined())
		{
			if (type.oclIsKindOf(AADLI!BusType)) { typeImg <- thisModule.BusType(type); }
			else if (type.oclIsKindOf(AADLI!VirtualBusType)) { typeImg <- thisModule.VirtualBusType(type); }	
			else if (type.oclIsKindOf(AADLI!DeviceType)) { typeImg <- thisModule.DeviceType(type); }
			else if (type.oclIsKindOf(AADLI!ProcessorType)) { typeImg <- thisModule.ProcessorType(type); }
			else if (type.oclIsKindOf(AADLI!VirtualProcessorType)) { typeImg <- thisModule.VirtualProcessorType(type); }
			else if (type.oclIsKindOf(AADLI!MemoryType)) { typeImg <- thisModule.MemoryType(type); }
			else if (type.oclIsKindOf(AADLI!ProcessType)) 
			{ 
				if (c.oclIsUndefined())
					typeImg <- thisModule.ProcessTypeWithoutInst(type);
				else
					typeImg <- thisModule.ProcessType(c,type);
			}
			else if (type.oclIsKindOf(AADLI!ThreadGroupType)) { typeImg <- thisModule.ThreadGroupType(type); }
			else if (type.oclIsKindOf(AADLI!ThreadType)) 
			{ 
				if (c.oclIsUndefined())
					typeImg <- thisModule.ThreadTypeWithoutInst(type);
				else
					typeImg <- thisModule.ThreadType(c,type);
			}
			else if (type.oclIsKindOf(AADLI!SubprogramType)) { typeImg <- thisModule.SubprogramType(type); }
			else if (type.oclIsKindOf(AADLI!DataType)) { typeImg <- thisModule.DataType(type); }
			
		
			if (typeImg.isDeclared())
			  typeImg.debug('  previously declared type');
			else
			{
			  typeImg.debug('  declare type');
			  thisModule.public().getOwnedClassifiers().add(typeImg);
			}
		
		}
		
		typeImg;
	}
}

unique lazy rule BusType {
 from
 	type : AADLI!BusType
 to
 	typeImg : AADLBA!BusType (
 		name <- type.name
 	)
}

unique lazy rule VirtualBusType {
 from
 	type : AADLI!VirtualBusType
 to
 	typeImg : AADLBA!VirtualBusType (
 		name <- type.name
 	)
}

unique lazy rule DeviceType {
 from
 	type : AADLI!DeviceType
 to
 	typeImg : AADLBA!DeviceType (
 		name <- type.name,
		ownedEventDataPort <- type.ownedEventDataPort->collect(e|thisModule.Port(e)),
	 	ownedDataPort <- type.ownedDataPort->collect(e|thisModule.Port(e)),
	 	ownedEventPort <- type.ownedEventPort->collect(e|thisModule.Port(e))
 	)
}

unique lazy rule ProcessorType {
 from 
    type : AADLI!ProcessorType 
 to 
    typeImg : AADLBA!ProcessorType (
     name <- type.name,
	 ownedEventDataPort <- type.ownedEventDataPort->collect(e|thisModule.Port(e)),
	 ownedDataPort <- type.ownedDataPort->collect(e|thisModule.Port(e)),
	 ownedEventPort <- type.eventPortsMapping()
 )
}

unique lazy rule VirtualProcessorType {
 from 
    type : AADLI!VirtualProcessorType 
 to 
    typeImg : AADLBA!VirtualProcessorType (
     name <- type.name,
	 ownedEventDataPort <- type.ownedEventDataPort->collect(e|thisModule.Port(e)),
	 ownedDataPort <- type.ownedDataPort->collect(e|thisModule.Port(e)),
	 ownedEventPort <- type.eventPortsMapping()
	)
}

unique lazy rule MemoryType {
 from type : AADLI!MemoryType to typeImg : AADLBA!MemoryType (name <- type.name)
}



unique lazy rule ProcessType {
 from
 	c : AADLI!ComponentInstance,
 	type : AADLI!ProcessType
 to 
 	typeImg : AADLBA!ProcessType (
 	 name <- c.uniqueName(),
	 ownedEventDataPort <- c.featureInstance->select(e| e.category=#eventDataPort)->collect(f| thisModule.resolveTemp(f, 'f')),
	 ownedDataPort <- c.featureInstance->select(e| e.category=#dataPort)->collect(f| thisModule.resolveTemp(f, 'f')),
	 ownedEventPort <- c.featureInstance->select(e| e.category=#eventPort)->collect(f| thisModule.resolveTemp(f, 'f')),
	 ownedSubprogramAccess <- c.featureInstance->select(e| e.category=#subprogramAccess)->collect(f| thisModule.resolveTemp(f, 'f').debug('Retreive mapped subprogram access'))
	)
}

unique lazy rule ThreadGroupType {
 from 
 	type : AADLI!ThreadGroupType
 to 
 	typeImg : AADLBA!ThreadGroupType (
 	 name <- type.name,
	 ownedEventDataPort <- type.ownedEventDataPort->collect(e|thisModule.Port(e)),
	 ownedDataPort <- type.ownedDataPort->collect(e|thisModule.Port(e)),
	 ownedEventPort <- type.ownedEventPort->collect(e|thisModule.Port(e))
	)
}

unique lazy rule ThreadType {
 from 
 	c : AADLI!ComponentInstance,
 	type : AADLI!ThreadType
 to 
 	typeImg : AADLBA!ThreadType (
 	 name <- c.uniqueName().debug('thread type'),
	 ownedEventDataPort <- c.featureInstance->select(e| e.category=#eventDataPort)->collect(f| thisModule.resolveTemp(f, 'f').debug('Retreive mapped feature')),
	 ownedDataPort <- c.featureInstance->select(e| e.category=#dataPort)->collect(f| thisModule.resolveTemp(f, 'f')),
	 ownedEventPort <- c.featureInstance->select(e| e.category=#eventPort)->collect(f| thisModule.resolveTemp(f, 'f')),
	 ownedDataAccess <- c.featureInstance->select(e| e.category=#dataAccess)->collect(f| thisModule.resolveTemp(f, 'f')),
	 ownedSubprogramAccess <- c.featureInstance->select(e| e.category=#subprogramAccess)->collect(f| thisModule.resolveTemp(f, 'f').debug('Retreive mapped subprogram access'))
 	)
}

unique lazy rule SubprogramType {
 from 
 	type : AADLI!SubprogramType 
 to 
 	typeImg : AADLBA!SubprogramType (
 		name <- type.name,
		ownedParameter <- type.ownedParameter->collect(p|thisModule.Parameter(p)),
		ownedDataAccess <- type.ownedDataAccess->collect(p|thisModule.DataAccess(p)),
		ownedPropertyAssociation <- type.mapOwnedPropertyAssociationList()
	)
}

--rule addOrderedSubprogramFeatures(type: AADLBA!SubprogramType, typeImg: AADLBA!SubprogramType)
--{
--	do
--	{
--		for(f in type.ownedFeature)
--		{
--			if(f.oclIsKindOf(AADLBA!Parameter))
--			{
--				typeImg.ownedParameter.add(thisModule.Parameter(f));
--			}
--			else if(f.oclIsKindOf(AADLBA!DataAccess))
--			{
--				typeImg.ownedDataAccess.add(thisModule.DataAccess(f));
--			}
--		}
--	}
--}

unique lazy rule DataType {
 from type : AADLI!DataType 
 to typeImg : AADLBA!DataType 
 (
 	name <- type.name,
	ownedPropertyAssociation <- type.mapOwnedPropertyAssociationList()
 )
}
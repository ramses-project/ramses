--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @path AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore


module CreateThreadsBehavior;
create OUT : AADLBA 	from 	IN : AADLBA,
								HOOKS: ATLHOOKS;

uses Services;


rule createThreadBehavior(threadImpl: AADLBA!ThreadImplementation)
{
	to
		behvior_annex : AADLBA!BehaviorAnnex (
            name <- 'behavior_specification',
            states <- Sequence{initialState, mainState, finalState},
            transitions <- Sequence{initTransition,mainTransition,finalTransition}, 
            actions <- Sequence{mainActionBlock}
        ),
		initialState: AADLBA!BehaviorState
		(
			name <- 'init_state',
	    	initial <- true,
	    	complete <- false,
	    	final <- false
		),
		mainState: AADLBA!BehaviorState
		(
			name <- 'main_state',
	    	initial <- false,
	    	complete <- false,
	    	final <- false
		),
		finalState: AADLBA!BehaviorState
		(
			name <- 'final_state',
	    	initial <- false,
	    	complete <- false,
	    	final <- false			
		),
		
		initTransition: AADLBA!BehaviorTransition 
		( 
			name <- 'to_main',
		    sourceState <- initialState,
		    destinationState <- mainState
		),
		mainTransition: AADLBA!BehaviorTransition 
		(
		    name <- 'main_loop',
		    sourceState <- mainState,
		    destinationState <- mainState,
		    actionBlock <- mainActionBlock
		),
		finalTransition: AADLBA!BehaviorTransition 
		(
		    name <- 'to_final',
		    sourceState <- mainState,
		    destinationState <- finalState
		),
		mainActionBlock : AADLBA!BehaviorActionBlock
		(
			content<-mainActionSequence
		),
		mainActionSequence: AADLBA!BehaviorActionSequence
		(
			actions <- threadImpl.getOwnedSubprogramCallSequences().get(0).generateSubprogramCallActionSequence()
		)
	do
	{
		threadImpl.getOwnedAnnexSubclauses().add(behvior_annex);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().putTransitionWhereSrc(initialState, initTransition);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().putTransitionWhereSrc(mainState, mainTransition);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().putTransitionWhereSrc(mainState, finalTransition);
	}
}



helper context AADLBA!SubprogramCallSequence def : generateSubprogramCallActionSequence(): Sequence(AADLBA!SubprogramCallAction) = 
			self.ownedCallSpecification->collect(e|thisModule.generateSubprogramCallActionFromCallSpecication(e));


lazy rule generateSubprogramCallActionFromCallSpecication
{
	from
		callSpecification : AADLBA!SubprogramCall
	using
	{
		orderedFeatures: Sequence(AADLBA!Feature) = callSpecification.calledSubprogram.getOrderedFeature();
	}
	to
		callAction: AADLBA!SubprogramCallAction
		(
			subprogram <- thisModule.generateCalledSubprogramHolder(callSpecification.calledSubprogram)
		)
	do
	{
		for(p in orderedFeatures)
		{
			-- get connected data subcomponent
			if(p.oclIsKindOf(AADLBA!Parameter))
			{
				if(not callSpecification.getConnectedParamDataSubcomponent(p).oclIsUndefined())
				{
					callAction.parameterLabels.add(
						thisModule.DataSubcomponentAsValueExpression
						(
							callSpecification.getConnectedParamDataSubcomponent(p),
							OclUndefined
						));
				}
				else
					true.debug('ERROR : could not find data subcomponent connected to '+p.name+' in call '+callSpecification.name);
			}
			else if(p.oclIsKindOf(AADLBA!DataAccess))
			{
				if(not callSpecification.getConnectedAccessDataSubcomponent(p).oclIsUndefined())
				{
					callAction.parameterLabels.add(
						thisModule.DataSubcomponentAsValueExpression
						(
							callSpecification.getConnectedAccessDataSubcomponent(p),
							OclUndefined
						));
				}
				else
					true.debug('ERROR : could not find data subcomponent connected to '+p.name+' in call '+callSpecification.name);
			}
		}
	}
}

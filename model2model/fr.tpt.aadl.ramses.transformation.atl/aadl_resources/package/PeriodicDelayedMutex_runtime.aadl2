package PeriodicDelayedMutex_runtime
public

with AADL_Runtime;
with Base_Types;
with Data_Model;

---------------------------------------------------------------
-- Linked list types
---------------------------------------------------------------

-- Linked element

data t_aadl_linkedlist_link
properties
  Data_Model::Data_Representation => Struct;
end t_aadl_linkedlist_link;

data implementation t_aadl_linkedlist_link.impl
prototypes
  t_data: data;
  t_link: data t_aadl_linkedlist_link.impl;
subcomponents
  DataPtr   : data t_data -- pointer
              {
                 Data_Model::Data_Representation => Array;
                 Data_Model::Dimension => (0);
              };
              
  Timestamp : data Base_Types::Integer_16;
  PriorityValue  : data Base_Types::Integer_16;
  
  Consumed  : data Base_Types::Boolean 
              { 
              	 Data_Model::Initial_Value => ("TRUE");
              };
  
  Previous    : data t_link
              {
                 Data_Model::Data_Representation => Array;
                 Data_Model::Dimension => (0);
              };
              
  Next        : data t_link
              {
                 Data_Model::Data_Representation => Array;
                 Data_Model::Dimension => (0);
              };
              
end t_aadl_linkedlist_link.impl;


-- Pointer on linked element

-- data t_aadl_linkedlist_link_ptr
-- end t_aadl_linkedlist_link_ptr;

-- data implementation t_aadl_linkedlist_link_ptr.impl
-- prototypes
--  t_data: data;
-- properties
--  Data_Model::Data_Representation => Array;
--  Data_Model::Dimension => (0);
--  Data_Model::Base_Type => (classifier(t_aadl_linkedlist_link.impl));
-- end t_aadl_linkedlist_link_ptr.impl;


-- Linked list structure

data t_aadl_thread_data_queue_content
properties
  Data_Model::Data_Representation => Array;
  Data_Model::Base_Type => (classifier(t_aadl_linkedlist_link.impl));
end t_aadl_thread_data_queue_content;

data t_aadl_thread_data_queue
properties
  Data_Model::Data_Representation => Struct;
end t_aadl_thread_data_queue;

data implementation t_aadl_thread_data_queue.impl
prototypes
  t_link: data t_aadl_linkedlist_link.impl;
  t_lock: data;
subcomponents
  Values: data t_aadl_thread_data_queue_content;
  Size: data Base_Types::Integer;
  First: data t_link
        {
            Data_Model::Data_Representation => Array;
            Data_Model::Dimension => (0);
        };
  Last: data t_link
        {
            Data_Model::Data_Representation => Array;
            Data_Model::Dimension => (0);
        };
  Lock: data t_lock;
end t_aadl_thread_data_queue.impl;

subprogram Init_LinkedList
features
  PortVariable: requires data access t_aadl_thread_data_queue.impl;
  Size : in parameter Base_Types::Integer;
annex behavior_specification {**
  variables
    --i : Base_Types::Integer_16;
    j : Base_Types::Integer_16;
    iMax: Base_Types::Integer_16;
  states
    s : initial final state;
  transitions
    t: s-[]->s {
    	PortVariable.Size  := Size;
    	PortVariable.First := PortVariable.Values[0];
    	PortVariable.Last  := PortVariable.Values[0];
    	
    	iMax := Size - 2;
    	for(i : Base_Types::Integer_16 in 0 .. iMax)
    	{
    	   j := i + 1;
    	   PortVariable.Values[i].Next := PortVariable.Values[j];
    	   PortVariable.Values[j].Previous := PortVariable.Values[i]
    	}
    };
**};
end Init_LinkedList;

---------------------------------------------------------------
-- Lock Services
---------------------------------------------------------------
subprogram Get_Resource
prototypes
  t_port: data t_aadl_thread_data_queue.impl;
features
  PortVariable: requires data access t_port;
end Get_Resource;

subprogram Release_Resource
prototypes
  t_port: data t_aadl_thread_data_queue.impl;
features
  PortVariable: requires data access t_port;
end Release_Resource;

---------------------------------------------------------------
-- Runtime Services
---------------------------------------------------------------
subprogram Put_Value
prototypes
  t_data: data;
  t_link: data t_aadl_linkedlist_link.impl;
  t_port: data t_aadl_thread_data_queue.impl;
features
  PortVariable    : requires data access t_port; 
  DataValue       : requires data access t_data;
  CurrentDeadline : in parameter Base_Types::Integer_16;
  PriorityValue   : in parameter Base_Types::Integer_16;
end Put_Value;

subprogram implementation Put_Value.impl
prototypes
  t_data_sub: data;
  t_link_sub: data t_aadl_linkedlist_link.impl;
  t_port_sub: data t_aadl_thread_data_queue.impl;
  Get_Res       : subprogram Get_Resource;
  Release_Res   : subprogram Release_Resource;
subcomponents
  CurrentLink   : data t_link_sub
                  { Data_Model::Data_Representation => Array;
                    Data_Model::Dimension => (0); };
  AvailableLink : data t_link_sub
                  { Data_Model::Data_Representation => Array;
                    Data_Model::Dimension => (0); };
annex behavior_specification {**
  variables
    iterations    : Base_Types::Integer;
  states
    s: initial final state;
  transitions
    t: s -[]-> s
    {
      Get_Res! (PortVariable);
      
      CurrentLink := PortVariable.First;
      iterations := 0;
      while (not CurrentLink.Consumed 
             and (CurrentLink.Timestamp < CurrentDeadline 
  			         or (CurrentLink.Timestamp=CurrentDeadline 
  			             and CurrentLink.PriorityValue>PriorityValue))
  			 and (iterations < PortVariable.Size))
      {
  	     CurrentLink := CurrentLink.Next;
  	     iterations := iterations + 1
      };
      
      if (iterations < PortVariable.Size and PortVariable.Last.Consumed)
  	  {
  	     AvailableLink                 := PortVariable.Last;
  	     
	     AvailableLink.DataPtr         := DataValue;
	     AvailableLink.Timestamp       := CurrentDeadline;
	     AvailableLink.PriorityValue   := PriorityValue;
	     AvailableLink.Consumed        := FALSE;
	       
	     if (not CurrentLink.Consumed)
	     {  
	       AvailableLink.Next.Previous     := AvailableLink.Previous;
           AvailableLink.Previous.Next     := AvailableLink.Next;
           AvailableLink.Next              := CurrentLink;
	       AvailableLink.Previous          := CurrentLink.Previous; 
	       CurrentLink.Previous.Next       := AvailableLink;
	       CurrentLink.Previous            := AvailableLink
	     }
	     end if;
	           
	     PortVariable.Last         := PortVariable.Last.Next
  	  }
  	  end if;
      
      Release_Res! (PortVariable)
    };
**};
end Put_Value.impl;

subprogram Receive_Input
prototypes
  t_port: data t_aadl_thread_data_queue.impl;
  t_link: data t_aadl_linkedlist_link.impl;
features
  PeriodValue   : in parameter Base_Types::Integer_16;
  CurrentPeriod : in parameter Base_Types::Integer_16;
  PortVariable  : requires data access t_port;
end Receive_Input;

subprogram implementation Receive_Input.impl
prototypes
  t_link_sub    : data t_aadl_linkedlist_link.impl;
  Get_Res       : subprogram Get_Resource;
  Release_Res   : subprogram Release_Resource;
subcomponents
  CurrentLink : data t_link_sub
  		{ Data_Model::Data_Representation => Array;
          Data_Model::Dimension => (0); };
annex behavior_specification {**
  variables
    LastPeriod  : Base_Types::Integer_16;
    
    i : Base_Types::Integer_16;
  states
    s: initial final state;
  transitions
    t: s-[]->s {
      -- Skip elements received before previous period 
      -- and not already consumed.
    
      Get_Res! (PortVariable);
    
      if (CurrentPeriod > 0)
      {
        LastPeriod := CurrentPeriod - PeriodValue;
        i := 0;
        
        CurrentLink := PortVariable.First;
        while ((CurrentLink.Timestamp <= LastPeriod)
               and (i < PortVariable.Size))
        {
           CurrentLink.Consumed := TRUE;
           CurrentLink := CurrentLink.Next;
           i := i + 1
        };
        PortVariable.First := CurrentLink
      }
      end if;
      
      Release_Res!(PortVariable)
    };
**};
end Receive_Input.impl;

subprogram Next_Value
prototypes
  t_data: data;
  t_link: data t_aadl_linkedlist_link.impl;
  t_port: data t_aadl_thread_data_queue.impl;
features
  PortVariable: requires data access t_port;
  DataValue: out parameter t_data;
  CurrentPeriod : in parameter Base_Types::Integer_16; 
end Next_Value;

subprogram implementation Next_Value.impl
prototypes
  t_link_sub: data t_aadl_linkedlist_link.impl;
subcomponents
  First: data t_link_sub
     { Data_Model::Data_Representation => Array;
       Data_Model::Dimension => (0); };
annex behavior_specification {**
  states
    s: initial final state;
  transitions
    t: s -[]-> s
    {
      First := PortVariable.First;
      if ((First.Next.Timestamp <= CurrentPeriod) 
      		and (First.Next.Consumed=FALSE))
      {
        DataValue := First.Next.DataPtr;
        First.Consumed := TRUE;
        PortVariable.First := First.Next
      }
      end if -- else DataValue is unchanged (use previous value)
    };
**};
end Next_Value.impl;

subprogram Send_Output
features 
  PeriodValue     : in parameter Base_Types::Integer_16;
  DeadlineValue   : in parameter Base_Types::Integer_16;
  CurrentPeriod   : in out parameter Base_Types::Integer_16;
  CurrentDeadline : in out parameter Base_Types::Integer_16;
annex behavior_specification {**
  states
    s : initial final state;
  transitions
    t : s-[]->s
    {
      CurrentPeriod := CurrentPeriod + PeriodValue;
      CurrentDeadline := CurrentPeriod + DeadlineValue
    };
**};
end Send_Output;

end PeriodicDelayedMutex_runtime;
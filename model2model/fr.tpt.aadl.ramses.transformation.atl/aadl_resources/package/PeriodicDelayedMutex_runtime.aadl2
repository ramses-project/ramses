package PeriodicDelayedMutex_runtime
public

with AADL_Runtime;
with Base_Types;
with Data_Model;

---------------------------------------------------------------
-- Linked list types
---------------------------------------------------------------

-- Linked element

data t_aadl_linkedlist_link
properties
  Data_Model::Data_Representation => Struct;
end t_aadl_linkedlist_link;

data implementation t_aadl_linkedlist_link.impl
prototypes
  t_request: data;
subcomponents
  DataPtr   : data t_request -- pointer
              {
                 Data_Model::Data_Representation => Array;
                 Data_Model::Dimension => (0);
              };
              
  Timestamp : data Base_Types::Integer_16;
  Priority  : data Base_Types::Integer_16;
  
  Consumed  : data Base_Types::Boolean 
              { 
              	 Data_Model::Initial_Value => ("TRUE");
              };
  
  Previous  : data t_aadl_linkedlist_link_ptr.impl;
  Next      : data t_aadl_linkedlist_link_ptr.impl;
end t_aadl_linkedlist_link.impl;


-- Pointer on linked element

data t_aadl_linkedlist_link_ptr
end t_aadl_linkedlist_link_ptr;

data implementation t_aadl_linkedlist_link_ptr.impl
prototypes
  t_request: data;
properties
  Data_Model::Data_Representation => Array;
  Data_Model::Dimension => (0);
  Data_Model::Base_Type => (classifier(t_aadl_linkedlist_link.impl));
end t_aadl_linkedlist_link_ptr.impl;


-- Linked list structure

data t_aadl_thread_data_queue_content
properties
  Data_Model::Data_Representation => Array;
  Data_Model::Base_Type => (classifier(t_aadl_linkedlist_link.impl));
end t_aadl_thread_data_queue_content;

-- data implementation t_aadl_thread_data_queue_content.impl
-- prototypes
--   t_request: data;
-- end t_aadl_thread_data_queue_content.impl;

data t_aadl_thread_data_queue
properties
  Data_Model::Data_Representation => Struct;
end t_aadl_thread_data_queue;

data implementation t_aadl_thread_data_queue.impl
prototypes
  t_request: data;
subcomponents
  Values: data t_aadl_thread_data_queue_content;
  Size: data Base_Types::Integer;
  UsedSize: data Base_Types::Integer;
  First: data t_aadl_linkedlist_link_ptr.impl;
  Free: data t_aadl_linkedlist_link_ptr.impl;
end t_aadl_thread_data_queue.impl;

-- data implementation t_aadl_thread_data_queue.impl
-- prototypes
--   t_request: data;
-- subcomponents
--   Size: data Base_Types::Integer;
--   UsedSize: data Base_Types::Integer;
--   First: data t_aadl_linkedlist_link_ptr.impl;
--   Free: data t_aadl_linkedlist_link_ptr.impl;
-- end t_aadl_thread_data_queue.impl;

subprogram Init_LinkedList
features
  PortVariable: requires data access t_aadl_thread_data_queue.impl;
  Size : in parameter Base_Types::Integer;
annex behavior_specification {**
  variables
    --i : Base_Types::Integer_16;
    j : Base_Types::Integer_16;
    iMax: Base_Types::Integer_16;
  states
    s : initial final state;
  transitions
    t: s-[]->s {
    	PortVariable.Size  := Size;
    	PortVariable.First := PortVariable.Values[0];
    	PortVariable.Free  := PortVariable.Values[0];
    	
    	iMax := Size - 2;
    	for(i : Base_Types::Integer_16 in 0 .. iMax)
    	{
    	   j := i + 1;
    	   PortVariable.Values[i].Next := PortVariable.Values[j];
    	   PortVariable.Values[j].Previous := PortVariable.Values[i]
    	}
    };
**};
end Init_LinkedList;

---------------------------------------------------------------
-- Runtime Services
---------------------------------------------------------------

subprogram Get_Resource
features
  PortVariable: requires data access t_aadl_thread_data_queue.impl; -- Reference to port variable
end Get_Resource;

subprogram Release_Resource
features
  PortVariable: requires data access t_aadl_thread_data_queue.impl; -- Reference to port variable
end Release_Resource;


subprogram Put_Value
prototypes
  t_request: data;
features
  PortVariable    : requires data access t_aadl_thread_data_queue.impl; 
  DataValue       : requires data access t_request;
  CurrentDeadline : requires data access Base_Types::Integer_16;
  Priority        : requires data access Base_Types::Integer_16;
annex behavior_specification {**
  variables
    CurrentLink   : t_aadl_linkedlist_link_ptr.impl;
    AvailableLink : t_aadl_linkedlist_link_ptr.impl;
    iterations    : Base_Types::Integer;
  states
    s: initial final state;
  transitions
    t: s -[]-> s
    {
      Get_Resource! (PortVariable);
      
      CurrentLink := PortVariable.First;
      iterations := 0;
      while (not CurrentLink.Consumed 
             and (CurrentLink.Timestamp < CurrentDeadline 
  			         or (CurrentLink.Timestamp=CurrentDeadline 
  			             and CurrentLink.Priority>Priority))
  			 and (iterations < PortVariable.Size))
      {
  	     CurrentLink := CurrentLink.Next;
  	     iterations := iterations + 1
      };
      
      if (iterations < PortVariable.Size and PortVariable.Free.Consumed)
  	  {
  	     AvailableLink             := PortVariable.Free;
  	     
	     AvailableLink.DataPtr     := DataValue;
	     AvailableLink.Timestamp   := CurrentDeadline;
	     AvailableLink.Priority    := Priority;
	     AvailableLink.Consumed    := FALSE;
	       
	     if (not CurrentLink.Consumed)
	     {  
	       Insert_Link!(AvailableLink, CurrentLink)
	     }
	     end if;
	           
	     PortVariable.Free         := PortVariable.Free.Next;
	     PortVariable.UsedSize     := PortVariable.UsedSize + 1
  	  }
  	  end if;
      
      Release_Resource! (PortVariable)
    };
**};
end Put_Value;

subprogram Insert_Link
features
  Link        : in out parameter t_aadl_linkedlist_link_ptr.impl;
  Follower    : in out parameter t_aadl_linkedlist_link_ptr.impl;
annex behavior_specification {**
  states
    s: initial final state;
  transitions
    t: s -[]-> s
    {
      Link.Next.Previous     := Link.Previous;
      Link.Previous.Next     := Link.Next;
      Link.Next              := Follower;
	  Link.Previous          := Follower.Previous; 
	  Follower.Previous.Next := Link;
	  Follower.Previous      := Link
    };
**};
end Insert_Link;

subprogram Receive_Input
prototypes
  t_request: data;
features
  Period : requires data access Base_Types::Integer_16;
  CurrentPeriod : requires data access Base_Types::Integer_16;
  PortVariable : requires data access t_aadl_thread_data_queue.impl;
  First : in out parameter t_aadl_linkedlist_link_ptr.impl;
annex behavior_specification {**
  variables
    LastPeriod  : Base_Types::Integer_16;
    CurrentLink : t_aadl_linkedlist_link_ptr.impl;
    Next : t_aadl_linkedlist_link_ptr.impl;
    i : Base_Types::Integer_16;
  states
    s: initial final state;
  transitions
    t: s-[]->s {
      -- Skip elements received before previous period 
      -- and not already consumed.
    
      Get_Resource! (PortVariable);
    
      if (CurrentPeriod > 0)
      {
        LastPeriod := CurrentPeriod - Period;
        i := 0;
        
        CurrentLink := PortVariable.First;
        while ((CurrentLink.Timestamp <= LastPeriod)
               and (i < PortVariable.Size))
        {
           Next := CurrentLink.Next;
           Remove_Link! (CurrentLink, PortVariable);
           CurrentLink := Next;
           i := i + 1
        };
        First := CurrentLink
      }
      end if;
      
      Release_Resource!(PortVariable)
    };
**};
end Receive_Input;

subprogram Remove_Link
features
  CurrentLink : in out parameter t_aadl_linkedlist_link_ptr.impl;
  PortVariable : requires data access t_aadl_thread_data_queue.impl; -- Reference to port variable
annex behavior_specification {**
  states
    s: initial final state;
  transitions
    t: s -[]-> s
    {
      CurrentLink.Consumed := TRUE;
           
      -- remove link
      CurrentLink.Previous.Next := CurrentLink.Next;
      CurrentLink.Next.Previous := CurrentLink.Previous;
       
      -- add link at the end of the chain
      CurrentLink.Previous := PortVariable.Free;
      CurrentLink.Next := PortVariable.Free.Next;
      PortVariable.Free.Next.Previous := CurrentLink;
      PortVariable.Free.Next := CurrentLink
    };
**};
end Remove_Link;

subprogram Next_Value
prototypes
  t_request: data;
features
  PortVariable: requires data access t_aadl_thread_data_queue.impl; -- Reference to port variable
  DataValue: out parameter t_request; -- Reference to value being retrieved
  First : in out parameter t_aadl_linkedlist_link_ptr.impl;
  CurrentPeriod : requires data access Base_Types::Integer_16; 
annex behavior_specification {**
  variables
    Next : t_aadl_linkedlist_link_ptr.impl;
  states
    s: initial final state;
  transitions
    t: s -[]-> s
    {
      Get_Resource! (PortVariable);
      
      Next := First.Next;
      
      if ((Next.Timestamp <= CurrentPeriod) and (Next.Consumed=FALSE))
      {
        DataValue := Next.DataPtr;
        Remove_Link! (First, PortVariable);
        First := Next;
        PortVariable.UsedSize := PortVariable.UsedSize - 1
      }
      end if; -- else DataValue is unchanged (use previous value)
      
      Release_Resource! (PortVariable)
    };
**};
end Next_Value;

subprogram Send_Output
prototypes
  t_request: data;
features
  PortVariable: requires data access t_aadl_thread_data_queue.impl; -- Reference to port variable
end Send_Output;

subprogram Compute_Deadline
features 
  Period          : requires data access Base_Types::Integer_16;
  Deadline        : requires data access Base_Types::Integer_16;
  CurrentPeriod   : requires data access Base_Types::Integer_16;
  CurrentDeadline : requires data access Base_Types::Integer_16;
annex behavior_specification {**
  states
    s : initial final state;
  transitions
    t : s-[]->s
    {
      CurrentPeriod := CurrentPeriod + Period;
      CurrentDeadline := CurrentPeriod + Deadline
    };
**};
end Compute_Deadline;

end PeriodicDelayedMutex_runtime;
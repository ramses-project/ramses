--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLI=http:///AADL2/instance

module ExpandSubprogramCalls;

create 
	OUT 				   : AADLBA
from 
	IN 					   : AADLI,
	BASE_TYPES			   : AADLBA,
	AADL_RUNTIME		   : AADLBA,
	DATA_MODEL			   : AADLBA,
	SCHEDULER_CONSTANTS	   : AADLBA,
	SCHEDULER_REALIZATIONS : AADLBA,
	SCHEDULER_RUNTIME	   : AADLBA;

uses AADLCopyHelpers;
uses AADLICopyHelpers;
uses FHSHelpers;
uses AADLRuntimeHelpers;
uses Services;

helper context AADLBA!ThreadImplementation def : createBAVariablesForSpgParameters() : Sequence(AADLBA!BehaviorVariable) =
	self.callSequence().getAllOutParameters()->collect(p|thisModule.CreateVariableForParameter(p))
;

unique lazy rule CreateVariableForParameter {
 from
	p : AADLI!Parameter
 using
 {
	pName : String = p.eContainer().name.concat('_').concat(p.name);
 }
 to
	v : AADLBA!BehaviorVariable (
		DataUniqueComponentClassifierReference <- type,
		LocalVariableDeclarators <- Sequence{decl}
	),
	type : AADLBA!UniqueComponentClassifierReference (aadlRef <- p.dataFeatureClassifier),
	decl : AADLBA!Declarator (identifierOwned <- thisModule.CreateIdentifier(pName, OclUndefined))
  do 
  { 
  	pName.debug('  create behavior variable');
  	v;
  }
}


rule CreateAction_SubprogramCall (behavior     : AADLBA!BehaviorAnnex,
								  call 		   : AADLBA!SubprogramCall)
{
 using
 {
 	seq : AADLBA!SubprogramCallSequence = call.eContainer();
 	owner : AADLBA!ComponentImplementation = seq.eContainer();
 }
 to
   callAction			: AADLBA!SubprogramCallAction (
		subprogramNames				<- Sequence {subprogramName},
		subprogramReference			<- subprogramRef,
		parameterLabels				<- call.calledSubprogram.ownedParameter
										->collect(p|behavior.getBehaviorVariableForParameter(owner, call, p))
										->select(v|not v.oclIsUndefined()) -- remove when input ports will be removed
										->collect(v|thisModule.CreateBAName(v.getName(), v))
	),
	
	subprogramName		: AADLBA!Name (
		identifierOwned 			<- thisModule.CreateIdentifier(call.calledSubprogram.name, call.calledSubprogram)
	),
	
	subprogramRef		: AADLBA!UniqueComponentClassifierReference (
		aadlRef 					<- call.calledSubprogram
	)
 do { callAction; }
}

rule addParameterConnection(implImg: AADLBA!ThreadImplementation, name: String, param: AADLBA!Parameter, ctx:AADLBA!Context, variable: AADLBA!DataSubcomponent)
{
  to
	connectedParam: AADLBA!ConnectedElement
	(
		connectionEnd<-param
	),
	connectedSubcomponent: AADLBA!ConnectedElement
	(
		connectionEnd<-variable
	),
	paramConnection: AADLBA!ParameterConnection
	(
		name<-name,
		source<-connectedParam,
		destination<-connectedSubcomponent
	)
  do
  {
  	if(not ctx.oclIsUndefined())
  		connectedParam.setContext(ctx);
  	implImg.ownedParameterConnection.add(paramConnection);
  }
}

rule addSuprogramCallParameterConnection(implImg:AADLBA!ThreadImplementation, paramConnection: AADLI!ParameterConnection)
{
	using
	{
		dataSubcomponent: AADLBA!DataSubcomponent = thisModule.addParameterLocalVariable(paramConnection.source, implImg);
	}
	do
	{
		thisModule.addParameterConnection(implImg, 'dest_'+paramConnection.destination.connectionEnd.name,
							paramConnection.destination.getConnFeatureImg(implImg),
							paramConnection.destination.getConnContextImg(implImg),
							dataSubcomponent);
			
		thisModule.addParameterConnection(implImg, 'src_'+paramConnection.source.connectionEnd.name ,
							paramConnection.source.getConnFeatureImg(implImg),
							paramConnection.source.getConnContextImg(implImg),
							dataSubcomponent);
	}
}

rule mapSubprogramParameters(implImg: AADLBA!ComponentImplementation, impl: AADLI!ComponentClassifier)
{
	do
	{
		for(paramConnection in impl.ownedParameterConnection)
		{
			if(paramConnection.source.connectionEnd.oclIsKindOf(AADLI!Parameter) and paramConnection.destination.connectionEnd.oclIsKindOf(AADLI!Parameter))
			{
				thisModule.addSuprogramCallParameterConnection(implImg, paramConnection);
			}
		}
	}
}


unique lazy rule addParameterLocalVariable
{
	from
		paramConnectionEnd: AADLI!ParameterConnectionEnd,
		implImg: AADLBA!ThreadImplementation
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name <- 'from_'+paramConnectionEnd.connectionEnd.name,
			dataSubcomponentType <- paramConnectionEnd.getConnFeatureImg(implImg).dataFeatureClassifier
		)
	do
	{
		implImg.ownedDataSubcomponent.add(dataSubcomponent.debug('Added Parameter Local Variable'));
		
	}
}

lazy rule mapConstantParameter
{
	from
		p: AADLBA!Parameter,
		value : String,
		call: AADLI!SubprogramCall,
		implImg : AADLBA!ComponentImplementation
	using
	{
		initValuePE: AADLBA!PropertyExpression = thisModule.CreateStringLiteralPropertyExpression(value);
	}
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name <- 'constant_'+call.name+'_'+p.name,
			dataSubcomponentType <- p.dataFeatureClassifier,
			ownedPropertyAssociation <- Sequence {thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL',lv)}
		),
		lv: AADLBA!ListValue
		(
			ownedListElement <- Sequence{initValuePE}
		)
		
	do
	{
		implImg.ownedDataSubcomponent.add(dataSubcomponent);
		
		thisModule.addParameterConnection(implImg, 'dest_'+dataSubcomponent.name,
							p,
							call,
							dataSubcomponent);
	}
}

helper context AADLBA!SubprogramType def: getOrderedFeature() : Sequence(AADLBA!Feauture) =
	ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().orderFeatures(self);


helper def: getStringListValue(v : AADLBA!ModalPropertyValue) : Sequence(String) = 
	v.ownedValue.getOwnedListElements()->collect(e|e.getValue())
;



helper context AADLBA!SubprogramSubcomponentType def: getSubprogramType() : AADLBA!SubprogramType = 
	if(self.oclIsKindOf(AADLBA!SubprogramType)) then
		self
	else 
		if(self.oclIsKindOf(AADLBA!SubprogramImplementation)) then
			self.type
		else
			OclUndefined
		endif
	endif
;

helper context AADLBA!SubprogramCall def:getConnectedParamDataSubcomponent(p: AADLBA!Parameter) : AADLBA!DataSubcomponent =
	if(not self.eContainer().eContainer().getOwnedParameterConnections()->any
	( paramCnx |
		paramCnx.source.getContext() = self and paramCnx.source.connectionEnd = p
	).oclIsUndefined())
	then
		self.eContainer().eContainer().getOwnedParameterConnections()->any
		( paramCnx |
			paramCnx.source.getContext() = self and paramCnx.source.connectionEnd = p
		).destination.connectionEnd
	else 
		if(not self.eContainer().eContainer().getOwnedParameterConnections()->any
		( paramCnx |
			paramCnx.destination.getContext() = self and paramCnx.destination.connectionEnd = p
		).oclIsUndefined())
		then
			self.eContainer().eContainer().getOwnedParameterConnections()->any
			( paramCnx |
				paramCnx.destination.getContext() = self and paramCnx.destination.connectionEnd = p
			).source.connectionEnd
		else
			OclUndefined.debug('ERROR: Could not find Parameter Connection for '+p.name+' in '+self.name)
		endif
	endif
;

helper context AADLBA!SubprogramCall def:getConnectedAccessDataSubcomponent(p: AADLBA!DataAccess) : AADLBA!DataSubcomponent =
	if(not self.eContainer().eContainer().getOwnedAccessConnections()->any
	( accessCnx |
		accessCnx.source.getContext() = self and accessCnx.source.connectionEnd = p
	).oclIsUndefined())
	then
		self.eContainer().eContainer().getOwnedAccessConnections()->any
		( accessCnx |
			accessCnx.source.getContext() = self and accessCnx.source.connectionEnd = p
		).destination.connectionEnd
	else 
		if(not self.eContainer().eContainer().getOwnedAccessConnections()->any
		( accessCnx |
			accessCnx.destination.getContext() = self and accessCnx.destination.connectionEnd = p
		).oclIsUndefined())
		then
			self.eContainer().eContainer().getOwnedAccessConnections()->any
			( accessCnx |
				accessCnx.destination.getContext() = self and accessCnx.destination.connectionEnd = p
			).source.connectionEnd
		else
			OclUndefined
		endif
	endif
;
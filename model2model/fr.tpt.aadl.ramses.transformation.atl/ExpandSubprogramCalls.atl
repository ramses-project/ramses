--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLI=http:///AADL2/instance

module ExpandSubprogramCalls;

create 
	OUT 				   : AADLBA
from 
	IN 					   : AADLI,
	BASE_TYPES			   : AADLBA,
	AADL_RUNTIME		   : AADLBA,
	DATA_MODEL			   : AADLBA,
	SCHEDULER_CONSTANTS	   : AADLBA,
	SCHEDULER_REALIZATIONS : AADLBA,
	SCHEDULER_RUNTIME	   : AADLBA;

uses AADLCopyHelpers;
uses AADLICopyHelpers;
uses FHSHelpers;
uses AADLRuntimeHelpers;
uses Services;

helper context AADLBA!ThreadImplementation def : createBAVariablesForSpgParameters() : Sequence(AADLBA!BehaviorVariable) =
	self.callSequence().getAllOutParameters()->collect(p|thisModule.CreateVariableForParameter(p))
;

unique lazy rule CreateVariableForParameter {
 from
	p : AADLI!Parameter
 using
 {
	pName : String = p.eContainer().name.concat('_').concat(p.name);
 }
 to
	v : AADLBA!BehaviorVariable (
		DataUniqueComponentClassifierReference <- type,
		LocalVariableDeclarators <- Sequence{decl}
	),
	type : AADLBA!UniqueComponentClassifierReference (aadlRef <- p.dataFeatureClassifier),
	decl : AADLBA!Declarator (identifierOwned <- thisModule.CreateIdentifier(pName, OclUndefined))
  do 
  { 
  	pName.debug('  create behavior variable');
  	v;
  }
}


rule CreateAction_SubprogramCall (behavior     : AADLBA!BehaviorAnnex,
								  call 		   : AADLBA!SubprogramCall)
{
 using
 {
 	seq : AADLBA!SubprogramCallSequence = call.eContainer();
 	owner : AADLBA!ComponentImplementation = seq.eContainer();
 }
 to
   callAction			: AADLBA!SubprogramCallAction (
		subprogramNames				<- Sequence {subprogramName},
		subprogramReference			<- subprogramRef,
		parameterLabels				<- call.calledSubprogram.ownedParameter
										->collect(p|behavior.getBehaviorVariableForParameter(owner, call, p))
										->select(v|not v.oclIsUndefined()) -- remove when input ports will be removed
										->collect(v|thisModule.CreateBAName(v.getName(), v))
	),
	
	subprogramName		: AADLBA!Name (
		identifierOwned 			<- thisModule.CreateIdentifier(call.calledSubprogram.name, call.calledSubprogram)
	),
	
	subprogramRef		: AADLBA!UniqueComponentClassifierReference (
		aadlRef 					<- call.calledSubprogram
	)
 do { callAction; }
}

rule addParameterConnection(implImg: AADLBA!ThreadImplementation, name: String, param: AADLBA!Parameter, ctx:AADLBA!Context, variable: AADLBA!DataSubcomponent)
{
  to
	connectedParam: AADLBA!ConnectedElement
	(
		connectionEnd<-param
	),
	connectedSubcomponent: AADLBA!ConnectedElement
	(
		connectionEnd<-variable
	),
	paramConnection: AADLBA!ParameterConnection
	(
		name<-name,
		source<-connectedParam,
		destination<-connectedSubcomponent
	)
  do
  {
  	connectedParam.setContext(ctx);
  	implImg.ownedParameterConnection.add(paramConnection);
  }
}

rule addDataAccessConnection(implImg: AADLBA!ComponentImplementation, name: String, param: AADLBA!DataAccess, ctx:AADLBA!Context, variable: AADLBA!DataSubcomponent)
{
  to
	connectedParam: AADLBA!ConnectedElement
	(
		connectionEnd<-param
	),
	connectedSubcomponent: AADLBA!ConnectedElement
	(
		connectionEnd<-variable
	),
	accessConnection: AADLBA!AccessConnection
	(
		name<-name,
		source<-connectedParam,
		accessCategory<-#data,
		destination<-connectedSubcomponent
	)
  do
  {
  	connectedParam.setContext(ctx);
  	implImg.ownedAccessConnection.add(accessConnection);
  }
}

rule addSuprogramCallParameterConnection(implImg:AADLBA!ThreadImplementation, paramConnection: AADLI!ParameterConnection)
{
	using
	{
		dataSubcomponent: AADLBA!DataSubcomponent = thisModule.addParameterLocalVariable(implImg,  paramConnection.source);
	}
	do
	{
		thisModule.addParameterConnection(implImg, 'dest_'+dataSubcomponent.name,
							paramConnection.destination.getConnFeatureImg(implImg),
							paramConnection.destination.getConnContextImg(implImg),
							dataSubcomponent);
			
		thisModule.addParameterConnection(implImg, 'src_'+dataSubcomponent.name ,
							paramConnection.source.getConnFeatureImg(implImg),
							paramConnection.source.getConnContextImg(implImg),
							dataSubcomponent);
	}
}

unique lazy rule addParameterLocalVariable
{
	from
		implImg: AADLBA!ThreadImplementation,
		paramConnectionEnd: AADLI!ParameterConnectionEnd
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name <- 'from_'+paramConnectionEnd.connectionEnd.name,
			dataSubcomponentType <- paramConnectionEnd.getConnFeatureImg(implImg).dataFeatureClassifier
		)
	do
	{
		implImg.ownedDataSubcomponent.add(dataSubcomponent);
	}
}

lazy rule generateSubprogramCallActionFromCallSpecication
{
	from
		callSpecification : AADLBA!SubprogramCall
	using
	{
		orderedFeatures: Sequence(AADLBA!Feature) = callSpecification.calledSubprogram.getOrderedFeature();
	}
	to
		callAction: AADLBA!SubprogramCallAction
		(
			subprogramReference <- thisModule.generateUCCR(callSpecification.calledSubprogram)
		)
	do
	{
		for(p in orderedFeatures)
		{
			-- get connected data subcomponent
			if(p.oclIsKindOf(AADLBA!Parameter))
			{
				if(not callSpecification.getConnectedParamDataSubcomponent(p).oclIsUndefined())
				{
					callAction.parameterLabels.add(
						thisModule.DataSubcomponentAsValueExpression
						(
							callSpecification.getConnectedParamDataSubcomponent(p),
							OclUndefined
						));
				}
			}
			else if(p.oclIsKindOf(AADLBA!DataAccess))
			{
				if(not callSpecification.getConnectedAccessDataSubcomponent(p).oclIsUndefined())
				{
					callAction.parameterLabels.add(
						thisModule.DataSubcomponentAsValueExpression
						(
							callSpecification.getConnectedAccessDataSubcomponent(p),
							OclUndefined
						));
				}
			}
		}
	}
}

helper context AADLBA!SubprogramType def: getOrderedFeature() : Sequence(AADLBA!Feauture) =
	ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().orderFeatures(self);
--	if(self.getModalPropertyValue('Ordered_Features').oclIsUndefined())then
--		self.ownedFeature
--	else
--		let orderedFeatureNames : Sequence(String) = thisModule.getStringListValue(self.getModalPropertyValue('Ordered_Features')) in
--		orderedFeatureNames->collect
--		(
--			e|self.ownedFeature->any(f|e.equalsIgnoreCase(f.name))
--		)
--	endif
--;


helper def: getStringListValue(v : AADLBA!ModalPropertyValue) : Sequence(String) = 
	v.ownedValue.getOwnedListElements()->collect(e|e.getValue())
;



helper context AADLBA!SubprogramSubcomponentType def: getSubprogramType() : AADLBA!SubprogramType = 
	if(self.oclIsKindOf(AADLBA!SubprogramType)) then
		self
	else 
		if(self.oclIsKindOf(AADLBA!SubprogramImplementation)) then
			self.type
		else
			OclUndefined
		endif
	endif
;

helper context AADLBA!SubprogramCall def:getConnectedParamDataSubcomponent(p: AADLBA!Parameter) : AADLBA!DataSubcomponent =
	if(not self.eContainer().eContainer().getOwnedParameterConnections()->any
	( paramCnx |
		paramCnx.source.getContext() = self and paramCnx.source.connectionEnd = p
	).oclIsUndefined())
	then
		self.eContainer().eContainer().getOwnedParameterConnections()->any
		( paramCnx |
			paramCnx.source.getContext() = self and paramCnx.source.connectionEnd = p
		).destination.connectionEnd
	else 
		if(not self.eContainer().eContainer().getOwnedParameterConnections()->any
		( paramCnx |
			paramCnx.source.getContext() = self and paramCnx.source.connectionEnd = p
		).oclIsUndefined())
		then
			self.eContainer().eContainer().getOwnedParameterConnections()->any
			( paramCnx |
				paramCnx.destination.getContext() = self and paramCnx.destination.connectionEnd = p
			).source.connectionEnd
		else
			OclUndefined
		endif
	endif
;

helper context AADLBA!SubprogramCall def:getConnectedAccessDataSubcomponent(p: AADLBA!DataAccess) : AADLBA!DataSubcomponent =
	if(not self.eContainer().eContainer().getOwnedAccessConnections()->any
	( accessCnx |
		accessCnx.source.getContext() = self and accessCnx.source.connectionEnd = p
	).oclIsUndefined())
	then
		self.eContainer().eContainer().getOwnedAccessConnections()->any
		( accessCnx |
			accessCnx.source.getContext() = self and accessCnx.source.connectionEnd = p
		).destination.connectionEnd
	else 
		if(not self.eContainer().eContainer().getOwnedAccessConnections()->any
		( accessCnx |
			accessCnx.source.getContext() = self and accessCnx.source.connectionEnd = p
		).oclIsUndefined())
		then
			self.eContainer().eContainer().getOwnedParameterConnections()->any
			( accessCnx |
				accessCnx.destination.getContext() = self and accessCnx.destination.connectionEnd = p
			).source.connectionEnd
		else
			OclUndefined
		endif
	endif
;
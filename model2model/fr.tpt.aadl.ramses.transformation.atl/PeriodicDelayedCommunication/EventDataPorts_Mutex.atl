--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore

module EventDataPorts_Mutex;
create OUT : AADLBA 	from 		IN : AADLI,
									AADL_RUNTIME: AADLBA,
									DATA_MODEL: AADLBA,
									PROGRAMMING_PROPERTIES: AADLBA,
									HOOKS: ATLHOOKS,
									PERIODICDELAYED_RUNTIME: AADLBA,
									PERIODICDELAYEDMUTEX_RUNTIME: AADLBA,
									ARINC653_RUNTIME: AADLBA;

uses AADLCopyHelpers;
uses AADLICopyHelpers;
uses Uninstanciate;
uses PropertiesTools;
uses Services;

helper def : PeriodicDelayedMutexRuntime_Name : String = 'PERIODICDELAYEDMUTEX_RUNTIME';
helper def : Compute_Deadline_Name : String = 'Compute_Deadline';

helper context AADLBA!ThreadImplementation def : getCall(name: String) : AADLBA!SubprogramCall =
	self.getOwnedSubprogramCallSequences()
	     ->first().ownedCallSpecification->any(call|call.name=name)
;

helper context AADLI!FeatureInstance def : getAllInternalConnections() : Sequence(AADLI!Connection) =
	if (self.direction = #out) then
		self.eContainer().subcomponent.classifier.getOwnedConnections()
			->select(c|c.destination.connectionEnd.name=self.feature.name)
	else
		self.eContainer().subcomponent.classifier.getOwnedConnections()
			->select(c|c.source.connectionEnd.name=self.feature.name)
	endif
;

helper context AADLBA!ComponentImplementation def : subprogramCalls() : 
	Sequence(AADLBA!SubprogramCall) =
	if(self.ownedSubprogramCallSequence->isEmpty()) then
		0
	else
		self.getOwnedSubprogramCallSequences()->first()
			.getOwnedCallSpecifications()
	endif
;

helper context AADLI!ComponentInstance def : getPriority() : Integer =
	self.getPropertyIntValue('Priority',0)
;

helper context AADLI!ComponentInstance def : getMsgPriority() : Integer =
	self.getPriority()
;

helper context AADLI!ComponentInstance def : getImgSubcomponent(name : String) : 
	AADLBA!Subcomponent = thisModule.resolveTemp(self,'sub')
			.threadSubcomponentType.getAllSubcomponents()
			->any(s|s.name=name)
;

helper context AADLBA!Subcomponent def : getSubcomponent(name : String) :
	AADLBA!Subcomponent = self.getComponentImplementation().getSubcomponent(name)
;

helper context AADLBA!ComponentImplementation def : getSubcomponent(name : String) :
	AADLBA!Subcomponent = self.getOwnedSubcomponents()->any(s|s.name=name)
;


rule Thread_Instance {
	from
		c : AADLI!ComponentInstance (c.category = #thread)
	using
	{
		periodValue : Integer = c.getPropertyIntValue('Period').longValue();
		deadlineValue : Integer = c.getPropertyIntValue('Deadline',periodValue).longValue();
		msgPriorityValue : Integer = c.getMsgPriority().longValue();
	}
	to 
		sub : AADLBA!ThreadSubcomponent(
			name <- c.name.debug('thread instance'),
			threadSubcomponentType <- c.createOrSetTypeAndImplementation(),
			ownedPropertyAssociation <- c.mapOwnedPropertyAssociationList()
					->union(c.mapSubcomponentsReferenceList())
					->union(Sequence{
						thisModule.CreatePropertyAssociationAppliesTo(
							'Initial_Value',
							'DATA_MODEL',
							thisModule.CreateListValueFromString(msgPriorityValue.toString()),
							msgPriorityInitAppliesTo
						),
						thisModule.CreatePropertyAssociationAppliesTo(
							'Initial_Value',
							'DATA_MODEL',
							thisModule.CreateListValueFromString(periodValue.toString()),
							periodInitAppliesTo
						),
						thisModule.CreatePropertyAssociationAppliesTo(
							'Initial_Value',
							'DATA_MODEL',
							thisModule.CreateListValueFromString(deadlineValue.toString()),
							deadlineInitAppliesTo
						),
						thisModule.CreatePropertyAssociationAppliesTo(
							'Initial_Value',
							'DATA_MODEL',
							thisModule.CreateListValueFromString(deadlineValue.toString()),
							currentDeadlineInitAppliesTo
						)
					})
		),
		msgPriorityInitAppliesTo: AADLBA!ContainedNamedElement (
			containmentPathElement <- Sequence{msgPriorityPE}
		),
		msgPriorityPE : AADLBA!ContainmentPathElement (
			namedElement <- sub.getSubcomponent('MsgPriority')
		),
		periodInitAppliesTo : AADLBA!ContainedNamedElement(
			containmentPathElement <- Sequence{periodPE}
		),
		periodPE : AADLBA!ContainmentPathElement (
			namedElement <- sub.getSubcomponent('Period')
		),
		deadlineInitAppliesTo : AADLBA!ContainedNamedElement(
			containmentPathElement <- Sequence{deadlinePE}
		),
		deadlinePE : AADLBA!ContainmentPathElement (
			namedElement <- sub.getSubcomponent('Deadline')
		),
		currentDeadlineInitAppliesTo : AADLBA!ContainedNamedElement(
			containmentPathElement <- Sequence{currentDeadlinePE}
		),
		currentDeadlinePE : AADLBA!ContainmentPathElement (
			namedElement <- sub.getSubcomponent('CurrentDeadline')
		)
	do
	{	
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(sub, c);
	}
}

rule EventDataPort_Instance
{
	from
		port: AADLI!FeatureInstance
		(
			port.debug('EventDataPort_Instance').direction.toString()='in' 
			and port.isDelayedPort().debug('EventDataPort_Instance')
		)
	using
	{
		processImg : AADLBA!Subcomponent = OclUndefined;
		dstThreadImg : AADLBA!Subcomponent = OclUndefined;
		ownerName : String = port.eContainer().name;

		dataClassifier : AADLBA!DataClassifier = port.feature.dataFeatureClassifier;
		runtimeName: String = thisModule.PeriodicDelayedMutexRuntime_Name;

		Buffer_Prototype : AADLBA!DataClassifier = 't_aadl_thread_data_queue_content'.asDataType(runtimeName);
		Queue_Prototype  : AADLBA!DataClassifier = 't_aadl_thread_data_queue'.asDataType(runtimeName);
		Queue_Prototype_Impl : AADLBA!DataClassifier = 't_aadl_thread_data_queue.impl'.asDataType(runtimeName);

		Receive_Input_PrototypeSpg: AADLBA!SubprogramType = 'Receive_Input'.asSubprogramType(runtimeName);
		Next_Value_PrototypeSpg: AADLBA!SubprogramType = 'Next_Value'.asSubprogramType(runtimeName);
	}
	to
		bufferArrayType: AADLBA!DataType
		(
			name <- 'BufferArrayType_'+port.eContainer().name+'_'+port.name,
			ownedPropertyAssociation <- Sequence {
												
					thisModule.CreatePropertyAssociation
					(
					 	'Base_Type',
						'DATA_MODEL',
						thisModule.CreateListValueFromClassifier(
							thisModule.Queue_Element_Type(dataClassifier))
					),
					
					thisModule.CreatePropertyAssociation
					(
					 	'Dimension',
						'DATA_MODEL',
						thisModule.CreateListValueFromInteger(
							port.getQueueSize().longValue())
					)
			},
			ownedExtension <- bufferArrayTypeExtension 
		),
		bufferArrayTypeExtension: AADLBA!TypeExtension
		(
			extended <- Buffer_Prototype
		),
		bufferQueueType: AADLBA!DataType
		(
			name <- 'QueueType_'+port.eContainer().name+'_'+port.name,
			ownedExtension <- bufferQueueTypeExtension
		),
		bufferQueueTypeExtension: AADLBA!TypeExtension
		(
			extended <- Queue_Prototype 
		),
		bufferQueueImpl: AADLBA!DataImplementation
		(
			name <- bufferQueueType.name + '.impl',
			ownedRealization <- thisModule.Realization(bufferQueueType,bufferQueueImpl),
			ownedExtension <- bufferQueueImplExtension,
			ownedPrototypeBinding <- Sequence {bufferQueueImplPrototypeBinding},
			ownedDataSubcomponent <- Sequence {bufferQueueImplValuesSub},
			ownedPropertyAssociation <- Sequence {
				thisModule.CreatePropertyAssociationAppliesTo(
							'Initial_Value',
							'DATA_MODEL',
							thisModule.CreateListValueFromString(port.getQueueSize().longValue().toString()),
							bufferQueueSizeAppliesTo
						)
			}
		),
		bufferQueueSizeAppliesTo: AADLBA!ContainedNamedElement (
			containmentPathElement <- Sequence{bufferQueueSizePE}
		),
		bufferQueueSizePE : AADLBA!ContainmentPathElement (
			namedElement <- Queue_Prototype_Impl.getSubcomponent('Size')
		),
		bufferQueueImplExtension: AADLBA!ImplementationExtension
		(
			extended <- Queue_Prototype_Impl
		),
		bufferQueueImplPrototypeBinding : AADLBA!ComponentPrototypeBinding
		(
			formal <- Receive_Input_PrototypeSpg.ownedPrototype->any(e|e.name = 't_request'),
			actual <- Sequence{bufferQueueImplPrototypeActual}
		),
		bufferQueueImplPrototypeActual : AADLBA!ComponentPrototypeActual
		(
			category <-  #data
		),
		bufferQueueImplValuesSub: AADLBA!DataSubcomponent 
		(
			name <- 'Values',
			dataSubcomponentType <- bufferArrayType,
			refined <- Queue_Prototype_Impl.ownedDataSubcomponent->any(d|d.name='Values')
		),
		bufferSubcomponent:AADLBA!DataSubcomponent
		(
			name<-port.eContainer().name+'_'+port.name,
			dataSubcomponentType <- bufferQueueImpl
		),
		firstSubcomponent: AADLBA!DataSubcomponent 
		(
			name<-port.eContainer().name+'_'+port.name+'_First',
			dataSubcomponentType <- thisModule.Queue_Element_Type_Ptr(dataClassifier) 
		),
		bufferAccess:AADLBA!DataAccess
		(
			name <- port.eContainer().name+'_'+port.name+'_Buffer',
			dataFeatureClassifier <- bufferQueueImpl,
			kind<-#requires
		),
		bufferConnection_Source: AADLBA!ConnectedElement
		(
			connectionEnd <- bufferSubcomponent.debug('bufferConnection_Source')
		),
		bufferConnection_Dest: AADLBA!ConnectedElement
		(
			context <- port.eContainer().getSubcomponentImg(),
			connectionEnd <- bufferAccess.debug('bufferConnection_Dest')
		),
		bufferConnection:AADLBA!AccessConnection
		(
			name <- 'cnx_' + bufferSubcomponent.name + '_' + bufferConnection_Dest.context.name,
			accessCategory <- #data,
			source <- bufferConnection_Source,
			destination <- bufferConnection_Dest
		),
		receiveInputCall: AADLBA!SubprogramCall
		(
			calledSubprogram <- thisModule.Receive_Input_Mapper(port),
			name <- receiveInputCall.calledSubprogram.name + '_' + port.name
		),
		receiveInputPeriodParameterConnection: AADLBA!ParameterConnection
		(
			name <- 'cnx_Receive_Input_Period_' + bufferSubcomponent.name,
			source <- receiveInputPeriodParameterConnection_Source,
			destination <- receiveInputPeriodParameterConnection_Destination
		),
		receiveInputPeriodParameterConnection_Source: AADLBA!ConnectedElement
		(
			connectionEnd <- OclUndefined
		),
		receiveInputPeriodParameterConnection_Destination: AADLBA!ConnectedElement
		(
			context <- receiveInputCall,
			connectionEnd <- Receive_Input_PrototypeSpg.ownedParameter
								->any(a|a.name='Period')
		),
		receiveInputCurrentPeriodParameterConnection: AADLBA!ParameterConnection
		(
			name <- 'cnx_Receive_Input_CurrentPeriod_' + bufferSubcomponent.name,
			source <- receiveInputCurrentPeriodParameterConnection_Source,
			destination <- receiveInputCurrentPeriodParameterConnection_Destination
		),
		receiveInputCurrentPeriodParameterConnection_Source: AADLBA!ConnectedElement
		(
			connectionEnd <- OclUndefined
		),
		receiveInputCurrentPeriodParameterConnection_Destination: AADLBA!ConnectedElement
		(
			context <- receiveInputCall,
			connectionEnd <- Receive_Input_PrototypeSpg.ownedParameter
								->any(a|a.name='CurrentPeriod')
		),
		receiveInputFirstAccessConnection: AADLBA!ParameterConnection
		(
			name <- 'cnx_Receive_Input_First_' + bufferSubcomponent.name,
			source <- receiveInputFirstAccessConnection_Source,
			destination <- receiveInputFirstAccessConnection_Destination
		),
		receiveInputFirstAccessConnection_Source: AADLBA!ConnectedElement
		(
			connectionEnd <- firstSubcomponent
		),
		receiveInputFirstAccessConnection_Destination: AADLBA!ConnectedElement
		(
			context <- receiveInputCall,
			connectionEnd <- Receive_Input_PrototypeSpg.ownedParameter
								->any(a|a.name='First')
		),
		receiveInputBufferAccessConnection: AADLBA!AccessConnection
		(
			name <- 'cnx_Receive_Input_PortVariable_' + bufferSubcomponent.name,
			accessCategory <- #data,
			source <- receiveInputBufferAccessConnection_Source,
			destination <- receiveInputBufferAccessConnection_Destination
		),
		receiveInputBufferAccessConnection_Source: AADLBA!ConnectedElement
		(
			connectionEnd <- bufferAccess
		),
		receiveInputBufferAccessConnection_Destination: AADLBA!ConnectedElement
		(
			context <- receiveInputCall,
			connectionEnd <- Receive_Input_PrototypeSpg.ownedDataAccess
								->any(a|a.name='PortVariable')
		),
		nextValueCall: AADLBA!SubprogramCall
		(
			calledSubprogram <- thisModule.Next_Value_Mapper(port),
			name <- nextValueCall.calledSubprogram.name + '_' + port.name
		),
		nextValueBufferAccessConnection: AADLBA!AccessConnection
		(
			name <- 'cnx_Next_Value_PortVariable_' + bufferSubcomponent.name,
			accessCategory <- #data,
			source <- nextValueBufferConnection_Source,
			destination <- nextValueBufferConnection_Dest
		),
		nextValueBufferConnection_Source: AADLBA!ConnectedElement
		(
			connectionEnd <- bufferAccess
		),
		nextValueBufferConnection_Dest: AADLBA!ConnectedElement
		(
			context <- nextValueCall,
			connectionEnd <- Next_Value_PrototypeSpg.ownedDataAccess
				->any(a|a.name='PortVariable').debug('nextValueBufferConnection_Dest')
		),
		nextValueFirstParameterConnection: AADLBA!ParameterConnection
		(
			name <- 'cnx_Next_Value_First_' + bufferSubcomponent.name,
			source <- nextValueFirstParameterConnection_Source,
			destination <- nextValueFirstParameterConnection_Destination
		),
		nextValueFirstParameterConnection_Source: AADLBA!ConnectedElement
		(
			connectionEnd <- firstSubcomponent
		),
		nextValueFirstParameterConnection_Destination: AADLBA!ConnectedElement
		(
			context <- nextValueCall,
			connectionEnd <- Next_Value_PrototypeSpg.ownedParameter
				->any(a|a.name='First').debug('nextValueFirstConnection_Dest')
		)
	do
	{
		port.debug('EventDataPort_Instance');
		thisModule.addImportedUnit(thisModule.public(), 'PERIODICDELAYEDMUTEX_RUNTIME', 'PeriodicDelayedMutex_runtime');
		
		processImg<-port.eContainer().eContainer().getSubcomponentImg().classifier;
		dstThreadImg<-port.eContainer().getSubcomponentImg().classifier;
		
		dstThreadImg.debug('EventDataPort_Instance-dstThreadImg');
		
		bufferQueueImplPrototypeActual.setSubcomponentType(dataClassifier);
		
		processImg.ownedDataSubcomponent.add(bufferSubcomponent);
		processImg.ownedAccessConnection.add(bufferConnection);
		
		dstThreadImg.type.ownedDataAccess.add(bufferAccess);
		dstThreadImg.ownedDataSubcomponent.add(firstSubcomponent);
		
		dstThreadImg.ownedAccessConnection.add(receiveInputBufferAccessConnection);
		dstThreadImg.ownedAccessConnection.add(nextValueBufferAccessConnection);
		dstThreadImg.ownedParameterConnection.add(receiveInputPeriodParameterConnection);
		dstThreadImg.ownedParameterConnection.add(receiveInputCurrentPeriodParameterConnection);
		dstThreadImg.ownedParameterConnection.add(nextValueFirstParameterConnection);
		dstThreadImg.ownedParameterConnection.add(receiveInputFirstAccessConnection);
		
		bufferConnection_Dest.context 
			<- port.eContainer().getSubcomponentImg().debug('bufferConnection_Dest.context');
		
		receiveInputPeriodParameterConnection_Source.connectionEnd
			<- dstThreadImg.ownedDataSubcomponent->any(d|d.name='Period');
		
		receiveInputCurrentPeriodParameterConnection_Source.connectionEnd
			<- dstThreadImg.ownedDataSubcomponent->any(d|d.name='CurrentPeriod');
		
		thisModule.addSubprogramCall(port.feature, dstThreadImg, nextValueCall);
		thisModule.addSubprogramCall(port.feature, dstThreadImg, receiveInputCall);
		
		thisModule.NextValueToJobParameters(port,dstThreadImg, nextValueCall);
		thisModule.public().ownedClassifier.add(bufferArrayType);
		thisModule.public().ownedClassifier.add(bufferQueueType);
		thisModule.public().ownedClassifier.add(bufferQueueImpl);
	}
}

rule PortConnection_Instance
{
	from
		cnxInst: AADLI!ConnectionInstance
		(
			--cnxInst.destination.isPeriodicDelayedPort().debug('IS PERIODIC-DELAYED DESTINATION')
			--and cnxInst.source.isPeriodicDelayedPort().debug('IS PERIODIC-DELAYED SOURCE')
			cnxInst.destination.debug('PortConnection_Instance').isDelayedPort()
			and cnxInst.source.eContainer().category = #thread
			and cnxInst.destination.eContainer().category = #thread
		)
	using
	{
		processImg : AADLBA!Subcomponent = OclUndefined;
		dstThreadImg : AADLBA!Subcomponent = OclUndefined;
		port : AADLI!FeatureInstance = cnxInst.destination;
		dataClassifier : AADLI!DataClassifier = port.feature.dataFeatureClassifier;

		Put_Value_PrototypeSpg: AADLBA!SubprogramType = 'Put_Value'.asSubprogramType(thisModule.PeriodicDelayedMutexRuntime_Name);
		Send_Output_Spg: AADLBA!SubprogramType = 'Send_Output'.asSubprogramType(thisModule.PeriodicDelayedMutexRuntime_Name);

		putValueCallIndex : Integer = 0;
		sourceOwner : String = cnxInst.source.eContainer().name;

		portSimpleName : String = port.eContainer().name 
			          + '_' + port.name;
	}
	to
		portDataSubcomponent: AADLBA!DataSubcomponent 
		(
			name <- sourceOwner + '_' + portSimpleName + '_Value',
			dataSubcomponentType <- dataClassifier
		),
		portDataAccess : AADLBA!DataAccess
		(
			name <- portSimpleName + '_Value',
			dataFeatureClassifier <- dataClassifier,
			kind <- #requires
		),
		portDataConnection_Source : AADLBA!ConnectedElement
		(
			connectionEnd <- portDataSubcomponent
		),
		portDataConnection_Destination : AADLBA!ConnectedElement
		(
			context <- cnxInst.source.eContainer().getSubcomponentImg(),
			connectionEnd <- portDataAccess
		),
		portDataConnection : AADLBA!AccessConnection
		(
			name <- 'cnx_' + portSimpleName + '_Value',
			accessCategory <- #data,
			source <- portDataConnection_Source,
			destination <- portDataConnection_Destination
		),
		bufferAccess: AADLBA!DataAccess
		(
			name<-port.eContainer().name+'_'+port.name+'_Buffer',
			dataFeatureClassifier <- thisModule.resolveTemp(port,'bufferQueueImpl'),
			kind <- #requires
		),
		bufferConnection_Source : AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveTemp(port,'bufferSubcomponent').debug('bufferSubcomponent')
		),
		bufferConnection_Dest : AADLBA!ConnectedElement
		(
			context <- cnxInst.source.eContainer().getSubcomponentImg(),
			connectionEnd <- bufferAccess
		),
		bufferConnection : AADLBA!AccessConnection
		(
			name <- 'cnx_' + bufferAccess.name + '_' + bufferConnection_Dest.context.name,
			accessCategory <- #data,
			source <- bufferConnection_Source,
			destination <- bufferConnection_Dest
		),
		putValueCall: AADLBA!SubprogramCall
		(
			calledSubprogram <- thisModule.Put_Value_Mapper(port),
			name <- 'Put_Value_'
					 + bufferConnection_Source.connectionEnd.name
		),
		putValueDataAccessConnection: AADLBA!AccessConnection
		(
			name <- 'cnx_Put_Value_' + portSimpleName + '_Value',
			accessCategory <- #data,
			source <- putValueDataAccessConnection_Source,
			destination <- putValueDataAccessConnection_Dest
		),
		putValueDataAccessConnection_Source: AADLBA!ConnectedElement
		(
			connectionEnd <- portDataAccess 
		),
		putValueDataAccessConnection_Dest: AADLBA!ConnectedElement
		(
			context <- putValueCall,
			connectionEnd <- Put_Value_PrototypeSpg.ownedDataAccess->any(a|a.name='DataValue')
		),
		putValueBufferAccessConnection: AADLBA!AccessConnection
		(
			name <- 'cnx_Put_Value_' + portSimpleName+'_Buffer',
			accessCategory <- #data,
			source <- putValueBufferAccessConnection_Source,
			destination <- putValueBufferAccessConnection_Destination
		),
		putValueBufferAccessConnection_Source : AADLBA!ConnectedElement
		(
			connectionEnd <- bufferAccess
		),
		putValueBufferAccessConnection_Destination : AADLBA!ConnectedElement
		(
			context <- putValueCall,
			connectionEnd <- Put_Value_PrototypeSpg.ownedDataAccess->any(a|a.name='PortVariable')
		),
		putValueMsgPriorityParameterConnection: AADLBA!ParameterConnection 
		(
			name <- 'cnx_Put_Value_' + portSimpleName +'_Priority',
			source <- putValueMsgPriorityParameterConnection_Source,
			destination <- putValueMsgPriorityParameterConnection_Destination
		),
		putValueMsgPriorityParameterConnection_Source: AADLBA!ConnectedElement
		(
			connectionEnd <- port.eContainer().getImgSubcomponent('MsgPriority')
		),
		putValueMsgPriorityParameterConnection_Destination : AADLBA!ConnectedElement
		(
			context <- putValueCall,
			connectionEnd <- Put_Value_PrototypeSpg.ownedParameter->any(a|a.name='Priority')
		),
		putValueCurrentDeadlineParameterConnection: AADLBA!ParameterConnection 
		(
			name <- 'cnx_Put_Value_' + portSimpleName +'_CurrentDeadline',
			source <- putValueCurrentDeadlineParameterConnection_Source,
			destination <- putValueCurrentDeadlineParameterConnection_Destination
		),
		putValueCurrentDeadlineParameterConnection_Source: AADLBA!ConnectedElement
		(
			connectionEnd <- port.eContainer().getImgSubcomponent('CurrentDeadline')
		),
		putValueCurrentDeadlineParameterConnection_Destination : AADLBA!ConnectedElement
		(
			context <- putValueCall,
			connectionEnd <- Put_Value_PrototypeSpg.ownedParameter->any(a|a.name='CurrentDeadline')
		),
		sendOutputCall: AADLBA!SubprogramCall
		(
			name <- 'Send_Output_' + thisModule.resolveTemp(port,'bufferSubcomponent').name,
			calledSubprogram <- thisModule.Send_Output_Mapper(port)
		),
		sendOutputBufferConnection: AADLBA!AccessConnection
		(
			name <- 'cnx_Send_Output_' + portSimpleName, 
			accessCategory <- #data,
			source <- sendOutputBufferConnection_Source,
			destination <- sendOutputBufferConnection_Destination
		),
		sendOutputBufferConnection_Source: AADLBA!ConnectedElement
		(
			connectionEnd <- bufferAccess
		),
		sendOutputBufferConnection_Destination: AADLBA!ConnectedElement
		(
			context <- sendOutputCall,
			connectionEnd <- Send_Output_Spg.ownedDataAccess
								->any(a|a.name='PortVariable')
		)
	do
	{
		thisModule.addImportedUnit(thisModule.public(), 'PERIODICDELAYEDMUTEX_RUNTIME', 'PeriodicDelayedMutex_runtime');
		
		processImg<-port.eContainer().eContainer().getSubcomponentImg().classifier;
		dstThreadImg<-cnxInst.source.eContainer().getSubcomponentImg().classifier;
		
		dstThreadImg.debug('Connection_Instance-dstThreadImg');
		
		processImg.ownedDataSubcomponent.add(portDataSubcomponent);
		processImg.ownedAccessConnection.add(portDataConnection);
	
		thisModule.JobParametersToPortDataValue(cnxInst,dstThreadImg,portDataAccess);
		dstThreadImg.ownedAccessConnection.add(putValueDataAccessConnection);
		dstThreadImg.ownedAccessConnection.add(putValueBufferAccessConnection);
		dstThreadImg.ownedAccessConnection.add(sendOutputBufferConnection);
		
		dstThreadImg.ownedParameterConnection.add(putValueCurrentDeadlineParameterConnection);
		dstThreadImg.ownedParameterConnection.add(putValueMsgPriorityParameterConnection);
		
		dstThreadImg.type.ownedDataAccess.add(bufferAccess);
		dstThreadImg.type.ownedDataAccess.add(portDataAccess);
		
		processImg.ownedAccessConnection.add(bufferConnection);
		
		thisModule.addSubprogramCall(cnxInst.source.feature, dstThreadImg, putValueCall);
		thisModule.addSubprogramCall(cnxInst.source.feature, dstThreadImg, sendOutputCall);
	}
}


unique lazy rule Receive_Input_Mapper
{
	from
		port: AADLI!FeatureInstance
	using
	{
		t_request : AADLBA!DataClassifier = port.feature.dataFeatureClassifier;
		bufferQueueImpl: AADLBA!DataImplementation = thisModule.resolveTemp(port,'bufferQueueImpl');

		Receive_Input_PrototypeSpg: AADLBA!SubprogramType = 'Receive_Input'.asSubprogramType(thisModule.PeriodicDelayedMutexRuntime_Name);
	}
	to
		receiveInputSpg: AADLBA!SubprogramType
		(
			name <- Receive_Input_PrototypeSpg.name+'_'+ port.eContainer().name + '_' + port.name,
			ownedExtension <- extendedReceiveInputSpg,
			ownedPrototypeBinding <- Sequence{receiveInputPrototypeBinding},
			ownedDataAccess <- Sequence{receiveInputPortVariable},
			ownedParameter <- Sequence{receiveInputFirst}
		),
		receiveInputPortVariable: AADLBA!DataAccess
		(
			name <- 'PortVariable',
			kind <- #requires,
			dataFeatureClassifier <- bufferQueueImpl,
			refined <- Receive_Input_PrototypeSpg.ownedDataAccess->any(d|d.name='PortVariable')
		),
		receiveInputFirst: AADLBA!Parameter
		(
			name <- 'First',
			direction <- 'in out',
			dataFeatureClassifier <- thisModule.Queue_Element_Type_Ptr(t_request),
			refined <- Receive_Input_PrototypeSpg.ownedParameter->any(d|d.name='First')
		),
		extendedReceiveInputSpg: AADLBA!TypeExtension
		(
			extended <- Receive_Input_PrototypeSpg
		),
		receiveInputPrototypeBinding : AADLBA!ComponentPrototypeBinding
		(
			formal <- Receive_Input_PrototypeSpg.ownedPrototype->any(e|e.name = 't_request').debug('Next_Value.formal'),
			actual <- Sequence{receiveInputPrototypeActual}
		),
		receiveInputPrototypeActual : AADLBA!ComponentPrototypeActual
		(
			category <-  #data
		)
	do
	{
		receiveInputPrototypeActual.setSubcomponentType(t_request);
		thisModule.public().ownedClassifier.add(receiveInputSpg);
		receiveInputSpg;
	}
}

unique lazy rule Next_Value_Mapper
{
	from
		port: AADLI!FeatureInstance
	using
	{
		t_request : AADLBA!DataClassifier = port.feature.dataFeatureClassifier;
		bufferQueueImpl: AADLBA!DataImplementation = thisModule.resolveTemp(port,'bufferQueueImpl');

		Next_Value_PrototypeSpg: AADLBA!SubprogramType = 'Next_Value'.asSubprogramType(thisModule.PeriodicDelayedMutexRuntime_Name);
	}
	to
		nextValueSpg: AADLBA!SubprogramType
		(
			--name <- Next_Value_PrototypeSpg.name+'_'+thisModule.getProgrammationLanguageIdentifier(port.getComponentInstancePath()),
			name <- Next_Value_PrototypeSpg.name+'_'+ port.eContainer().name + '_' + port.name,
			ownedExtension <- extendedNextValueSpg,
			ownedPrototypeBinding <- Sequence{nextValuePrototypeBinding},
			ownedDataAccess <- Sequence {nextValuePortVariable},
			ownedParameter <- Sequence {nextValueSpgDataValue,nextValueFirst}
		),
		nextValuePortVariable: AADLBA!DataAccess
		(
			name <- 'PortVariable',
			kind <- #requires,
			dataFeatureClassifier <- bufferQueueImpl,
			refined <- Next_Value_PrototypeSpg.ownedDataAccess->any(d|d.name='PortVariable')
		),
		nextValueSpgDataValue: AADLBA!Parameter
		(
			name <- 'DataValue',
			direction <- #out,
			dataFeatureClassifier <- t_request,
			refined <- Next_Value_PrototypeSpg.ownedParameter->any(d|d.name='DataValue')
		),
		nextValueFirst: AADLBA!Parameter
		(
			name <- 'First',
			direction <- 'in out',
			dataFeatureClassifier <- thisModule.Queue_Element_Type_Ptr(t_request),
			refined <- Next_Value_PrototypeSpg.ownedParameter->any(d|d.name='First')
		),
		extendedNextValueSpg: AADLBA!TypeExtension
		(
			extended <- Next_Value_PrototypeSpg
		),
		nextValuePrototypeBinding : AADLBA!ComponentPrototypeBinding
		(
			formal <- Next_Value_PrototypeSpg.ownedPrototype->any(e|e.name = 't_request').debug('Next_Value.formal'),
			actual <- Sequence{nextValuePrototypeActual}
		),
		nextValuePrototypeActual : AADLBA!ComponentPrototypeActual
		(
			category <-  #data
		)
	do
	{
		nextValuePrototypeActual.setSubcomponentType(t_request);
		thisModule.public().ownedClassifier.add(nextValueSpg);
		nextValueSpg;
	}
}

unique lazy rule Put_Value_Mapper
{
	from
		port: AADLI!FeatureInstance
	using
	{
		t_request : AADLBA!DataClassifier = port.feature.dataFeatureClassifier;
		bufferQueueImpl: AADLBA!DataImplementation = thisModule.resolveTemp(port,'bufferQueueImpl');

		Put_Value_PrototypeSpg: AADLBA!SubprogramType = 'Put_Value'.asSubprogramType(thisModule.PeriodicDelayedMutexRuntime_Name);
	}
	to
		putValueSpg: AADLBA!SubprogramType
		(
			--name <- Put_Value_PrototypeSpg.name+'_'+thisModule.getProgrammationLanguageIdentifier(port.getComponentInstancePath()),
			name <- Put_Value_PrototypeSpg.name+'_'+ port.eContainer().name + '_' + port.name,
			ownedExtension <- extendedPutValueSpg,
			ownedPrototypeBinding <- Sequence{putValuePrototypeBinding},
			ownedDataAccess <- Sequence {putValueSpgPortVariable,putValueSpgDataValue}
		),
		putValueSpgPortVariable: AADLBA!DataAccess
		(
			name <- 'PortVariable',
			kind <- #requires,
			dataFeatureClassifier <- bufferQueueImpl,
			refined <- Put_Value_PrototypeSpg.ownedDataAccess->any(d|d.name='PortVariable')
		),
		putValueSpgDataValue: AADLBA!DataAccess
		(
			name <- 'DataValue',
			kind <- #requires,
			dataFeatureClassifier <- t_request,
			refined <- Put_Value_PrototypeSpg.ownedDataAccess->any(d|d.name='DataValue')
		),
		extendedPutValueSpg: AADLBA!TypeExtension
		(
			extended <- Put_Value_PrototypeSpg
		),
		putValuePrototypeBinding : AADLBA!ComponentPrototypeBinding
		(
			formal <- Put_Value_PrototypeSpg.ownedPrototype->any(e|e.name = 't_request').debug('Put_Value.formal'),
			actual <- Sequence{putValuePrototypeActual}
		),
		putValuePrototypeActual : AADLBA!ComponentPrototypeActual
		(
			category <-  #data
		)
	do
	{
		putValuePrototypeActual.setSubcomponentType(t_request);
		thisModule.public().ownedClassifier.add(putValueSpg);
		putValueSpg;
	}
}

unique lazy rule Send_Output_Mapper
{
	from
		port: AADLI!FeatureInstance
	using
	{
		t_request : AADLBA!DataClassifier = port.feature.dataFeatureClassifier;
		bufferQueueImpl: AADLBA!DataImplementation = thisModule.resolveTemp(port,'bufferQueueImpl');

		Send_Output_PrototypeSpg: AADLBA!SubprogramType = 'Send_Output'.asSubprogramType(thisModule.PeriodicDelayedMutexRuntime_Name);
	}
	to
		sendOutputSpg: AADLBA!SubprogramType
		(
			--name <- Next_Value_PrototypeSpg.name+'_'+thisModule.getProgrammationLanguageIdentifier(port.getComponentInstancePath()),
			name <- Send_Output_PrototypeSpg.name+'_'+ port.eContainer().name + '_' + port.name,
			ownedExtension <- extendedSendOutputSpg,
			ownedPrototypeBinding <- Sequence{sendOutputPrototypeBinding},
			ownedDataAccess <- Sequence {sendOutputPortVariable}
		),
		sendOutputPortVariable: AADLBA!DataAccess
		(
			name <- 'PortVariable',
			kind <- #requires,
			dataFeatureClassifier <- bufferQueueImpl,
			refined <- Send_Output_PrototypeSpg.ownedDataAccess->any(d|d.name='PortVariable')
		),
		extendedSendOutputSpg: AADLBA!TypeExtension
		(
			extended <- Send_Output_PrototypeSpg
		),
		sendOutputPrototypeBinding : AADLBA!ComponentPrototypeBinding
		(
			formal <- Send_Output_PrototypeSpg.ownedPrototype->any(e|e.name = 't_request').debug('Send_Output.formal'),
			actual <- Sequence{sendOutputPrototypeActual}
		),
		sendOutputPrototypeActual : AADLBA!ComponentPrototypeActual
		(
			category <-  #data
		)
	do
	{
		sendOutputPrototypeActual.setSubcomponentType(t_request);
		thisModule.public().ownedClassifier.add(sendOutputSpg);
		sendOutputSpg;
	}
}

-- Queue as a linked list, its elements are links
unique lazy rule Queue_Element_Type
{
	from
		dataClassifier : AADLI!DataClassifier
	using
	{
		Link_Prototype_Type: AADLI!DataClassifier = 't_aadl_linkedlist_link'
			.asDataType(thisModule.PeriodicDelayedMutexRuntime_Name);

		Link_Prototype_Impl: AADLI!DataClassifier = 't_aadl_linkedlist_link.impl'
			.asDataType(thisModule.PeriodicDelayedMutexRuntime_Name);

		linkName: String = dataClassifier.name.concat('_Link');
	}
	to
	    dataImplPtr : AADLBA!DataImplementation 
		(
			name <- linkName + '.impl',
			--ownedRealization <- thisModule.Realization(dataTypePtr,dataImplPtr),
			ownedExtension <- extendedPointerImpl,
			ownedPrototypeBinding <- Sequence{pointerImplPrototypeBinding}
		),
		extendedPointerImpl: AADLBA!ImplementationExtension
		(
			extended <- Link_Prototype_Impl
		),
		dataTypePtr : AADLBA!DataType 
		(
			name <- linkName,
			ownedExtension <- extendedPointerType
		),
		extendedPointerType: AADLBA!TypeExtension
		(
			extended <- Link_Prototype_Type
		),
		pointerImplPrototypeBinding : AADLBA!ComponentPrototypeBinding
		(
			formal <- Link_Prototype_Impl.ownedPrototype->any(e|e.name = 't_request').debug('Queue_Element_Impl.formal'),
			actual <- Sequence{pointerImplPrototypeActual}
		),
		pointerImplPrototypeActual : AADLBA!ComponentPrototypeActual
		(
			category <-  #data
		)
	do
	{
		dataImplPtr.ownedRealization <- thisModule.Realization(dataTypePtr,dataImplPtr);
		pointerImplPrototypeActual.setSubcomponentType(dataClassifier);
		thisModule.public().ownedClassifier.add(dataTypePtr);
		thisModule.public().ownedClassifier.add(dataImplPtr);
		dataImplPtr;
	}
}

unique lazy rule Queue_Element_Type_Ptr
{
	from
		dataClassifier : AADLI!DataClassifier
	using
	{
		Link_Prototype_Type: AADLI!DataClassifier = 't_aadl_linkedlist_link_ptr'
			.asDataType(thisModule.PeriodicDelayedMutexRuntime_Name);

		Link_Prototype_Impl: AADLI!DataClassifier = 't_aadl_linkedlist_link_ptr.impl'
			.asDataType(thisModule.PeriodicDelayedMutexRuntime_Name);
	}
	to
		dataImplPtr : AADLBA!DataImplementation 
		(
			name <- dataClassifier.name.concat('_Link_Ptr.impl'),
			ownedExtension <- extendedPointerImpl
		),
	    dataTypePtr : AADLBA!DataType 
		(
			name <- dataClassifier.name.concat('_Link_Ptr'),
			ownedExtension <- extendedPointerType
		),
		extendedPointerType: AADLBA!TypeExtension
		(
			extended <- Link_Prototype_Type
		),
		extendedPointerImpl: AADLBA!ImplementationExtension
		(
			extended <- Link_Prototype_Impl
		),
		pointerTypePrototypeBinding : AADLBA!ComponentPrototypeBinding
		(
			formal <- Link_Prototype_Impl.ownedPrototype->any(e|e.name = 't_request').debug('Queue_Element_Type_Ptr.formal'),
			actual <- Sequence{pointerImplPrototypeActual}
		),
		pointerImplPrototypeActual : AADLBA!ComponentPrototypeActual
		(
			category <-  #data
		)
	do
	{
		dataImplPtr.ownedRealization <- thisModule.Realization(dataTypePtr,dataImplPtr);
		pointerImplPrototypeActual.setSubcomponentType(dataClassifier);
		thisModule.public().ownedClassifier.add(dataTypePtr);
		thisModule.public().ownedClassifier.add(dataImplPtr);
		dataImplPtr;
	}
}

rule threadImplementationPostTreatment(implImg: AADLBA!ThreadImplementation)
{
	using
	{
		Compute_Deadline : AADLBA!SubprogramType = thisModule.Compute_Deadline_Name.asSubprogramType(thisModule.PeriodicDelayedMutexRuntime_Name);
	}
	to
		msgPrioritySub : AADLBA!DataSubcomponent (
			name <- 'MsgPriority',
			dataSubcomponentType <- 'Integer_16'.asDataType('BASE_TYPES')
		),
		periodSub : AADLBA!DataSubcomponent (
			name <- 'Period',
			dataSubcomponentType <- 'Integer_16'.asDataType('BASE_TYPES')
		),
		deadlineSub : AADLBA!DataSubcomponent (
			name <- 'Deadline',
			dataSubcomponentType <- 'Integer_16'.asDataType('BASE_TYPES')
		),
		currentPeriodSub : AADLBA!DataSubcomponent (
			name <- 'CurrentPeriod',
			dataSubcomponentType <- 'Integer_16'.asDataType('BASE_TYPES'),
			ownedPropertyAssociation <- Sequence {
				thisModule.CreatePropertyAssociation(
							'Initial_Value',
							'DATA_MODEL',
							thisModule.CreateListValueFromString('0')
						)
			}
		),
		currentDeadlineSub : AADLBA!DataSubcomponent (
			name <- 'CurrentDeadline',
			dataSubcomponentType <- 'Integer_16'.asDataType('BASE_TYPES')
		),
		computeDeadlineCall : AADLBA!SubprogramCall (
			name <- 'Compute_Deadline',
			calledSubprogram <- Compute_Deadline
		),
		computeDeadlineCallPeriod : AADLBA!ParameterConnection (
			name <- 'cnx_Compute_Deadline_Period',
			source <- computeDeadlineCallPeriod_Source,
			destination <- computeDeadlineCallPeriod_Destination
		),
		computeDeadlineCallPeriod_Source : AADLBA!ConnectedElement (
			connectionEnd <- periodSub
		),
		computeDeadlineCallPeriod_Destination : AADLBA!ConnectedElement (
			context <- computeDeadlineCall,
			connectionEnd <- Compute_Deadline.ownedParameter
								->any(a|a.name='Period')
		),
		computeDeadlineCallDeadline : AADLBA!ParameterConnection (
			name <- 'cnx_Compute_Deadline_Deadline',
			source <- computeDeadlineCallDeadline_Source,
			destination <- computeDeadlineCallDeadline_Destination
		),
		computeDeadlineCallDeadline_Source : AADLBA!ConnectedElement (
			connectionEnd <- deadlineSub
		),
		computeDeadlineCallDeadline_Destination : AADLBA!ConnectedElement (
			context <- computeDeadlineCall,
			connectionEnd <- Compute_Deadline.ownedParameter
								->any(a|a.name='Deadline')
		),
		computeDeadlineCallCurrentPeriod : AADLBA!ParameterConnection (
			name <- 'cnx_Compute_Deadline_CurrentPeriod',
			source <- computeDeadlineCallCurrentPeriod_Source,
			destination <- computeDeadlineCallCurrentPeriod_Destination
		),
		computeDeadlineCallCurrentPeriod_Source : AADLBA!ConnectedElement (
			connectionEnd <- currentPeriodSub
		),
		computeDeadlineCallCurrentPeriod_Destination : AADLBA!ConnectedElement (
			context <- computeDeadlineCall,
			connectionEnd <- Compute_Deadline.ownedParameter
								->any(a|a.name='CurrentPeriod')
		),
		computeDeadlineCallCurrentDeadline : AADLBA!ParameterConnection (
			name <- 'cnx_Compute_Deadline_CurrentDeadline',
			source <- computeDeadlineCallCurrentDeadline_Source,
			destination <- computeDeadlineCallCurrentDeadline_Destination
		),
		computeDeadlineCallCurrentDeadline_Source : AADLBA!ConnectedElement (
			connectionEnd <- currentDeadlineSub
		),
		computeDeadlineCallCurrentDeadline_Destination : AADLBA!ConnectedElement (
			context <- computeDeadlineCall,
			connectionEnd <- Compute_Deadline.ownedParameter
								->any(a|a.name='CurrentDeadline')
		)
	do
	{	
		implImg.ownedDataSubcomponent.add(msgPrioritySub);
		implImg.ownedDataSubcomponent.add(periodSub);
		implImg.ownedDataSubcomponent.add(deadlineSub);
		implImg.ownedDataSubcomponent.add(currentPeriodSub);
		implImg.ownedDataSubcomponent.add(currentDeadlineSub);
		
		thisModule.addSubprogramCall(OclUndefined, implImg, computeDeadlineCall);
		implImg.ownedParameterConnection.add(computeDeadlineCallPeriod);
		implImg.ownedParameterConnection.add(computeDeadlineCallDeadline);
		implImg.ownedParameterConnection.add(computeDeadlineCallCurrentPeriod);
		implImg.ownedParameterConnection.add(computeDeadlineCallCurrentDeadline);
		
		implImg.getType().ownedEventDataPort.debug('test');
	}
}

rule addPutValueSubprogramCall(seq : AADLBA!SubprogramCallSequence,
								impl : AADLBA!ComponentImplementation,
								implImg : AADLBA!ComponentImplementation,
								fi: AADLI!FeatureInstance)
{
	
}

rule addNextValueSubprogramCall(seq : AADLBA!SubprogramCallSequence,
								impl : AADLBA!ComponentImplementation,
								implImg : AADLBA!ComponentImplementation,
								fi: AADLI!FeatureInstance)
{
	
}



-- FeaturesTools
rule addSubprogramCall(f:AADLBA!Feature, implImg: AADLBA!ComponentImplementation, call: AADLBA!SubprogramCall)
{
	using
	{
		calls : Sequence(AADLBA!SubprogramCall) = OclUndefined;
		Compute_Deadline : AADLBA!SubprogramCall = OclUndefined;
	
		CDN : String = thisModule.Compute_Deadline_Name;
		Is_Compute_Deadline : Boolean = call.calledSubprogram.name=CDN;
	}
	do
	{
		if(implImg.ownedSubprogramCallSequence->isEmpty())
		{
			implImg.ownedSubprogramCallSequence.add(thisModule.createCallSequence(call));
		}
		else
		{
			for(seq in implImg.getOwnedSubprogramCallSequences())
			{
				calls <- seq.getOwnedCallSpecifications();
				
				if (f.oclIsUndefined())
					calls.add(call);
				else
				{
					if(f.direction.toString()='in' or f.direction=#inOut)
						calls.add(0, call);
					if (f.direction=#out or f.direction=#inOut)
						calls.add(call);
				}
				
				-- Compute_Deadline must be always the last subprogram call
				
				Compute_Deadline <- calls->any(c|c.calledSubprogram.name=CDN);
				if (not Is_Compute_Deadline
					and not Compute_Deadline.oclIsUndefined())
				{
					calls.remove(Compute_Deadline);
					calls.add(Compute_Deadline);
				}
			}
		}
		call.name.debug('addSubprogramCall');
	}
}

rule NextValueToJobParameters (port : AADLI!FeatureInstance,
						 	  dstThreadImg : AADLBA!ThreadImplementation,
							  nextValueCall : AADLBA!SubprogramCall)
{
	do
	{
		for(co in port.getAllInternalConnections())
		{
			dstThreadImg.ownedParameterConnection.add(
				thisModule.NextValueToJobParameter(
					co, dstThreadImg, nextValueCall)
			);
		}
	}
}

rule NextValueToJobParameter         (co : AADLI!Connection, -- parameter connected to the port
									 dstThreadImg : AADLBA!ThreadImplementation, -- output thread impl,
									 nextValueCall : AADLBA!SubprogramCall)
{
	using
	{
		callName  : String = co.destination.context.name;
		call    : AADLBA!SubprogramCall =  dstThreadImg.getCall(callName);
	}
	to
		conn: AADLBA!ParameterConnection
		(
			name <- 'cnx_' + nextValueCall.name + '_to_' 
			         + callName + '_' + co.destination.connectionEnd.name,
			source <- conn_source,
			destination <- conn_dest
		),
		conn_source : AADLBA!ConnectedElement
		(
			context <- nextValueCall,
			connectionEnd <- nextValueCall.calledSubprogram
			                    .ownedExtension.extended.ownedParameter
								->any(p|p.name='DataValue')
		),
		conn_dest : AADLBA!ConnectedElement
		(
			context <- call,
			connectionEnd <- call.calledSubprogram.ownedParameter
			        ->any(p|p.name=co.destination.connectionEnd.name)
		)
	do { conn; }
	
}


rule JobParametersToPortDataValue (cnxInst : AADLI!ConnectionInstance,
								   dstThreadImg : AADLBA!ThreadImplementation,
								   portDataSubcomponent : AADLBA!DataSubcomponent)
{
	do
	{
		for(co in cnxInst.source.getAllInternalConnections())
		{
			dstThreadImg.ownedParameterConnection.add(
				thisModule.JobParameterToPortDataValue(
					co, dstThreadImg, portDataSubcomponent)
			);
		}
	}
}

rule JobParameterToPortDataValue    (co : AADLI!Connection,
									 dstThreadImg : AADLBA!ThreadImplementation,
									 portDataSubcomponent : AADLBA!DataSubcomponent)
{
	using
	{
		callName  : String = co.source.context.name;
		call    : AADLBA!SubprogramCall =  dstThreadImg.getCall(callName);
	}
	to
		conn_source : AADLBA!ConnectedElement 
		(
			context <- call,
			connectionEnd <- call.calledSubprogram.ownedParameter
		           ->any(p|p.name=co.source.connectionEnd.name)
		),
		conn_dest : AADLBA!ConnectedElement
		(
			connectionEnd <- portDataSubcomponent
		),
		conn: AADLBA!ParameterConnection 
		(
			name <- 'cnx_' + callName + '_' + conn_source.connectionEnd.name 
			               + '_to_' + portDataSubcomponent.name,
			source <- conn_source,
			destination <- conn_dest
		)
	do { conn; }
}
--
-- AADL-RAMSES
-- 
-- Copyright ï¿½ 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--
-- @nsURI AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore


module EventDataPorts_LowMFP;
create OUT: AADLBA from IN: AADLI, AADL_RUNTIME: AADLBA, DATA_MODEL: AADLBA,
		PROGRAMMING_PROPERTIES: AADLBA, HOOKS: ATLHOOKS, PERIODICDELAYED_RUNTIME: AADLBA,
		ARINC653_RUNTIME: AADLBA;

uses AADLCopyHelpers;
uses AADLICopyHelpers;
uses Uninstanciate;
uses PropertiesTools;
uses Services;

helper def : Put_Value_Name     : String = 'Put_Value_LowFP';
helper def : Receive_Input_Name : String = 'Receive_Input_LowFP';
helper def : Component_Instance_Type_Name : String = 'component_instance_t.impl';
helper def : Component_Instance_Array_Type_Name: String = 'ComponentInstanceArrayDataType';
helper def : Periodic_Delayed_Context_Type_Name : String = 'periodic_delayed_context_t';
helper def : Periodic_Delayed_Context_Impl_Name : String = 'periodic_delayed_context_t.impl';

helper def: getHyperperiod(destinationPort: AADLI!FeatureInstance) : Integer = 
	thisModule.theHOOK.getHyperperiod(destinationPort)
;


rule intraProcess_PeriodicDelayed_PortConnection_Instance
{
	from
		cnxInst: AADLI!ConnectionInstance
		(
			cnxInst.destination.isPeriodicDelayedPort().debug('IS PERIODIC-DELAYED DESTINATION') and
			cnxInst.source.isPeriodicDelayedPort().debug('IS PERIODIC-DELAYED SOURCE')
		)
	using
	{
		-- next variable will be initialized in the imperative "do" section
		-- to be sure it is executed after the creation of output element we are
		-- looking for
		srcThreadImg: AADLBA!ThreadImplementation = OclUndefined;
		processImg : AADLBA!Subcomponent = OclUndefined;
		
		port: AADLI!FeatureInstance = cnxInst.source;
		CurrentDeadlineWriteTable: Sequence(Integer) = thisModule.getCurrentDeadlineWriteTable(port, cnxInst.destination);
		consumerPort: AADLI!FeatureInstance = cnxInst.destination;
		ArrayDataType: AADLBA!SubprogramType = 'ArrayDataType'.asDataType('PERIODICDELAYED_RUNTIME');
		Put_Value_PrototypeSpg: AADLBA!SubprogramType = thisModule.Put_Value_Name.asSubprogramType('PERIODICDELAYED_RUNTIME');
		Periodic_Delayed_Context_Prototype: AADLBA!DataImplementation = thisModule.Periodic_Delayed_Context_Impl_Name.asDataType('PERIODICDELAYED_RUNTIME'); 
		portAbsoluteName: String = thisModule.getProgrammationLanguageIdentifier(port.getComponentInstancePath());
	}
	to
		-----------------------
		--- Data Subcomponents
		-----------------------
		CDWSizeInit: AADLBA!ListValue
		(
			ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression(
															CurrentDeadlineWriteTable->size().toString())}
		),
		CDWSize: AADLBA!DataSubcomponent (
		    name<-port.name+'_CDWSize',
			dataSubcomponentType <- 'Integer_16'.asDataType('BASE_TYPES'),
			ownedPropertyAssociation <- Sequence {
												thisModule.CreatePropertyAssociation(
												 	'Initial_Value',
													'DATA_MODEL',
													CDWSizeInit)
									   }
		    ),
		value: AADLBA!DataSubcomponent (
			name <- port.name+'_currentValue',
			dataSubcomponentType <- port.feature.dataFeatureClassifier.getClassifierInOutput()
		),
		
		-----------------------
		--- Thread configuration
		-----------------------
		
		--- Buffer
		bufferAccessThread: AADLBA!DataAccess
		(
			name <- port.name+'_bufferAccess',
			dataFeatureClassifier <- thisModule.resolveTemp(cnxInst.destination, 'bufferArrayType'),
			kind<-#requires
		),
		connected_Buffer_Access: AADLBA!ConnectedElement
		(
			connectionEnd<-bufferAccessThread,
			context<-port.eContainer().getSubcomponentImg()
		),
		connected_Buffer_Data: AADLBA!ConnectedElement
		(
			connectionEnd<-thisModule.resolveTemp(cnxInst.destination, 'bufferSubcomponent')
		),
		accessBufferConnection: AADLBA!AccessConnection
		(
			name<-portAbsoluteName+'_to_Buffer',
			accessCategory<-#data,
			source<-connected_Buffer_Access,
			destination<-connected_Buffer_Data
		),
		
		-----------------------
		--- Put_Value
		-----------------------
		extendedPutValueSpg: AADLBA!TypeExtension
		(
			extended<-Put_Value_PrototypeSpg
		),
		putValueSpg: AADLBA!SubprogramType
		(
			name <- Put_Value_PrototypeSpg.name+'_'+thisModule.getProgrammationLanguageIdentifier(port.getComponentInstancePath()),
			ownedExtension <- extendedPutValueSpg,
			ownedPrototypeBinding <- Sequence{putValueOutputPrototypeBinding,putValueContextPrototypeBinding},
			ownedParameter <- Sequence{}, -- CDWParam
			ownedDataAccess <- Sequence{BufferAccess}
		),
		putValueCall: AADLBA!SubprogramCall
		(
			name<-thisModule.callPrefix()+putValueSpg.name,
			calledSubprogram<-putValueSpg
		),
		putValueOutputActual: AADLBA!ComponentPrototypeActual
		(
			category<-#data
		),
		putValueOutputPrototypeBinding: AADLBA!ComponentPrototypeBinding
		(
			formal <- Put_Value_PrototypeSpg.ownedPrototype->any(e|e.name = 'value_type'),
			actual <- Sequence{putValueOutputActual}
		),
		
		BufferAccess: AADLBA!DataAccess
		(
			name <- 'buffer',
			refined <- Put_Value_PrototypeSpg.ownedDataAccess->any(e|e.name = 'buffer'),
			dataFeatureClassifier <- thisModule.resolveTemp(cnxInst.destination, 'bufferArrayType'),
			kind<-#requires
		),
		putValueContextPrototypeBinding: AADLBA!ComponentPrototypeBinding
		(
			formal <- Put_Value_PrototypeSpg.ownedPrototype->any(e|e.name = 'context_prototype'),
			actual <- Sequence{putValueContextActual}
		),
		putValueContextActual: AADLBA!ComponentPrototypeActual
		(
			category<-#data
		),
		extensionPeriodicDelayedContext: AADLBA!ImplementationExtension
		(
			extended<-Periodic_Delayed_Context_Prototype
		),
		
		--- connect CDWSize
		connected_CDWSize_Param: AADLBA!ConnectedElement
		(
			connectionEnd<-Put_Value_PrototypeSpg.ownedParameter->any(e|e.name = 'CDWSize'),
			context<-putValueCall
		),
		connected_CDWSize_Data: AADLBA!ConnectedElement
		(
			connectionEnd<-CDWSize
		),
		paramCDWSizeConnection: AADLBA!ParameterConnection
		(
			name<-port.name+'_to_CDWSize',
			source<-connected_CDWSize_Param,
			destination<-connected_CDWSize_Data
		),
		
		
		--- connect IterationCounter
		connected_IterationCounter_Param: AADLBA!ConnectedElement
		(
			connectionEnd<-Put_Value_PrototypeSpg.ownedParameter->any(e|e.name = 'iteration_counter'),
			context<-putValueCall
		),
		connected_IterationCounter_Data: AADLBA!ConnectedElement,
		paramIterationCounterConnection: AADLBA!ParameterConnection
		(
			name<-port.name+'_to_IterationCounter',
			source<-connected_IterationCounter_Param,
			destination<-connected_IterationCounter_Data
		),
		
		--- connect value
		
		connected_Output_Param: AADLBA!ConnectedElement
		(
			connectionEnd<-Put_Value_PrototypeSpg.ownedParameter->any(e | e.name = 'value'),
			context<-putValueCall
		),
		connected_CurrentValue_Data: AADLBA!ConnectedElement
		(
			connectionEnd<-value
		),
		paramValueConnectionPutValue: AADLBA!ParameterConnection
		(
			name<-port.name+'_to_value',
			source<-connected_CurrentValue_Data,
			destination<-connected_Output_Param
		),
		
		--- connect buffer
		
		connected_Buffer_PutValueAccess: AADLBA!ConnectedElement
		(
			connectionEnd<-BufferAccess,
			context<-putValueCall
		),
		connected_Buffer_ThreadAccess: AADLBA!ConnectedElement
		(
			connectionEnd<-bufferAccessThread
		),
		accessBufferConnectionNextValue: AADLBA!AccessConnection
		(
			name<-port.name+'_to_buffer',
			accessCategory<-#data,
			source<-connected_Buffer_PutValueAccess,
			destination<-connected_Buffer_ThreadAccess
		)
		
	do
	{
		-- next is a workaround
		putValueOutputActual.setSubcomponentType(port.feature.dataFeatureClassifier.getClassifierInOutput());
		putValueContextActual.setSubcomponentType(thisModule.resolveTemp(consumerPort, 'Periodic_Delayed_Context_Type'));
		
		-- init
		srcThreadImg<-cnxInst.source.eContainer().getSubcomponentImg().classifier;
		processImg<-cnxInst.source.eContainer().eContainer().getSubcomponentImg().classifier;
		
		-- populate thread
		srcThreadImg.type.ownedDataAccess.add(bufferAccessThread);
		srcThreadImg.ownedDataSubcomponent.add(thisModule.createIterationCounter(srcThreadImg));
		
		srcThreadImg.ownedDataSubcomponent.add(CDWSize);
		srcThreadImg.ownedDataSubcomponent.add(value);
		srcThreadImg.ownedParameterConnection.add(paramIterationCounterConnection);
		srcThreadImg.ownedParameterConnection.add(paramCDWSizeConnection);
		srcThreadImg.ownedParameterConnection.add(paramValueConnectionPutValue);
		srcThreadImg.ownedAccessConnection.add(accessBufferConnectionNextValue);
		
		connected_IterationCounter_Data.connectionEnd<-thisModule.createIterationCounter(srcThreadImg);
		thisModule.addSubprogramCall(port.feature, srcThreadImg, putValueCall);
		
		-- populate process
		processImg.ownedAccessConnection.add(accessBufferConnection);
		
		-- populate package
		-- add Next_Value_<p> to the package
		thisModule.public().ownedClassifier.add(putValueSpg);
		-- add IndexArrayType_<p> to the package
		
			
		thisModule.addImportedUnit(thisModule.public(), 'PERIODICDELAYED_RUNTIME', 'PeriodicDelayed_runtime');
		thisModule.addImportedUnit(thisModule.public(), 'BASE_TYPES', 'Base_Types');
		thisModule.addImportedUnitFromInputModel(thisModule.public(), port.feature);
		
		thisModule.createCDWTable(cnxInst, putValueCall);
	}
}

rule In_PeriodicDelayed_EventDataPort_Instance
{
	from
		port: AADLI!FeatureInstance
		(
			port.direction.toString()='in' and
			port.isPeriodicDelayedPort()
		)
	using
	{
		-- next variable will be initialized in the imperative "do" section
		-- to be sure it is executed after the creation of output element we are
		-- looking for
		processImg : AADLBA!Subcomponent = OclUndefined;
		dstThreadImg: AADLBA!ThreadImplementation = OclUndefined;
		initial: Integer = -1;
		initialit: Integer = -1;
		
		CurrentPerionReadTable: Sequence(Integer) = thisModule.getCurrentPerionReadTable(port);
		BufferSize: Integer = thisModule.getBufferSize(port);
		ArrayDataType: AADLBA!SubprogramType = 'ArrayDataType'.asDataType('PERIODICDELAYED_RUNTIME');
		Receive_Input_PrototypeSpg: AADLBA!SubprogramType = thisModule.Receive_Input_Name.asSubprogramType('PERIODICDELAYED_RUNTIME');
		Next_Value_PrototypeSpg: AADLBA!SubprogramType = 'Next_Value'.asSubprogramType('PERIODICDELAYED_RUNTIME');
		Component_Instance_Type: AADLBA!DataImplementation = thisModule.Component_Instance_Type_Name.asDataType('PERIODICDELAYED_RUNTIME');
		Component_Instance_Array_Type: AADLBA!DataType = thisModule.Component_Instance_Array_Type_Name.asDataType('PERIODICDELAYED_RUNTIME');
		Periodic_Delayed_Context_Prototype_Type: AADLBA!DataType = thisModule.Periodic_Delayed_Context_Type_Name.asDataType('PERIODICDELAYED_RUNTIME');
		Periodic_Delayed_Context_Prototype_Impl: AADLBA!DataImplementation = thisModule.Periodic_Delayed_Context_Impl_Name.asDataType('PERIODICDELAYED_RUNTIME');
		portAbsoluteName: String = thisModule.getProgrammationLanguageIdentifier(port.getComponentInstancePath());
	}
	to
		-----------------------
		--- Data Subcomponents
		-----------------------
		extendedArrayDataType: AADLBA!TypeExtension
		(
			extended<-ArrayDataType
		),
		bufferArrayType: AADLBA!DataType
		(
			name <- 'BufferArrayType_'+port.eContainer().name+'_'+port.name,
			ownedExtension <- extendedArrayDataType,
			ownedPropertyAssociation <- Sequence {
												
												thisModule.CreatePropertyAssociation
												(
												 	'Data_Representation',
													'DATA_MODEL',
													'Array'.asEnumeration('DATA_MODEL').asNamedValue()
												),
												
												thisModule.CreatePropertyAssociation
												(
												 	'Base_Type',
													'DATA_MODEL',
													thisModule.CreateListValueFromClassifier(
														'Integer_16'.asClassifier('BASE_TYPES')
													)
												),
												
												thisModule.CreatePropertyAssociation
												(
												 	'Dimension',
													'DATA_MODEL',
													thisModule.CreateListValueFromInteger(
														BufferSize.longValue())
												)
									   }
		),
		bufferSubcomponent:AADLBA!DataSubcomponent
		(
			name<-port.eContainer().name+'_'+port.name+'_Buffer',
			dataSubcomponentType <- bufferArrayType
		),
		
		BufferSizeInit: AADLBA!ListValue
		(
			ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression(
															BufferSize.toString())}
		),
		
		bufferSizeSubcomponent:AADLBA!DataSubcomponent
		(
			name<-port.eContainer().name+'_'+port.name+'_BufferSize',
			dataSubcomponentType <- 'Integer_16'.asDataType('BASE_TYPES'),
			ownedPropertyAssociation <- Sequence {
				thisModule.CreatePropertyAssociation(
												 	'Initial_Value',
													'DATA_MODEL',
													BufferSizeInit)
			}
		),
		
		CPRSizeInit: AADLBA!ListValue
		(
			ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression(
															CurrentPerionReadTable->size().toString())}
		),
		CPRSize: AADLBA!DataSubcomponent (
		    name<-port.name+'_CPRSize',
			dataSubcomponentType <- 'Integer_16'.asDataType('BASE_TYPES'),
			ownedPropertyAssociation <- Sequence {
												thisModule.CreatePropertyAssociation(
												 	'Initial_Value',
													'DATA_MODEL',
													CPRSizeInit)
									   }
		    ),
		lastIndexInit: AADLBA!ListValue
		(
			ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression(initial.toString())}
		),
		lastIndex:AADLBA!DataSubcomponent (
			name <- port.name+'_lastIndex',
			dataSubcomponentType <- 'Integer_16'.asDataType('BASE_TYPES'),
			ownedPropertyAssociation <- Sequence {
												thisModule.CreatePropertyAssociation(
												 	'Initial_Value',
													'DATA_MODEL',
													lastIndexInit)
									   }
		),
		readIndexInit: AADLBA!ListValue
		(
			ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression(initial.toString())}
		),
		readIndex:AADLBA!DataSubcomponent (
			name <- port.name+'_readIndex',
			dataSubcomponentType <- 'Integer_16'.asDataType('BASE_TYPES'),
			ownedPropertyAssociation <- Sequence {
												thisModule.CreatePropertyAssociation(
												 	'Initial_Value',
													'DATA_MODEL',
													readIndexInit)
									   }
		),
		IterationCounterInit: AADLBA!ListValue
		(
			ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression(initialit.toString())}
		),
		IterationCounter:AADLBA!DataSubcomponent (
			name <- port.name+'_IterationCounter',
			dataSubcomponentType <- 'Integer_16'.asDataType('BASE_TYPES'),
			ownedPropertyAssociation <- Sequence {
												thisModule.CreatePropertyAssociation(
												 	'Initial_Value',
													'DATA_MODEL',
													IterationCounterInit)
									   }
		),
		currentValue: AADLBA!DataSubcomponent (
			name <- port.name+'_currentValue',
			dataSubcomponentType <- port.feature.dataFeatureClassifier.getClassifierInOutput()
		),
		-----------------------
		--- Thread configuration
		-----------------------
		
		--- Buffer
		bufferAccessThread: AADLBA!DataAccess
		(
			name <- port.name+'_bufferAccess',
			dataFeatureClassifier <- bufferArrayType,
			kind<-#requires
		),
		connected_Buffer_Access: AADLBA!ConnectedElement
		(
			connectionEnd<-bufferAccessThread,
			context<-port.eContainer().getSubcomponentImg()
		),
		connected_Buffer_Data: AADLBA!ConnectedElement
		(
			connectionEnd<-bufferSubcomponent
		),
		accessBufferConnection: AADLBA!AccessConnection
		(
			name<-portAbsoluteName+'_to_Buffer',
			accessCategory<-#data,
			source<-connected_Buffer_Access,
			destination<-connected_Buffer_Data
		),
		
		
		--- Current Value
		currentValueAccess:AADLBA!DataAccess(
			name <- port.name+'_currentValueAccess',
			dataFeatureClassifier <- port.feature.dataFeatureClassifier.getClassifierInOutput(),
			kind<-#requires
		),
		connected_CurrentValue_Access: AADLBA!ConnectedElement
		(
			connectionEnd<-currentValueAccess,
			context<-port.eContainer().getSubcomponentImg()
		),
		connected_CurrentValue_Data: AADLBA!ConnectedElement
		(
			connectionEnd<-currentValue
		),
		accessCurrentValueConnection: AADLBA!AccessConnection
		(
			name<-portAbsoluteName+'_to_currentValue',
			accessCategory<-#data,
			source<-connected_CurrentValue_Access,
			destination<-connected_CurrentValue_Data
		),
		
		-----------------------
		--- Receive_Input
		-----------------------
		extendedReceiveInputSpg: AADLBA!TypeExtension
		(
			extended<-Receive_Input_PrototypeSpg
		),
		receiveInputSpg: AADLBA!SubprogramType
		(
			name <- Receive_Input_PrototypeSpg.name+'_'+thisModule.getProgrammationLanguageIdentifier(port.getComponentInstancePath()),
			ownedExtension <- extendedReceiveInputSpg,
			ownedPrototypeBinding <- Sequence{receiveInputContextPrototypeBinding},
			ownedParameter <- Sequence{}
		),
		receiveInputContextPrototypeBinding: AADLBA!ComponentPrototypeBinding
		(
			formal <- Receive_Input_PrototypeSpg.ownedPrototype->any(e|e.name = 'context_prototype'),
			actual <- Sequence{receiveInputContextActual}
		),
		receiveInputContextActual: AADLBA!ComponentPrototypeActual
		(
			category<-#data
		),
		Periodic_Delayed_Context_Type: AADLBA!DataType
		(
			name <- Periodic_Delayed_Context_Prototype_Type.name,
			ownedExtension <- extensionPeriodicDelayedContextType
		),
		Periodic_Delayed_Context_Impl: AADLBA!DataImplementation
		(
			name <- Periodic_Delayed_Context_Prototype_Impl.name+'_'+thisModule.getProgrammationLanguageIdentifier(port.getComponentInstancePath()),
			ownedExtension <- extensionPeriodicDelayedContext,
			ownedDataSubcomponent <- Sequence{refined_Context_Subcomponent}
		),
		refined_Context_Subcomponent: AADLBA!DataSubcomponent
		(
			name <- 'writer_instances',
			refined <- Periodic_Delayed_Context_Prototype_Impl.ownedDataSubcomponent->any(e|e.name = 'writer_instances'),
			dataSubcomponentType <- ComponentInstanceArrayDataType
		),
		ComponentInstanceArrayDataTypeExtension: AADLBA!TypeExtension
		(
			extended<-Component_Instance_Array_Type
		),
		ComponentInstanceArrayDataType: AADLBA!DataType
		(
			name <- 'ComponentInstanceArrayDataType_'+port.eContainer().name+'_'+port.name,
			ownedExtension <- ComponentInstanceArrayDataTypeExtension,
			ownedPropertyAssociation <- Sequence {
												
												thisModule.CreatePropertyAssociation
												(
												 	'Data_Representation',
													'DATA_MODEL',
													'Array'.asEnumeration('DATA_MODEL').asNamedValue()
												),
												
												thisModule.CreatePropertyAssociation
												(
												 	'Base_Type',
													'DATA_MODEL',
													thisModule.CreateListValueFromClassifier(
														Component_Instance_Type
													)
												),

												thisModule.CreatePropertyAssociation
												(
												 	'Dimension',
													'DATA_MODEL',
													thisModule.CreateListValueFromInteger(
														port.dstConnectionInstance->size().longValue()
													)
												)
									   }
		),
		extensionPeriodicDelayedContext: AADLBA!ImplementationExtension
		(
			extended<-Periodic_Delayed_Context_Prototype_Impl
		),
		extensionPeriodicDelayedContextType: AADLBA!TypeExtension
		(
			extended<-Periodic_Delayed_Context_Prototype_Type
		),
		receiveInputCall: AADLBA!SubprogramCall
		(
			name<-thisModule.callPrefix()+receiveInputSpg.name,
			calledSubprogram<-receiveInputSpg
		),
		--- connect cprSize
		connected_CPRSize_Param: AADLBA!ConnectedElement
		(
			connectionEnd<-Receive_Input_PrototypeSpg.ownedParameter->any(e|e.name = 'CPRSize'),
			context<-receiveInputCall
		),
		connected_CPRSize_Data: AADLBA!ConnectedElement
		(
			connectionEnd<-CPRSize
		),
		paramCPRSizeConnection: AADLBA!ParameterConnection
		(
			name<-port.name+'_to_CPRSize',
			source<-connected_CPRSize_Param,
			destination<-connected_CPRSize_Data
		),
		
		
		--- connect IterationCounter
		connected_IterationCounter_Param: AADLBA!ConnectedElement
		(
			connectionEnd<-Receive_Input_PrototypeSpg.ownedParameter->any(e|e.name = 'iteration_counter'),
			context<-receiveInputCall
		),
		connected_IterationCounter_Data: AADLBA!ConnectedElement,
		paramIterationCounterConnection: AADLBA!ParameterConnection
		(
			name<-port.name+'_to_IterationCounter',
			source<-connected_IterationCounter_Param,
			destination<-connected_IterationCounter_Data
		),
		
		--- connect firstIndex
		
		connected_ReadIndex_ReceiveInputAccess: AADLBA!ConnectedElement
		(
			connectionEnd<-Receive_Input_PrototypeSpg.ownedDataAccess->any(e | e.name = 'first'),
			context<-receiveInputCall
		),
		connected_ReadIndex_ThreadSubcomponent: AADLBA!ConnectedElement
		(
			connectionEnd<-readIndex
		),
		accessReadIndexConnectionReceiveInput: AADLBA!AccessConnection
		(
			name<-port.name+'_to_ReceiveInput_first',
			accessCategory<-#data,
			source<-connected_ReadIndex_ThreadSubcomponent,
			destination<-connected_ReadIndex_ReceiveInputAccess
		),
		
		--- connect lastIndex
		
		connected_LastIndex_ReceiveInputAccess: AADLBA!ConnectedElement
		(
			connectionEnd<-Receive_Input_PrototypeSpg.ownedDataAccess->any(e | e.name = 'last'),
			context<-receiveInputCall
		),
		connected_LastIndex_ThreadSubcomponent: AADLBA!ConnectedElement
		(
			connectionEnd<-lastIndex
		),
		accessLastIndexConnectionReceiveInput: AADLBA!AccessConnection
		(
			name<-port.name+'_to_ReceiveInput_last',
			accessCategory<-#data,
			source<-connected_LastIndex_ThreadSubcomponent,
			destination<-connected_LastIndex_ReceiveInputAccess
		),
		
		--- connect bufferSize
		connected_bufferSize_Parameter: AADLBA!ConnectedElement
		(
			connectionEnd<-Receive_Input_PrototypeSpg.ownedParameter->any(e | e.name = 'bufferSize'),
			context<-receiveInputCall
		),
		connected_BufferSize_ThreadSubcomponent: AADLBA!ConnectedElement
		(
			connectionEnd<-bufferSizeSubcomponent
		),
		parameterbufferSizeConnectionReceiveInput: AADLBA!ParameterConnection
		(
			name<-port.name+'_to_ReceiveInput_bufferSize',
			source<-connected_BufferSize_ThreadSubcomponent,
			destination<-connected_bufferSize_Parameter
		),
		
		-----------------------
		--- Next_Value
		-----------------------
		extendedNextValueSpg: AADLBA!TypeExtension
		(
			extended<-Next_Value_PrototypeSpg
		),
		nextValueSpg: AADLBA!SubprogramType
		(
			name <- Next_Value_PrototypeSpg.name+'_'+thisModule.getProgrammationLanguageIdentifier(port.getComponentInstancePath()),
			ownedExtension <- extendedNextValueSpg,
			ownedPrototypeBinding <- Sequence{nextValueOutputPrototypeBinding},
			ownedDataAccess <- Sequence{BufferAccess}
		),
		nextValueCall: AADLBA!SubprogramCall
		(
			name<-thisModule.callPrefix()+nextValueSpg.name,
			calledSubprogram<-nextValueSpg
		),
		nextValueOutputActual: AADLBA!ComponentPrototypeActual
		(
			category<-#data
		),
		nextValueOutputPrototypeBinding: AADLBA!ComponentPrototypeBinding
		(
			formal <- Next_Value_PrototypeSpg.ownedPrototype->any(e|e.name = 'output_type'),
			actual <- Sequence{nextValueOutputActual}
		),
		
		BufferAccess: AADLBA!DataAccess
		(
			name <- 'buffer',
			refined <- Next_Value_PrototypeSpg.ownedDataAccess->any(e|e.name = 'buffer'),
			dataFeatureClassifier <- bufferArrayType,
			kind<-#requires
		),
		
		--- connect output
		
		connected_Output_Access: AADLBA!ConnectedElement
		(
			connectionEnd<-Next_Value_PrototypeSpg.ownedDataAccess->any(e | e.name = 'output'),
			context<-nextValueCall
		),
		connected_CurrentValue_ThreadAccess: AADLBA!ConnectedElement
		(
			connectionEnd<-currentValueAccess
		),
		accessOutputConnectionNextValue: AADLBA!AccessConnection
		(
			name<-port.name+'_to_output',
			accessCategory<-#data,
			source<-connected_CurrentValue_ThreadAccess,
			destination<-connected_Output_Access
		),
		
		--- connect first
		
		connected_ReadIndex_NextValueAccess: AADLBA!ConnectedElement
		(
			connectionEnd<-Next_Value_PrototypeSpg.ownedDataAccess->any(e | e.name = 'first'),
			context<-nextValueCall
		),
		connected_ReadIndex_NextValueThreadSubcomponent: AADLBA!ConnectedElement
		(
			connectionEnd<-readIndex
		),
		accessReadIndexConnectionNextValue: AADLBA!AccessConnection
		(
			name<-port.name+'_to_NextValue_first',
			accessCategory<-#data,
			source<-connected_ReadIndex_NextValueThreadSubcomponent,
			destination<-connected_ReadIndex_NextValueAccess
		),
		
		--- connect last
		
		connected_LastIndex_NextValueAccess: AADLBA!ConnectedElement
		(
			connectionEnd<-Next_Value_PrototypeSpg.ownedDataAccess->any(e | e.name = 'last'),
			context<-nextValueCall
		),
		connected_LastIndex_NextValueThreadSubcomponent: AADLBA!ConnectedElement
		(
			connectionEnd<-lastIndex
		),
		accessLastIndexConnectionNextValue: AADLBA!AccessConnection
		(
			name<-port.name+'_to_NextValue_last',
			accessCategory<-#data,
			source<-connected_LastIndex_NextValueThreadSubcomponent,
			destination<-connected_LastIndex_NextValueAccess
		),
		
		--- connect buffer
		
		connected_Buffer_NextValueAccess: AADLBA!ConnectedElement
		(
			connectionEnd<-BufferAccess,
			context<-nextValueCall
		),
		connected_Buffer_ThreadAccess: AADLBA!ConnectedElement
		(
			connectionEnd<-bufferAccessThread
		),
		accessBufferConnectionNextValue: AADLBA!AccessConnection
		(
			name<-port.name+'_to_buffer',
			accessCategory<-#data,
			source<-connected_Buffer_NextValueAccess,
			destination<-connected_Buffer_ThreadAccess
		),
		
		--- connect bufferSize
		
		connected_bufferSize_ParameterNextValue: AADLBA!ConnectedElement
		(
			connectionEnd<-Next_Value_PrototypeSpg.ownedParameter->any(e | e.name = 'bufferSize'),
			context<-nextValueCall
		),
		connected_bufferSize_Subcomponent: AADLBA!ConnectedElement
		(
			connectionEnd<-bufferSizeSubcomponent
		),
		parameterBufferSizeConnectionNextValue: AADLBA!ParameterConnection
		(
			name<-port.name+'_to_bufferSize',
			source<-connected_bufferSize_ParameterNextValue,
			destination<-connected_bufferSize_Subcomponent
		),
		contextSubcomponent: AADLBA!DataSubcomponent
		(
			name <- 'context_'+port.eContainer().name+'_'+port.name,
			dataSubcomponentType <- Periodic_Delayed_Context_Impl
		)
	do
	{
		-- next is a workaround
		nextValueOutputActual.setSubcomponentType(port.feature.dataFeatureClassifier.getClassifierInOutput());
		receiveInputContextActual.setSubcomponentType(Periodic_Delayed_Context_Impl);
		
		--init
		processImg<-port.eContainer().eContainer().getSubcomponentImg().classifier;
		dstThreadImg<-port.eContainer().getSubcomponentImg().classifier;
		
		--populate thread
		dstThreadImg.type.ownedDataAccess.add(bufferAccessThread);
		dstThreadImg.type.ownedDataAccess.add(currentValueAccess);
		
		dstThreadImg.ownedDataSubcomponent.add(CPRSize);
		--dstThreadImg.ownedDataSubcomponent.add(thisModule.createIterationCounter(dstThreadImg));
		--connected_IterationCounter_Data.connectionEnd<-thisModule.createIterationCounter(dstThreadImg);
		dstThreadImg.ownedDataSubcomponent.add(IterationCounter);
		dstThreadImg.ownedDataSubcomponent.add(bufferSizeSubcomponent);
		dstThreadImg.ownedDataSubcomponent.add(lastIndex);
		dstThreadImg.ownedDataSubcomponent.add(readIndex);
		
		connected_IterationCounter_Data.connectionEnd<-IterationCounter;
		
		dstThreadImg.ownedParameterConnection.add(paramCPRSizeConnection);
		dstThreadImg.ownedParameterConnection.add(paramIterationCounterConnection);
		dstThreadImg.ownedParameterConnection.add(parameterBufferSizeConnectionNextValue);
		if(not Receive_Input_PrototypeSpg.ownedParameter->any(e | e.name = 'bufferSize').oclIsUndefined())
		{
			dstThreadImg.ownedParameterConnection.add(parameterbufferSizeConnectionReceiveInput);
		}
		dstThreadImg.ownedAccessConnection.add(accessReadIndexConnectionReceiveInput);
		dstThreadImg.ownedAccessConnection.add(accessLastIndexConnectionReceiveInput);
		dstThreadImg.ownedAccessConnection.add(accessBufferConnectionNextValue);
		dstThreadImg.ownedAccessConnection.add(accessLastIndexConnectionNextValue);
		dstThreadImg.ownedAccessConnection.add(accessReadIndexConnectionNextValue);
		dstThreadImg.ownedAccessConnection.add(accessOutputConnectionNextValue);
		
		-- subprogram call must be added from last to first here as
		-- addSubprogramCall "prepend" subprogram calls to the list
		-- when port is an input port
		thisModule.addSubprogramCall(port.feature, dstThreadImg, nextValueCall);
		thisModule.addSubprogramCall(port.feature, dstThreadImg, receiveInputCall);
		
		-- populate process
		processImg.ownedDataSubcomponent.add(bufferSubcomponent);
		processImg.ownedDataSubcomponent.add(currentValue);
		processImg.ownedAccessConnection.add(accessBufferConnection);
		processImg.ownedAccessConnection.add(accessCurrentValueConnection);
		
		-- populate package
		-- add Next_Value_<p> to the package
		thisModule.public().ownedClassifier.add(nextValueSpg);
		thisModule.public().ownedClassifier.add(receiveInputSpg);
		thisModule.public().ownedClassifier.add(bufferArrayType);
		if(thisModule.public().ownedClassifier->any(e|e.name = Periodic_Delayed_Context_Type.name).oclIsUndefined())
			thisModule.public().ownedClassifier.add(Periodic_Delayed_Context_Type);
		if(thisModule.public().ownedClassifier->any(e|e.name = Periodic_Delayed_Context_Impl.name).oclIsUndefined())
			thisModule.public().ownedClassifier.add(Periodic_Delayed_Context_Impl);
		thisModule.addImportedUnit(thisModule.public(), 'PERIODICDELAYED_RUNTIME', 'PeriodicDelayed_runtime');
		thisModule.addImportedUnit(thisModule.public(), 'BASE_TYPES', 'Base_Types');
		thisModule.createCPRTable(port, receiveInputCall);	
	}
		
}


-- Add taskID
helper context AADLI!ComponentInstance def: computeThreadID(): Integer =
	let threads: Sequence(AADLI!ComponentInstance) =
		AADLI!ComponentInstance -> allInstances() -> select(c | c.category=#thread)
	in
		threads.indexOf(self) - 1;


unique lazy rule createThreadID
{
	from
		thrd: AADLI!ComponentInstance (
			thrd.category = #thread
		)
	to
		thrdIDSub: AADLBA!DataSubcomponent (
			name <- 'ID',
			dataSubcomponentType <- 'Integer_16'.asClassifier('BASE_TYPES'),
			ownedPropertyAssociation <- Sequence{
				thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL', ID)
			}
		),
		ID: AADLBA!ListValue (
			ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression(
												thrd.computeThreadID().toString()
											)}
		)
	do {
		thrdIDSub;
	}
}


rule createCDWTable (cnxInst:AADLI!ConnectionInstance, 
					 putValueCall: AADLBA!SubprogramCall)
{
	using
	{
		srcThreadImg: AADLBA!ThreadImplementation = OclUndefined;
		processImg: AADLBA!ThreadImplementation = OclUndefined;
		port: AADLI!FeatureInstance = cnxInst.source;
		consumerPort: AADLI!FeatureInstance = cnxInst.destination;
		Put_Value_PrototypeSpg: AADLBA!SubprogramType = thisModule.Put_Value_Name.asSubprogramType('PERIODICDELAYED_RUNTIME');
		-- access type,
		Periodic_Delayed_Context_Impl: AADLBA!DataImplementation = thisModule.resolveTemp(consumerPort, 'Periodic_Delayed_Context_Impl');
		-- context data subcomponent
		contextSubcomponent: AADLBA!DataSubcomponent = thisModule.resolveTemp(consumerPort, 'contextSubcomponent');
	
		
		-- POUR AJOUT taskID
		thrdID: AADLBA!DataSubcomponent = thisModule.createThreadID(port.eContainer());
	}
	to
	    --- Insert Require Data Acces to Periodic_Delayed_Context
		periodic_Delayed_ContextAccess:AADLBA!DataAccess(
			name <- port.name+'_Periodic_Delayed_ContextAccess',
			dataFeatureClassifier <- Periodic_Delayed_Context_Impl, 
			kind<-#requires
		),
		
		-------------------------------------------------------
		-- Put_Value : connexion Periodic_Delayed_Context    --
		-------------------------------------------------------
		connected_periodic_Delayed_ParameterForPutValue: AADLBA!ConnectedElement
		(
			connectionEnd<-putValueCall.calledSubprogram.ownedExtension.extended.ownedDataAccess->any(e|e.name='periodic_delayed_context'),
			context<-putValueCall
		),
		
		connected_periodic_Delayed_ContextAccessForPutValue: AADLBA!ConnectedElement
		(
			connectionEnd<-periodic_Delayed_ContextAccess
		),
		
		access_Periodic_Delayed_ContextConnectionForPutValue: AADLBA!AccessConnection
		(
			name<-port.name+'_to_periodic_Delayed_Context',
			accessCategory<-#data,
			source<-connected_periodic_Delayed_ContextAccessForPutValue,
			destination<-connected_periodic_Delayed_ParameterForPutValue
		),
		
		
		-----------------------------------------------------------------------
		-- Connexion between process and writers of Periodic_Delayed_Context --
		-----------------------------------------------------------------------
		
		connected_periodic_Delayed_ContextAccess: AADLBA!ConnectedElement
		(
			connectionEnd<-periodic_Delayed_ContextAccess,
			context<-port.eContainer().getSubcomponentImg()
		),
		
		connected_periodic_Delayed_ContextData: AADLBA!ConnectedElement
		(
			connectionEnd<-contextSubcomponent
		),
		
		access_Periodic_Delayed_ContextConnection: AADLBA!AccessConnection
		(
			name<-port.eContainer().name+'_'+port.name+'_to_periodic_Delayed_Context',
			accessCategory<-#data,
			source<-connected_periodic_Delayed_ContextAccess,
			destination<-connected_periodic_Delayed_ContextData
		)
		,
		-- TaskID connexion
		connected_TaskID_PutValueAccess: AADLBA!ConnectedElement (
			connectionEnd <- putValueCall.calledSubprogram.ownedExtension.extended.ownedParameter->any(e | e.name = 'taskID'),
			context <- putValueCall
		),
		connected_TaskID_ThreadAccess: AADLBA!ConnectedElement (
			connectionEnd <- thrdID
		),
		accessTaskIDConnectionPutValue: AADLBA!ParameterConnection (
			name <- port.name + '_to_ReceiveInput_taskID',
			source <- connected_TaskID_ThreadAccess,
			destination <- connected_TaskID_PutValueAccess
		)
	do
	{
		srcThreadImg<-cnxInst.source.eContainer().getSubcomponentImg().classifier;
		processImg<-cnxInst.source.eContainer().eContainer().getSubcomponentImg().classifier;

		
		-- Add require data access to Periodic_Delayed_Context in Writer Threads
		srcThreadImg.type.ownedDataAccess.add(periodic_Delayed_ContextAccess);
		
		-- Add connexion to Writer Threads for Put_Value
		srcThreadImg.ownedAccessConnection.add(access_Periodic_Delayed_ContextConnectionForPutValue);
	
		-- Add connexion between process and Writer Threads
		processImg.ownedAccessConnection.add(access_Periodic_Delayed_ContextConnection);
				
		
		-- POUR AJOUT TASKID
		srcThreadImg.ownedParameterConnection.add(accessTaskIDConnectionPutValue);
		if (not srcThreadImg.ownedDataSubcomponent->contains(thrdID))
		{
			srcThreadImg.ownedDataSubcomponent.add(thrdID);
		}
		
	}
}


rule createCPRTable (port: AADLI!FeatureInstance, 
					 receiveInputCall: AADLBA!SubprogramCall)
{
	using
	{
		dstThreadImg: AADLBA!ThreadImplementation = OclUndefined; 
		Receive_Input_PrototypeSpg: AADLBA!SubprogramType = thisModule.Receive_Input_Name.asSubprogramType('PERIODICDELAYED_RUNTIME'); 
		Periodic_Delayed_Context_Prototype: AADLBA!DataImplementation = thisModule.Periodic_Delayed_Context_Impl_Name.asDataType('PERIODICDELAYED_RUNTIME');

		processImg: AADLBA!ProcessImplementation = OclUndefined;
		
		processInst: AADLI!ComponentInstance = port.eContainer().eContainer();
		Periodic_Delayed_Context_Type: AADLBA!DataImplementation = thisModule.resolveTemp(port, 'Periodic_Delayed_Context_Type');
		ComponentInstanceArrayDataType: AADLBA!DataType = thisModule.resolveTemp(port, 'ComponentInstanceArrayDataType');
	}
	to
		-- define the actual data type of context for an input port;
		-- the objective is to precise the size of the writer component instances array.
		
		
		
	    --- Insert Require Data Acces to Periodic_Delayed_Context
		periodic_Delayed_ContextAccess:AADLBA!DataAccess(
			name <- port.name+'_Periodic_Delayed_ContextAccess',
			dataFeatureClassifier <- Periodic_Delayed_Context_Type, 
			kind<-#requires
		),
		
		----------------------------------------
		-- Receive_Input connection to reader --
		----------------------------------------
		connected_periodic_Delayed_ParameterForReceive: AADLBA!ConnectedElement
		(
			connectionEnd<-receiveInputCall.calledSubprogram.ownedExtension.extended.ownedDataAccess->any(e|e.name='periodic_delayed_context'),
			context<-receiveInputCall
		),
		connected_periodic_Delayed_ContextAccessForReceive: AADLBA!ConnectedElement
		(
			connectionEnd<-periodic_Delayed_ContextAccess
		),
		access_Periodic_Delayed_ContextConnectionForReceive: AADLBA!AccessConnection
		(
			name<-port.name+'_to_periodic_Delayed_Context',
			accessCategory<-#data,
			source<-connected_periodic_Delayed_ContextAccessForReceive,
			destination<-connected_periodic_Delayed_ParameterForReceive
		)
		
	do
	{
		dstThreadImg<-port.eContainer().getSubcomponentImg().classifier;
		processImg<-processInst.getSubcomponentImg().classifier;
		
		-- Add require data access to Periodic_Delayed_Context in Writer Threads
		dstThreadImg.type.ownedDataAccess.add(periodic_Delayed_ContextAccess);
		
		-- Add connexion to Writer Threads for Put_Value
		dstThreadImg.ownedAccessConnection.add(access_Periodic_Delayed_ContextConnectionForReceive);
		
		thisModule.initContext(port, ComponentInstanceArrayDataType, Periodic_Delayed_Context_Type, periodic_Delayed_ContextAccess);
		
		-- in the package of the target model, we add the definition of data types, implementations, 
		-- subprograms, etc...
		
		thisModule.public().ownedClassifier.add(ComponentInstanceArrayDataType);
		thisModule.public().ownedClassifier.add(Periodic_Delayed_Context_Type);
	}
}

unique lazy rule initContext
{
	from
		port: AADLI!FeatureInstance, 
		ComponentInstanceArrayDataType: AADLBA!DataType,
		Periodic_Delayed_Context_Type: AADLBA!DataType,
		periodic_Delayed_ContextAccess:AADLBA!DataAccess
	using
	{
		processImg: AADLBA!ProcessImplementation = OclUndefined;
		processInst: AADLI!ComponentInstance = port.eContainer().eContainer();
		Component_Instance_Type: AADLBA!DataImplementation = thisModule.Component_Instance_Type_Name.asDataType('PERIODICDELAYED_RUNTIME');
		Component_Instance_Array_Type: AADLBA!DataImplementation = thisModule.Component_Instance_Array_Type_Name.asDataType('PERIODICDELAYED_RUNTIME');
		writerPortsImg: Sequence(AADLBA!DataSubcomponent) = OclUndefined;
		contextSubcomponent: AADLBA!DataSubcomponent = thisModule.resolveTemp(port, 'contextSubcomponent');
	}
	to
		componentInstancesArray: AADLBA!DataSubcomponent
		(
			name <- 'writer_instances_'+port.eContainer().name+'_'+port.name,
			dataSubcomponentType <- ComponentInstanceArrayDataType
		),
		contextInit: AADLBA!ListValue,
		componentInstancesInit: AADLBA!ListValue,
		connected_periodic_Delayed_ContextAccess: AADLBA!ConnectedElement
		(
			connectionEnd<-periodic_Delayed_ContextAccess,
			context<-port.eContainer().getSubcomponentImg()
		),
		
		connected_periodic_Delayed_ContextData: AADLBA!ConnectedElement
		(
			connectionEnd<-contextSubcomponent
		),
		
		access_Periodic_Delayed_ContextConnection: AADLBA!AccessConnection
		(
			name<-port.name+'_to_periodic_Delayed_Context',
			accessCategory<-#data,
			source<-connected_periodic_Delayed_ContextAccess,
			destination<-connected_periodic_Delayed_ContextData
		)
	do
	{
		processImg<-processInst.getSubcomponentImg().classifier;
		writerPortsImg <- port.dstConnectionInstance->collect(e| thisModule.initComponentInstanceSubcomponent(e.source.eContainer())); 
		processImg.ownedDataSubcomponent.addAll(writerPortsImg);
		processImg.ownedDataSubcomponent.add(componentInstancesArray);
		processImg.ownedDataSubcomponent.add(contextSubcomponent);
		processImg.ownedAccessConnection.add(access_Periodic_Delayed_ContextConnection);
		
		-- add writers instance array initial value
		componentInstancesInit.ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression(
																port.initWriterContext())
																};
		componentInstancesArray.ownedPropertyAssociation.add
		(
			thisModule.CreatePropertyAssociation(
												 	'Initial_Value',
													'DATA_MODEL',
													componentInstancesInit
												)
		);
		-- add context initial value
		contextInit.ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression(
																'{'+
																port.eContainer().getPeriod().toString()+
																','+
																componentInstancesArray.name+
																','+
																writerPortsImg->size().toString()+
																','+
																thisModule.getBufferSize(port).toString()+
																','+
																thisModule.getHyperperiod(port).toString()+
																'}'
															)};
		contextSubcomponent.ownedPropertyAssociation.add
		(
			thisModule.CreatePropertyAssociation(
												 	'Initial_Value',
													'DATA_MODEL',
													contextInit
												)
		);
		
		
	}
}

unique lazy rule initComponentInstanceSubcomponent
{
	from
		thread: AADLI!ComponentInstance
	using
	{
		Component_Instance_Type: AADLBA!DataImplementation = thisModule.Component_Instance_Type_Name.asDataType('PERIODICDELAYED_RUNTIME');
	}
	to
		componentInstance: AADLBA!DataSubcomponent
		(
			name <- 'writer_instance_'+thread.name,
			dataSubcomponentType <- Component_Instance_Type,
			ownedPropertyAssociation <- Sequence {
				thisModule.CreatePropertyAssociation(
												 	'Initial_Value',
													'DATA_MODEL',
													ComponentInstanceInit
												)
			}
		),
		ComponentInstanceInit: AADLBA!ListValue
		(
			ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression(
															thread.initWriterContext())}
		)
}

helper context AADLI!FeatureInstance def: initWriterContext() : String =
	thisModule.concatToString(
	    self.dstConnectionInstance->collect(e| e.source.eContainer())->asOrderedSet()
																	->collect(e|e.initWriterContext())
    )
;

helper context AADLI!ComponentInstance def: initWriterContext() : String = 
	'{'+self.getPeriod().toString()+
    ','+
	self.getDeadline().toString()+'}'
;
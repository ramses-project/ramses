--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLI=http:///AADL2/instance
-- @atlcompiler emftvm

module UninstanciateOverride;

create 
	OUT 			: AADLBA
from 
	IN 				: AADLI;


abstract rule m_Component_Implementation {
 from
    impl : AADLI!ComponentImplementation
 to
 	implImg : AADLBA!ComponentImplementation (
 		name             			<- impl.name,
		ownedComment     			<- impl.ownedComment,
		ownedAccessConnection  		<- impl.getConnectionsInstancesImg('accessConnection'),
		ownedParameterConnection 	<- impl.getConnectionsInstancesImg('parameterConnection'),
		ownedRealization 			<- thisModule.Realization(impl.type.resolve())
 	)
}


rule m_Subprogram_Type {
	from
		type : AADLI!SubprogramType
}

rule m_Data_Type {
 from
   type : AADLI!DataType 
}

rule m_Thread_Type {
 from
   type : AADLI!ThreadType 
}

-- @extends m_Component_Type
rule m_Process_Type {
 from
 	type : AADLI!ProcessType
 to 
 	typeImg : AADLBA!ProcessType
}

rule m_Data_Implementation {
  from
 	impl : AADLI!DataImplementation
}

-- @extends m_Feature_Instance
rule m_DataPort_Instance
{
	from
		fi: AADLI!FeatureInstance 
		(
			fi.category=#dataPort
			and
			not (fi.eContainer().category=#thread)
			and
			not (fi.eContainer().category=#process)
		)
	to
		f: AADLBA!DataPort
		(
			direction <- fi.feature.direction,
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier
		)
}

-- @extends m_Feature_Instance
rule m_EventPort_Instance
{
	from
		fi: AADLI!FeatureInstance 
		(
			fi.category=#eventPort
			and
			not (fi.eContainer().category=#thread)
			and
			not (fi.eContainer().category=#process)
		)
	to
		f: AADLBA!EventPort
		(
			direction <- fi.feature.direction
		)
}

-- @extends m_Feature_Instance
rule m_EventDataPort_Instance
{
	from
		fi: AADLI!FeatureInstance 
		(
			fi.category=#eventDataPort
			and
			not (fi.eContainer().category=#thread)
			and
			not (fi.eContainer().category=#process)
		)
	to
		f: AADLBA!EventDataPort
		(
			direction <- fi.feature.direction,
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier
		)
}


rule m_Subprogram_Implementation {
  from
 	impl : AADLI!SubprogramImplementation
}

rule m_Thread_Implementation {
  from
 	impl : AADLI!ThreadImplementation
}

rule m_PortConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (cnxRef.eContainer().kind = #portConnection)
}

-- @extends m_Connection_Reference
rule m_AccessConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (
			cnxRef.eContainer().kind = #accessConnection
			and
			not (cnxRef.connection.accessCategory=#subprogram)
			)
	to
		cnxImg: AADLBA!AccessConnection
		(accessCategory <- cnxRef.connection.accessCategory)
}

rule m_SubprogramAccessConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (cnxRef.eContainer().kind = #accessConnection and cnxRef.connection.accessCategory=#subprogram)
}

rule m_ParameterConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (cnxRef.eContainer().kind = #parameterConnection)
}

rule m_FeatureGroupConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (cnxRef.eContainer().kind = #featureGroupConnection)
}

rule m_create_Thread_BA
{
	from
		c : AADLI!ComponentInstance (c.category = #thread)
	using
 	{
 		impl : AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
 	}
	to
		sub : AADLBA!ThreadSubcomponent(
			threadSubcomponentType <- implImg
		),
		implImg : AADLBA!ThreadImplementation (
 			name <- c.uniqueName().concat('.impl'),
			ownedRealization <- thisModule.Realization(typeImg),
			ownedSubprogramSubcomponent 	<- c.componentInstance->select(e|e.category=#subprogram),
			ownedDataSubcomponent 			<- c.componentInstance->select(e|e.category=#data),
			ownedSubprogramCallSequence     <- if (c.subcomponent.subcomponentType.needsToMapBehaviorAnnex()) then
												Sequence{thisModule.resolveTemp(c,'callSequenceImg')}
											   else
											   	impl.ownedSubprogramCallSequence
												->select(e|e.isComputeEntryPointOf(c))
												->collect(e| thisModule.resolveTemp(Sequence{c,e}, 'callSequenceImg'))
											   endif,
			ownedParameterConnection		<- impl.ownedParameterConnection->select (e|
												e.source.oclIsKindOf(AADLI!Parameter) and e.destination.oclIsKindOf(AADLI!Parameter))
												->collect(e| thisModule.ParameterConnection(e))
												->union
												(
													impl.ownedParameterConnection->select (e|
														e.source.connectionEnd.oclIsKindOf(AADLI!DataSubcomponent) 
													)
													->collect(e|
														impl.ownedSubprogramCallSequence
														->collect(callSequence|
															thisModule.resolveTemp(Sequence{c.subcomponent->any(e|e.subcomponent = e.source.connectionEnd), callSequence, e}, 'parameterConnection')
														)
													)
												)
												->union
												(
													impl.ownedParameterConnection->select (e|
														e.destination.connectionEnd.oclIsKindOf(AADLI!DataSubcomponent) 
													)
													->collect(e|
														impl.ownedSubprogramCallSequence
														->collect(callSequence|
															thisModule.resolveTemp(Sequence{c.componentInstance->any(f|f.subcomponent = e.destination.connectionEnd), callSequence, e}, 'parameterConnection')
														)
													)
												)
												->flatten(),
			ownedAccessConnection			<- c.featureInstance->select(fi|fi.feature.oclIsKindOf(AADLI!Port))
												->collect(fi| impl.ownedSubprogramCallSequence
													->collect(callSequence|
														thisModule.resolveTemp(Sequence{fi,callSequence}, 'f_connection')
													)
												)
												->flatten()
												->union(impl.ownedSubprogramCallSequence
													->collect(callSequence | c.subcomponent.classifier.ownedAccessConnection
														-> select(accessCnx| 
															accessCnx.isAccessToParamConnection()
															and
															accessCnx.isPartOfCallSequence(callSequence)
															and
															callSequence.isComputeEntryPointOf(c)
														)
														->collect(
															accessCnx | thisModule.resolveTemp(Sequence{c, callSequence, accessCnx}, 'accessConnection')
														)
													)
												)->flatten()
													
		),
		typeImg : AADLBA!ThreadType (
 	 		name <- c.uniqueName(),
	 		ownedDataAccess <- c.featureInstance->select(e| (e.isThreadPort() and e.isInputFeature()) or e.feature.oclIsKindOf(AADLBA!DataAccess))->
													collect
													(
														f|thisModule.resolveTemp(f, 'f')
													)
													->union(
														c.featureInstance->select(e|e.isThreadPort() and e.isOutputFeature())
														->collect(
	 														f| f.srcConnectionInstance->collect(cnxInst |
																thisModule.resolveTemp(Sequence{f,cnxInst.connectionReference->first()}, 'f')
															)
														)
													)->flatten()
 		)
}

-- @extends m_Component_Instance,m_create_Thread_BA
rule m_Thread_Instance {
	from
		c : AADLI!ComponentInstance (c.category = #thread 
			and c.subcomponent.subcomponentType.oclIsKindOf(AADLI!ComponentImplementation)
			and (not c.subcomponent.subcomponentType.needsToMapBehaviorAnnex()))
	using
 	{
 		impl : AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
 	}
	to
		sub : AADLBA!ThreadSubcomponent,
		implImg : AADLBA!ThreadImplementation,
		typeImg : AADLBA!ThreadType
		
}


rule m_Process_Implementation {
 from
 	impl : AADLI!ProcessImplementation
 to 
 	implImg : AADLBA!ProcessImplementation (
 		name 							<- impl.name,
		ownedThreadGroupSubcomponent 	<- impl.getSubcomponentsInstances('threadgroup'),
		ownedThreadSubcomponent 		<- impl.getSubcomponentsInstances('thread'),
		ownedSubprogramSubcomponent 	<- impl.getSubcomponentsInstances('subprogram'),
		ownedDataSubcomponent 			<- impl.getSubcomponentsInstances('data')
												-- intraprocess input thread port
												-- process output port
												-- process input port
												->union(impl.getSubcomponentsInstances('thread')
													->collect(c| c.featureInstance
														->select(e| e.isThreadPort() and e.isInputFeature() and e.isIntraProcessFeatureInstance())
														->collect(fi |
																thisModule.resolveTemp(fi, 'globalVariable')
															)
														)
													)->union
													(
														impl.getSubcomponentsInstances('thread')
															->collect(c| c.eContainer().featureInstance
																->select(e| e.isProcessPort() and e.isOutputFeature())
																->collect(fi |
																	thisModule.resolveTemp(fi, 'globalVariable')
																)
															)
													)->union
													(
														impl.getSubcomponentsInstances('thread')
															->collect(c| c.eContainer().featureInstance
																->select(e| e.isProcessPort() and e.isInputFeature())
																->collect(fi |
																	thisModule.resolveTemp(fi, 'globalVariable')
																)
															)
													)
													->flatten(),
		ownedAccessConnection			<- impl.getConnectionsInstancesImg('accessConnection')
												->union(impl.getSubcomponentsInstances('thread')
													->collect(c| c.featureInstance
														->select (fi | fi.isOutputFeature())
														->collect(fi |
															fi.srcConnectionInstance
															->collect(cnxInst |
																thisModule.resolveTemp(Sequence{fi,cnxInst.connectionReference->first()}, 'accessConnection')
															)	
														)
													)
												)->flatten()
												->union(impl.getSubcomponentsInstances('thread')
													->collect(c| c.featureInstance
														->select (fi | fi.isInputFeature())
														->collect(fi |
															thisModule.resolveTemp(fi, 'accessConnection')	
														)
													)
												)->flatten()
											
	)
}

rule m_Processor_Instance {
	from
		c : AADLI!ComponentInstance (c.category = #processor)
	to
		sub : AADLBA!ProcessorSubcomponent
		(
			name <- c.name.debug('subcomponent created'),
			processorSubcomponentType <- c.subcomponent.subcomponentType,
			ownedPropertyAssociation  <- c.ownedPropertyAssociation->select(e | not (e.property.name.toLower() = 'scheduling_protocol'))
												->collectSelfPropertyAssociationImg()
												-> append(thisModule.CreatePropertyAssociation ('Scheduling_Protocol', 'DEPLOYMENT_PROPERTIES', listValue))
												
		),
		listValue : AADLBA!ListValue
		(
			ownedListElement <- Sequence{sched}
		),
		sched : AADLBA!NamedValue
		(
			namedValue <- el
		),
		el : AADLBA!EnumerationLiteral
		(
			name <- 'Posix_1003_Highest_Priority_First_Protocol'
		)
		
		
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(sub, c);
	}
}
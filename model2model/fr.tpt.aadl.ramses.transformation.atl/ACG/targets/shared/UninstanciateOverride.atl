--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLI=http:///AADL2/instance
-- @atlcompiler emftvm

module UninstanciateOverride;

create 
	OUT 			: AADLBA
from 
	IN 				: AADLI;


abstract rule m_Component_Implementation {
 from
    impl : AADLI!ComponentImplementation
 to
 	implImg : AADLBA!ComponentImplementation (
 		name             			<- impl.name,
		ownedComment     			<- impl.ownedComment,
		ownedAccessConnection  		<- impl.getConnectionsInstancesImg('accessConnection'),
		ownedParameterConnection 	<- impl.getConnectionsInstancesImg('parameterConnection'),
		ownedRealization 			<- thisModule.Realization(impl.type.resolve())
 	)
}


rule m_Subprogram_Type {
	from
		type : AADLI!SubprogramType
}

rule m_Data_Type {
 from
   type : AADLI!DataType 
}

rule m_Thread_Type {
 from
   type : AADLI!ThreadType 
}

-- @extends m_Component_Type
rule m_Process_Type {
 from
 	type : AADLI!ProcessType
 to 
 	typeImg : AADLBA!ProcessType
}

rule m_Data_Implementation {
  from
 	impl : AADLI!DataImplementation
}

-- @extends m_Feature_Instance
rule m_DataPort_Instance
{
	from
		fi: AADLI!FeatureInstance 
		(
			fi.category=#dataPort
			and
			not (fi.eContainer().category=#thread)
			and
			not (fi.eContainer().category=#process)
		)
	to
		f: AADLBA!DataPort
		(
			direction <- fi.feature.direction,
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier
		)
}

-- @extends m_Feature_Instance
rule m_EventPort_Instance
{
	from
		fi: AADLI!FeatureInstance 
		(
			fi.category=#eventPort
			and
			not (fi.eContainer().category=#thread)
			and
			not (fi.eContainer().category=#process)
		)
	to
		f: AADLBA!EventPort
		(
			direction <- fi.feature.direction
		)
}

-- @extends m_Feature_Instance
rule m_EventDataPort_Instance
{
	from
		fi: AADLI!FeatureInstance 
		(
			fi.category=#eventDataPort
			and
			not (fi.eContainer().category=#thread)
			and
			not (fi.eContainer().category=#process)
		)
	to
		f: AADLBA!EventDataPort
		(
			direction <- fi.feature.direction,
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier
		)
}


rule m_Subprogram_Implementation {
  from
 	impl : AADLI!SubprogramImplementation
}

rule m_Thread_Implementation {
  from
 	impl : AADLI!ThreadImplementation
}

rule m_PortConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (cnxRef.eContainer().kind = #portConnection)
}

rule m_ParameterConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (cnxRef.eContainer().kind = #parameterConnection)
}

rule m_FeatureGroupConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (cnxRef.eContainer().kind = #featureGroupConnection)
}

rule m_create_Thread_BA
{
	from
		c : AADLI!ComponentInstance (c.category = #thread)
	using
 	{
 		impl : AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
 	}
	to
		sub : AADLBA!ThreadSubcomponent(
			threadSubcomponentType <- implImg
		),
		implImg : AADLBA!ThreadImplementation (
 			name <- c.uniqueName().concat('.impl'),
			ownedRealization <- thisModule.Realization(typeImg),
			ownedSubprogramSubcomponent 	<- c.componentInstance->select(e|e.category=#subprogram),
			ownedDataSubcomponent 			<- c.componentInstance->select(e|e.category=#data),
			ownedSubprogramCallSequence     <- impl.ownedSubprogramCallSequence->select(e|e.isComputeEntryPointOf(c))->collect(e| thisModule.resolveTemp(Sequence{c,e}, 'callSequenceImg')),
			ownedParameterConnection		<- impl.ownedParameterConnection->select (e|
												e.source.oclIsKindOf(AADLI!Parameter) and e.destination.oclIsKindOf(AADLI!Parameter))
												->collect(e| thisModule.ParameterConnection(e))
												->union
												(
													impl.ownedParameterConnection->select (e|
														e.source.connectionEnd.oclIsKindOf(AADLI!DataSubcomponent) 
													)
													->collect(e|
														impl.ownedSubprogramCallSequence
														->collect(callSequence|
															thisModule.resolveTemp(Sequence{c.subcomponent->any(e|e.subcomponent = e.source.connectionEnd), callSequence, e}, 'parameterConnection')
														)
													)
												)
												->union
												(
													impl.ownedParameterConnection->select (e|
														e.destination.connectionEnd.oclIsKindOf(AADLI!DataSubcomponent) 
													)
													->collect(e|
														impl.ownedSubprogramCallSequence
														->collect(callSequence|
															thisModule.resolveTemp(Sequence{c.componentInstance->any(f|f.subcomponent = e.destination.connectionEnd), callSequence, e}, 'parameterConnection')
														)
													)
												)
												->flatten(),
			ownedAccessConnection			<- c.featureInstance->select(fi|fi.feature.oclIsKindOf(AADLI!Port))
												->collect(fi| impl.ownedSubprogramCallSequence
													->collect(callSequence|
														thisModule.resolveTemp(Sequence{fi,callSequence}, 'f_connection')
													)
												)
												->flatten()
												->union(impl.ownedSubprogramCallSequence
													->collect(callSequence | c.subcomponent.classifier.ownedAccessConnection
														-> select(accessCnx| 
															accessCnx.isAccessToParamConnection()
															and
															accessCnx.isPartOfCallSequence(callSequence)
															and
															callSequence.isComputeEntryPointOf(c)
														)
														->collect(
															accessCnx | thisModule.resolveTemp(Sequence{c, callSequence, accessCnx}, 'accessConnection')
														)
													)
												)->flatten()
													
		),
		typeImg : AADLBA!ThreadType (
 	 		name <- c.uniqueName(),
	 		ownedDataAccess <- c.featureInstance->select(e| (e.isThreadPort() and e.isInputFeature()) or e.feature.oclIsKindOf(AADLBA!DataAccess))->
													collect
													(
														f|thisModule.resolveTemp(f, 'f')
													)
													->union(
														c.featureInstance->select(e|e.isThreadPort() and e.isOutputFeature())
														->collect(
	 														f| f.srcConnectionInstance->collect(cnxInst |
																thisModule.resolveTemp(Sequence{f,cnxInst.connectionReference->first()}, 'f')
															)
														)
													)->flatten()
 		)
}

-- @extends m_Component_Instance,m_create_Thread_BA
rule m_Thread_Instance {
	from
		c : AADLI!ComponentInstance (c.category = #thread 
			and c.subcomponent.subcomponentType.oclIsKindOf(AADLI!ComponentImplementation)
			and (not c.subcomponent.subcomponentType.needsToMapBehaviorAnnex()))
	using
 	{
 		impl : AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
 	}
	to
		sub : AADLBA!ThreadSubcomponent,
		implImg : AADLBA!ThreadImplementation,
		typeImg : AADLBA!ThreadType
		
}

-- @extends m_Component_Instance,m_create_Thread_BA
rule m_Thread_Instance_WithBA {
 from 
    c : AADLI!ComponentInstance ( c.category = #thread 
			and c.subcomponent.subcomponentType.oclIsKindOf(AADLI!ComponentImplementation)
			and c.subcomponent.subcomponentType.needsToMapBehaviorAnnex())
 using
 {
    impl: AADLI!Thread = c.subcomponent.subcomponentType;
 	implBA: AADLBA!BehaviorAnnex = c.subcomponent.subcomponentType.ownedAnnexSubclause->any(e| e.oclIsTypeOf(AADLBA!BehaviorAnnex));
 }
 to 
 	sub : AADLBA!ThreadSubcomponent,
	implImg : AADLBA!ThreadImplementation,
	typeImg : AADLBA!ThreadType,
	entryPointImg: AADLBA!SubprogramType,
	entryPointImplImg: AADLBA!SubprogramImplementation,
	callEntryPoint: AADLBA!SubprogramCall,
	callEntryPointCallSequence: AADLBA!SubprogramCallSequence,
	stateType: AADLBA!DataType
	(
		name <- c.uniqueName().concat('_currentState'),
		ownedPropertyAssociation <- Sequence {
												
												thisModule.CreatePropertyAssociation
												(
												 	'Data_Representation',
													'DATA_MODEL',
													'Enum'.asEnumeration('DATA_MODEL').asNamedValue()
												),
												thisModule.CreatePropertyAssociation
												(
												 	'Enumerators',
													'DATA_MODEL',
													 thisModule.CreateListValueFromListOfString(implBA.states->collect(e|e.name))
												)
									}
	),
	currentState: AADLBA!DataSubcomponent
	(
		name <- 'Parent_BA_currentState',
		dataSubcomponentType <- stateType
	),
	currentStateAccess: AADLBA!DataAccess
	(
		name <- 'Parent_BA_currentState_Access',
		dataFeatureClassifier <- stateType,
		kind <- #requires
	),
	
	
	-- connect currentState feature of entryPointImg to the data subcomponent of the implImg that
	-- represents the state of implImg
	connectedAccess_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentStateAccess,
		context<-callEntryPoint
	),
	connectedSubcomponent_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentState
	),
	accessConnection_CURRENT_STATE: AADLBA!AccessConnection
	(
		name<-'CNX_CURRENT_STATE_BA',
		source<-connectedAccess_CURRENT_STATE,
		destination<-connectedSubcomponent_CURRENT_STATE,
		accessCategory <- #data
	)
 do
 {
 	-- set ownership
	-- add current state to thread implementation implImg
 	implImg.ownedDataSubcomponent->add(currentState);
 	-- add data type to package
	thisModule.public().getOwnedClassifiers()->add(stateType);
 	
 	-- add initial value to statType; must be set after adding stateType to the package
 	-- otherwise the qualified name is incorrect.
 	stateType.ownedPropertyAssociation.add(thisModule.CreatePropertyAssociation
												(
												 	'Initial_Value',
													'DATA_MODEL',
													 thisModule.CreateListValueFromString(stateType.getProgrammationLanguageIdentifier().concat('_')+thisModule.getBAInitialStateIdentifier(implBA))
												));
 	
 	-- add subprogram type to package
	thisModule.public().getOwnedClassifiers()->add(entryPointImg);
 	thisModule.public().getOwnedClassifiers()->add(entryPointImplImg);
 	
 	if(implImg.ownedSubprogramCallSequence->isEmpty())
 		implImg.ownedSubprogramCallSequence<-thisModule.createSubprogramCallSequence(implImg);
	
 	-- add call to entryPointImg
	implImg.ownedSubprogramCallSequence->first().getOwnedCallSpecifications().add(callEntryPoint);

 	-- add data accesses created from c.featureInstance
	entryPointImg.ownedDataAccess->addAll(c.featureInstance->collect(e|e.retreiveEntrypointFeature()));
	
 	for(f in c.featureInstance)
	{
 		thisModule.ports_dataSubcomponent <- thisModule.resolveTemp(f, 'dataSubcomponent');
 		if(not thisModule.ports_dataSubcomponent.oclIsUndefined())
 			entryPointImplImg.ownedDataSubcomponent.add(thisModule.ports_dataSubcomponent);
 	
 		if(f.direction=#out and f.category=#eventPort)
 		{
 			thisModule.addPutValueSubprogramCall(implImg.ownedSubprogramCallSequence->first(), impl, implImg, f);
 		}
 		
 		-- connect each feature of implImg to each copy of this feature in entryPointImg
		thisModule.addDataAccessConnection(	implImg,
							 		   	   	f.name.concat('_to_EntryPoint'),
							 			   	f.retreiveEntrypointFeature(),
							 			   	callEntryPoint,
							 				f.getFeatureImg());
 		if(f.feature.oclIsKindOf(AADLBA!Port))
		{
 			if(f.isUsedInFresh())
 			{
 				thisModule.ports_fresh_data_previous <- thisModule.resolveTemp(f, 'fresh_data_previous');
				thisModule.ports_fresh_data_type_wrapper <- thisModule.resolveTemp(f, 'fresh_data_type_wrapper');
				thisModule.ports_fresh_data_impl_wrapper <- thisModule.resolveTemp(f, 'fresh_data_impl_wrapper');
				thisModule.ports_fresh_previous_access <- thisModule.resolveTemp(f, 'fresh_previous_access');
				implImg.ownedDataSubcomponent.add(thisModule.ports_fresh_data_previous);
				-- add fresh_current_access to subprogram
				entryPointImg.ownedDataAccess.add(thisModule.ports_fresh_previous_access);
				-- add connection to call
				thisModule.addDataAccessConnection(implImg,
							 			f.name+'_freshness_cnx',
							 			thisModule.ports_fresh_previous_access,
							 			callEntryPoint,
							 			thisModule.ports_fresh_data_previous);
 			}
		}
	}
 	
 	-- add BA in entryPointImg
	entryPointImplImg.ownedAnnexSubclause->add(thisModule.copyBehaviorAnnexFromThread(c, 
															implBA, 
															currentStateAccess,
															stateType,
															entryPointImplImg));
 }
}


rule m_Process_Implementation {
 from
 	impl : AADLI!ProcessImplementation
 to 
 	implImg : AADLBA!ProcessImplementation (
 		name 							<- impl.name,
		ownedThreadGroupSubcomponent 	<- impl.getSubcomponentsInstances('threadgroup'),
		ownedThreadSubcomponent 		<- impl.getSubcomponentsInstances('thread'),
		ownedSubprogramSubcomponent 	<- impl.getSubcomponentsInstances('subprogram'),
		ownedDataSubcomponent 			<- impl.getSubcomponentsInstances('data')
												-- intraprocess input thread port
												-- process output port
												-- process input port
												->union(impl.getSubcomponentsInstances('thread')
													->collect(c| c.featureInstance
														->select(e| e.isThreadPort() and e.isInputFeature() and e.isIntraProcessFeatureInstance())
														->collect(fi |
																thisModule.resolveTemp(fi, 'globalVariable')
															)
														)
													)->union
													(
														impl.getSubcomponentsInstances('thread')
															->collect(c| c.eContainer().featureInstance
																->select(e| e.isProcessPort() and e.isOutputFeature())
																->collect(fi |
																	thisModule.resolveTemp(fi, 'globalVariable')
																)
															)
													)->union
													(
														impl.getSubcomponentsInstances('thread')
															->collect(c| c.eContainer().featureInstance
																->select(e| e.isProcessPort() and e.isInputFeature())
																->collect(fi |
																	thisModule.resolveTemp(fi, 'globalVariable')
																)
															)
													)
													->flatten(),
		ownedAccessConnection			<- impl.getConnectionsInstancesImg('accessConnection')
												->union(impl.getSubcomponentsInstances('thread')
													->collect(c| c.featureInstance
														->select (fi | fi.isOutputFeature())
														->collect(fi |
															fi.srcConnectionInstance
															->collect(cnxInst |
																thisModule.resolveTemp(Sequence{fi,cnxInst.connectionReference->first()}, 'accessConnection')
															)	
														)
													)
												)->flatten()
												->union(impl.getSubcomponentsInstances('thread')
													->collect(c| c.featureInstance
														->select (fi | fi.isInputFeature())
														->collect(fi |
															thisModule.resolveTemp(fi, 'accessConnection')	
														)
													)
												)->flatten()
											
	)
}

rule m_Processor_Instance {
	from
		c : AADLI!ComponentInstance (c.category = #processor)
	to
		sub : AADLBA!ProcessorSubcomponent
		(
			name <- c.name.debug('subcomponent created'),
			processorSubcomponentType <- c.subcomponent.subcomponentType,
			ownedPropertyAssociation  <- c.ownedPropertyAssociation->select(e | not (e.property.name.toLower() = 'scheduling_protocol'))
												->collectSelfPropertyAssociationImg()
												-> append(thisModule.CreatePropertyAssociation ('Scheduling_Protocol', 'DEPLOYMENT_PROPERTIES', listValue))
												
		),
		listValue : AADLBA!ListValue
		(
			ownedListElement <- Sequence{sched}
		),
		sched : AADLBA!NamedValue
		(
			namedValue <- el
		),
		el : AADLBA!EnumerationLiteral
		(
			name <- 'Posix_1003_Highest_Priority_First_Protocol'
		)
		
		
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(sub, c);
	}
}
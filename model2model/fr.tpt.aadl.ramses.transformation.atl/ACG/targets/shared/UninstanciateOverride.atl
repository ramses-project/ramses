--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLI=http:///AADL2/instance
-- @atlcompiler emftvm

module UninstanciateOverride;

create 
	OUT 			: AADLBA
from 
	IN 				: AADLI;


helper context AADLI!ComponentImplementation def: needsCopy(): Boolean =
	self.isInstanciated()
	or self.type.needsCopy()
;

helper context AADLI!ComponentType def: needsCopy(): Boolean =
	self.isInstanciated()
	or (self.oclIsKindOf(AADLI!SubprogramType) and self.ownedPrototype->isEmpty()
		and
		  (not self.ownedEventPort->isEmpty()
			or
		  not self.ownedEventDataPort->isEmpty())
		)
;
	
helper context AADLI!ComponentType def : isInstanciated() : Boolean =
	if self.oclIsKindOf(AADLI!SubprogramClassifier) then
		false
	else
		AADLI!ComponentInstance.allInstancesFrom('IN')->select(e|not e.subcomponent.oclIsUndefined())
			->exists(e| e.subcomponent.subcomponentType=self or if e.subcomponent.subcomponentType.oclIsKindOf(AADLI!ComponentImplementation) then e.subcomponent.subcomponentType.type=self else false endif)
	endif
;

helper context AADLI!ComponentImplementation def: isInstanciated() : Boolean =
	if self.oclIsKindOf(AADLI!SubprogramClassifier) then
		false
	else
		AADLI!ComponentInstance.allInstancesFrom('IN')->select(e|not e.subcomponent.oclIsUndefined())
			->exists(e| e.subcomponent.subcomponentType=self)
	endif
;


helper context AADLI!SystemType def : isInstanciated() : Boolean =
	AADLI!SystemImplementation.allInstances()
		->exists(e| e.type=self and e.isInstanciated())
;

helper context AADLI!SystemImplementation def: isInstanciated() : Boolean =
	AADLI!SystemInstance.allInstancesFrom('IN')->exists(e| e.componentImplementation=self)
;

helper context AADLI!FeatureInstance def: getOutputPortId(processInstance: AADLI!ComponentInstance): Integer = 
	processInstance.componentInstance->select(e|e.category=#thread)
	->collect(e|e.featureInstance)->flatten()
	->select(e|e.feature.oclIsKindOf(AADLI!Port) and e.direction=#out)
	->indexOf(self)-1
;


----- Remove systems hierarchy

helper def : createContainmentPathElement(neList: Sequence(AADLI!NamedElement)) : AADLBA!ContainmentPathElement =
	thisModule.createContainmentPathElementLazyRule
		(
			neList->select(e|e.oclIsKindOf(AADLI!ComponentInstance) and not (e.category=#system))
		)
;

--@extends m_Component_Implementation
rule m_System_Implementation {
  from
  	impl : AADLI!SystemImplementation
	(
		impl.isRoot()
	)
  to
  	implImg : AADLBA!SystemImplementation
	(
		name                              <- if(thisModule.theHOOK.getOutputPackageName().oclIsUndefined()) then
											 impl.name
											 else
											 thisModule.theHOOK.getOutputPackageName()+'.impl'
											 endif,
		ownedMemorySubcomponent           <- impl.getSubcomponentsInstances('memory')
													->union(
														impl.getSubcomponentsInstances('system')
														->collect(e| e.getSystemSubcomponent())
														->flatten()
														->collect(e|e.componentInstance)
														->flatten()
														->select(e|e.category=#memory)
													)
													->asSet()
													->excluding(OclUndefined),
		ownedProcessorSubcomponent        <- impl.getSubcomponentsInstances('processor')
													->union(
														impl.getSubcomponentsInstances('system')
														->collect(e| e.getSystemSubcomponent())
														->flatten()
														->collect(e|e.componentInstance)
														->flatten()
														->select(e|e.category=#processor)
													)
													->asSet()
													->excluding(OclUndefined),
		ownedDeviceSubcomponent           <- impl.getSubcomponentsInstances('device')
													->union(
														impl.getSubcomponentsInstances('system')
														->collect(e| e.getSystemSubcomponent())
														->flatten()
														->collect(e|e.componentInstance)
														->flatten()
														->select(e|e.category=#device)
													)
													->asSet()
													->excluding(OclUndefined),
		ownedVirtualProcessorSubcomponent <- impl.getSubcomponentsInstances('virtual processor')->excluding(OclUndefined),
		ownedProcessSubcomponent          <- impl.getSubcomponentsInstances('process')
													->excluding(OclUndefined),
		ownedSubprogramSubcomponent       <- impl.getSubcomponentsInstances('subprogram')->excluding(OclUndefined),
		ownedDataSubcomponent             <- impl.getSubcomponentsInstances('data')->excluding(OclUndefined),
		ownedBusSubcomponent             <- impl.getSubcomponentsInstances('bus')->excluding(OclUndefined)
	)
}

-------- End of code to remove systems hirarchy


-- @extends m_Component_Type
rule m_Process_Type {
 from
 	type : AADLI!ProcessType
 to 
 	typeImg : AADLBA!ProcessType
}

-- @extends m_Connection_Reference
rule m_AccessConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (
			cnxRef.eContainer().kind = #accessConnection
			and
			not (cnxRef.connection.accessCategory=#subprogram)
			)
	to
		cnxImg: AADLBA!AccessConnection
		(accessCategory <- cnxRef.connection.accessCategory)
}

rule m_SubprogramAccessConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (cnxRef.eContainer().kind = #accessConnection and cnxRef.connection.accessCategory=#subprogram)
}

rule m_ParameterConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (cnxRef.eContainer().kind = #parameterConnection)
}

rule m_FeatureGroupConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (cnxRef.eContainer().kind = #featureGroupConnection)
}

unique lazy rule collectComputeEntryPoint_rule
{
	from
		c: AADLI!ComponentInstance
	to
		pa: AADLBA!PropertyAssociation
		(
			property <- thisModule.getProperty('Compute_Entrypoint_Call_Sequence'),  
    		ownedValue <- Sequence{mpv}
		),
		mpv: AADLBA!ModalPropertyValue
		(
			ownedValue<-v
		),
		v: AADLBA!ReferenceValue
		(
			path <- cpe
		),
		cpe: AADLBA!ContainmentPathElement
		(
			namedElement <- thisModule.resolveMatchedSingleIfExists(c, 'callSequenceImg')
		)
	do
	{
		pa;
	}
}

helper def : collectInitializationEntryPoint(c: AADLI!ComponentInstance) : AADLBA!PropertyAssociation =
	OclUndefined
;

helper def : collectThreadVariables(c: AADLI!ComponentInstance): AADLBA!DataSubcomponent =
	if(c.isSporadicThread()) then
		thisModule.collectSporadicThreadVariables(c)
	else
		Sequence{}
	endif
	->union(
		thisModule.collectPeriodicDelayed_ThreadVariables(c)
	)
;

unique lazy rule createAccessConnectionFromBA
{
	from
		fi: AADLI!FeatureInstance,
		ba: AADLBA!BehaviorAnnex
	using
	{
		annexSubclause: AADLBA!AnnexSubclause = fi.getComponentInstance().subcomponent.classifier.ownedAnnexSubclause->any(e|e.name = 'behavior_specification');
	}
	to
		accessCnx: AADLBA!AccessConnection
		(
			name <- fi.name+'_BA_cnx_'+fi.eContainer().subcomponent.subcomponentType.ownedAnnexSubclause->indexOf(annexSubclause).toString(),
			source <- accessCnx_Source,
			destination <- accessCnx_Destination,
			accessCategory <- #data
		),
		accessCnx_Source: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature()
		),
		accessCnx_Destination: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.getFeatureImg()
		)
	do
	{
		accessCnx_Source.setContext(thisModule.resolveMatchedSingleIfExists(fi.eContainer(), 'callEntryPoint'));
		accessCnx;
	}
}

unique lazy rule createFreshnessIndicator
{
	from
		fi: AADLI!FeatureInstance
	to
		freshnessIndicator: AADLBA!DataSubcomponent
		(
			name <- fi.name+'_persistentFreshnessIndicator',
			dataSubcomponentType<-'Integer_16'.asClassifier('BASE_TYPES'),
			ownedPropertyAssociation <- Sequence{
				thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL', freshnessIndicator_Init)
			}
		),
		freshnessIndicator_Init: AADLBA!ListValue
		(
			ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression('0')}
		),
		freshnessIndicator_Connection: AADLBA!AccessConnection
		(
			name <- fi.name+'_to_persistentFreshnessIndicator',
			accessCategory <- #data,
			source <- freshnessIndicator_CnxSource,
			destination <- freshnessIndicator_CnxDestination
		),
		freshnessIndicator_CnxSource: AADLBA!ConnectedElement
		(
			connectionEnd <- freshnessIndicator
		),
		freshnessIndicator_CnxDestination: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.createFreshnessIndicatorAccess(fi)
		)
	do
	{
		thisModule.addImportedUnit(thisModule.public(), 'BASE_TYPES', 'Base_Types');
		freshnessIndicator;
	}
}

unique lazy rule createFreshnessIndicatorAccess
{
	from
		fi:AADLI!FeatureInstance
	to
		freshnessIndicator_Access: AADLBA!DataAccess
		(
			name<-fi.name+'_freshnessIndicator_access',
			dataFeatureClassifier<-'Integer_16'.asClassifier('BASE_TYPES'),
			kind <- #requires
		)
	do
	{
		freshnessIndicator_Access;
	}
}

unique lazy rule createPortCountSubcomponent
{
	from
		fi:AADLI!FeatureInstance
	to
		countVariable:AADLBA!DataSubcomponent
		(
			name<-fi.name+'_countValue',
			dataSubcomponentType<-'Integer_16'.asClassifier('BASE_TYPES'),
			ownedPropertyAssociation <- Sequence{thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL', count_Init)}
		),
		count_Init: AADLBA!ListValue
		(
			ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression('0')}
		)
	do
	{
		countVariable;
	}
}

helper context AADLI!FeatureInstance def: collectPortGlobalVariableImg() : Sequence(AADLBA!DataSubcomponent) =
	Sequence{thisModule.resolveMatchedSingleIfExists(self, 'globalVariable')}
;

helper context AADLI!ComponentInstance def: collectGlobalVariableImg()  : Sequence(AADLBA!DataSubcomponent) =
	Sequence{}
;

helper context AADLI!ComponentInstance def: retrieveErrorHandler(): Sequence(AADLBA!SubprogramSubcomponent) =
	Sequence{}
;

-- @extends m_Component_Instance
rule m_Process_Instance {
	from
		c : AADLI!ComponentInstance (c.category = #process)
	using
	{
 		impl : AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
	}
	to 
		sub : AADLBA!ProcessSubcomponent
		(
			processSubcomponentType <- implImg
		),
		implImg : AADLBA!ProcessImplementation (
 			name 							<- if c.subcomponent.processSubcomponentType.oclIsKindOf(AADLBA!ComponentType)  then
												c.subcomponent.processSubcomponentType.name+'.impl'
											else c.subcomponent.processSubcomponentType.name
											endif,
			ownedRealization 				<- thisModule.Realization(
											if c.subcomponent.processSubcomponentType.oclIsKindOf(AADLBA!ComponentType)  then c.processSubcomponentType.resolve()
											else c.subcomponent.processSubcomponentType.type.resolve()
											endif),
			ownedThreadGroupSubcomponent 	<- c.componentInstance->select(e|e.category=#threadgroup),
        	ownedThreadSubcomponent         <- c.componentInstance->select(e|e.category=#thread),
			ownedSubprogramSubcomponent 	<- c.componentInstance->select(e|e.category=#subprogram),
			ownedDataSubcomponent 			<- c.componentInstance->select(e|e.category=#data)
												->union	(
													c.componentInstance->select(e|e.category=#thread)
													->collect( e|
														thisModule.resolveMatchedTupleIfExists(Sequence{e,e.subcomponent.subcomponentType.getBA()},'currentState')
													)
													
												)
												-- intraprocess input thread port
												-- process output port
												-- process input port
												->union(impl.getSubcomponentsInstances('thread')
													->collect(c|
														c.collectGlobalVariableImg()
													)
												)
												->union(impl.getSubcomponentsInstances('thread')
													->collect(c| c.featureInstance
														->select(e| e.isThreadPort() and e.isInputFeature() and e.isIntraProcessFeatureInstance())
														->collect(fi |
																fi.collectPortGlobalVariableImg()
															)
														)
													)->union
													(
														impl.getSubcomponentsInstances('thread')
															->collect(c| c.eContainer().featureInstance
																->select(e| e.isProcessPort())
																->collect(fi |
																	fi.collectPortGlobalVariableImg()
																)
															)
													)->union
													(
														impl.getSubcomponentsInstances('thread')
                                                        ->collect(c|
                                                                thisModule.collectPeriodicDelayed_GlobalVariables(c)
                                                       )
													)
													->union
													(
														impl.getSubcomponentsInstances('thread')
                                                        ->collect(c|
															if(c.isSporadicThread()) then
																thisModule.collectSporadicGlobalVariables(c)
															else
																Sequence{}
															endif
														)
													)
													->union
													(
														impl.getSubcomponentsInstances('thread')
                                                        ->collect(c|
															if(c.isTimedThread()) then
																thisModule.collectTimedGlobalVariables(c)
															else
																Sequence{}
															endif
														)
													)
													->flatten()->excluding(OclUndefined),
		ownedAccessConnection			<- impl.getConnectionsInstancesImg('accessConnection')
												->union(impl.getSubcomponentsInstances('thread')
													->collect(c| c.featureInstance
														->select (fi | fi.isOutputFeature())
														->collect(fi |
															fi.srcConnectionInstance
															->collect(cnxInst |
																thisModule.resolveMatchedTupleIfExists(Sequence{fi,cnxInst.connectionReference->first().connection}, 'accessConnection')
															)->asSet()	
														)
													)
												)->flatten()
												->union(impl.getSubcomponentsInstances('thread')
													->collect(c| c.featureInstance
														->select (fi | fi.isOutputFeature())
														->collect(fi |
															fi.srcConnectionInstance
															->collect(cnxInst |
																thisModule.resolveMatchedTupleIfExists(Sequence{fi,cnxInst.connectionReference->first().connection}, 'barrierThreadAccessConnection')
															)->asSet()	
														)
													)
												)->flatten()
												->union(impl.getSubcomponentsInstances('thread')
													->collect(c| c.featureInstance
														->select (fi | fi.isInputFeature())
														->collect(fi |
															if(fi.getProcess().modeInstance->exists(mi| fi.connectedInMode(mi.mode))) then
																fi.getProcess().modeInstance->collect(mi | thisModule.resolveMatchedTupleIfExists(Sequence{fi, mi.mode}, 'accessConnection'))
															else
																thisModule.resolveMatchedSingleIfExists(fi, 'accessConnection')
															endif
														)->flatten()
													)
												)
                                                ->union(
                                                       impl.getSubcomponentsInstances('thread')
                                                           ->collect(c|
                                                                thisModule.collectPeriodicDelayed_GlobalVariablesConnections(c)
                                                       )
                                               )
											   ->union
												(
													impl.getSubcomponentsInstances('thread')
                                                           ->collect(c|
														if(c.isSporadicThread()) then
															thisModule.collectSporadicGlobalVariablesAccessConnections(c)
														else
															Sequence{}
														endif
													)
												)
												->union
												(
													impl.getSubcomponentsInstances('thread')
                                                           ->collect(c|
														if(c.isTimedThread()) then
															thisModule.collectTimedGlobalVariablesAccessConnections(c)
														else
															Sequence{}
														endif
													)
												)
												->union	(
													c.componentInstance->select(e|e.category=#thread)
													->collect( e|
														thisModule.resolveMatchedTupleIfExists(Sequence{e,e.subcomponent.subcomponentType.getBA()},'accessConnection_CURRENT_STATE_THREAD')
													)
												)
                                               ->flatten()->excluding(OclUndefined),
		ownedMode <- c.modeInstance
	)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(implImg, impl);
	}
}

rule m_Process_Implementation {
 from
 	impl : AADLI!ProcessImplementation
 to 
 	
}

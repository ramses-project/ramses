--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLI=http:///AADL2/instance
-- @atlcompiler emftvm

module SubprogramCallsCommonRefinementSteps;

create 
	OUT 				   : AADLBA
from 
	IN 					   : AADLI,
	BASE_TYPES			   : AADLBA,
	AADL_RUNTIME		   : AADLBA,
	DATA_MODEL			   : AADLBA,
	SCHEDULER_CONSTANTS	   : AADLBA,
	SCHEDULER_REALIZATIONS : AADLBA,
	SCHEDULER_RUNTIME	   : AADLBA;

abstract rule m_DataPort
{
	from
		fi: AADLI!FeatureInstance
        (
        	fi.isDataPort()
		)
}


helper def : Unique_Send_Output_Per_Thread : Boolean = false;

helper def: collectDataNextValueCalls(fi: AADLI!FeatureInstance, behavior:AADLI!SubprogramCallSequence): Sequence(AADLBA!SubprogramCall) =
	let modeInstanceList: Sequence(AADLI!ModeInstance) = AADLI!ModeInstance.allInstancesFrom('IN')->select(mi|fi.connectedInMode(mi.mode)) in
	if not modeInstanceList.isEmpty() then
		modeInstanceList->collect(modeInstance|
			thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior,modeInstance.mode} ,'ifActiveMode'))
	else
		Sequence{thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior} ,'call')}
	endif
;

helper def: collectEventDataNextValueCalls(fi: AADLI!FeatureInstance, behavior:AADLI!SubprogramCallSequence, paramCnx:AADLBA!ParameterConnection): Sequence(AADLBA!SubprogramCall) =
	Sequence{thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior, paramCnx} ,'call')}
;

helper def: collectDataPutValueCalls(fi: AADLI!FeatureInstance, behavior:AADLI!SubprogramCallSequence, cnxInst:AADLI!ConnectionInstance): Sequence(AADLBA!SubprogramCall) =
	Sequence{
		thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior, cnxInst.connectionReference->first().connection} ,'call')
	}
;

helper def: collectEventDataPutValueCalls(fi: AADLI!FeatureInstance, behavior:AADLI!SubprogramCallSequence, paramCnx:AADLBA!Connection, cnxInst:AADLI!ConnectionInstance): Sequence(AADLBA!SubprogramCall) =
	Sequence{
		thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior, paramCnx, cnxInst.connectionReference->first().connection} ,'call'),
		thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior, paramCnx, cnxInst.connectionReference->first().connection} ,'callSetEvent')
	}
;

helper def: collectReceiveInputsCalls(fi: AADLI!FeatureInstance, behavior:AADLI!SubprogramCallSequence) : Sequence(AADLBA!SubprogramCall) =
	Sequence{
		thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior} ,'callReceiveInputs')
	}
;

helper def: collectCommunicationsLocalVariables(c: AADLI!ComponentInstance, callSequences: Sequence(AADLI!SubprogramCallSequence)): Sequence(AADLBA!DataSubcomponent)=
	Sequence{}
;

helper def: collectThreadInitActions(c: AADLI!ComponentInstance): Sequence(AADLBA!BehaviorAction) =
	Sequence{}
;

helper def: collectComputeEntryPointTransitions(c: AADLI!ComponentInstance): Sequence(AADLBA!BehaviorTransition) =
	c.featureInstance->select(fi| not fi.getComputeEntryPoints().oclIsUndefined() )
	->collect
	( fi |
		fi.getComputeEntryPoints()->collect
			(
				cep | thisModule.resolveMatchedTupleIfExists(Sequence{fi, cep}, 'computeEntryPointTransition')
			)
	)
	->union(
			c.getComputeEntryPoints()->collect(cep | 
				-- if in mode
				-- thisModule.resolveMatchedTupleIfExists(Sequence{c, cep, mode}, 'computeEntryPointTransition'))
				-- else
				thisModule.resolveMatchedTupleIfExists(Sequence{c, cep}, 'computeEntryPointTransition'))
		)
	->flatten()->excluding(OclUndefined)
;


helper def: collectBAEntryPointTransitions(c: AADLI!ComponentInstance): Sequence(AADLBA!BehaviorTransition) =
	Sequence{thisModule.resolveMatchedTupleIfExists(Sequence{c, c.subcomponent.classifier.getBA()}, 'computeEntryPointTransition')}
;

helper def: collectBAEntryPointActionBlocks(c: AADLI!ComponentInstance): Sequence(AADLBA!BehaviorActionBlock) =
	Sequence{thisModule.resolveMatchedTupleIfExists(Sequence{c, c.subcomponent.classifier.getBA()}, 'computeEntryPointActionBlock')}
;

helper def: collectComputeEntryPointActionBlocks(c: AADLI!ComponentInstance): Sequence(AADLBA!BehaviorActionBlock) =
	c.featureInstance->select(fi| not fi.getComputeEntryPoints()->isEmpty() )
	->collect
	( fi |
		fi.getComputeEntryPoints()->collect
			(
				cep | thisModule.resolveMatchedTupleIfExists(Sequence{fi, cep}, 'computeEntryPointActionBlock')
			)
	)
	->union(
			c.getComputeEntryPoints()->collect(cep | thisModule.resolveMatchedTupleIfExists(Sequence{c, cep}, 'computeEntryPointActionBlock'))
		)
	-->append(thisModule.resolveMatchedSingleIfExists(c, 'whichPortActionBlock'))
	->flatten()
;

helper context AADLI!InstanceObject def : collectSelfPropertyAssociationImg() : Sequence(AADLBA!PropertyAssociation) =
	self.ownedPropertyAssociation->select(e | not e.property.name.equalsIgnoreCase('Compute_Entrypoint_Call_Sequence')
									)
									->select(e|e.isApplicableTo(self.resolve()))
									->collectSelfPropertyAssociationImg()
	->union(
		if self.oclIsTypeOf(AADLI!ComponentInstance) and self.category=#thread then
			Sequence{ thisModule.collectComputeEntryPoint_rule(self),
					  thisModule.collectInitializationEntryPoint(self)}->excluding(OclUndefined)
		else
			Sequence{}
		endif
	)
;

helper context AADLI!ConnectionReference def: needsCopy() : Boolean =
	if self.source.isThreadPort() and not self.destination.context.oclIsUndefined() then
		not self.destination.context.eContainer().isComputeEntryPointOf(self.source.eContainer())
	else 
		if(self.destination.isThreadPort() and not self.source.context.oclIsUndefined()) then
			not self.source.context.eContainer().isComputeEntryPointOf(self.destination.eContainer())
		else
			false
		endif
	endif
;

lazy rule createClassifierPropertyReference
{
	from
		component: AADLI!Classifier,
		pa: 	   AADLI!PropertyAssociation,
		sl:        AADLI!StringLiteral
    to
	   classifierPropertyReference: AADLBA!ClassifierPropertyReference
	   (
	   	 classifier <- component,
		 properties <- Sequence {enum_propertyNameHolder, ccpr_propertyNameHolder}
	   ),
	   enum_propertyNameHolder: AADLBA!PropertyNameHolder
	   (
	   	 property <- enum_PropertyAssociationHolder
	   ),
	   enum_PropertyAssociationHolder: AADLBA!PropertyAssociationHolder
	   (
	   	 element <- pa
	   ),
	   ccpr_propertyNameHolder: AADLBA!PropertyNameHolder
	   (
		 property <- ccpr_PropertyExpressionHolder
	   ),
	   ccpr_PropertyExpressionHolder: AADLBA!PropertyExpressionHolder
	   (
		 element <- sl
	   )
	do {classifierPropertyReference;}   
}

unique lazy rule createComponentBehaviorEnumerators
{
	from
	  c: AADLI!ComponentInstance
	to
	   p : AADLBA!PropertyAssociation (
			property <- 'Enumerators'.asProperty('DATA_MODEL'),
			ownedValue <- Sequence {mpv}
		),
		
		mpv : AADLBA!ModalPropertyValue (
			ownedValue <- thisModule.CreateListValueFromListOfString(Sequence{'default_behavior'}->union(c.featureInstance->select(fi|fi.isInputFeature())->collect(e|e.name)))
		)
	do { p; }
}

rule m_PortConnection_Reference
{
	from
		cnxRef: AADLI!ConnectionReference (cnxRef.eContainer().kind = #portConnection)
}


-- @extends m_Feature_Instance
rule m_DataPort_Instance
{
	from
		fi: AADLI!FeatureInstance 
		(
			fi.category=#dataPort
			and
			not (fi.eContainer().category=#thread)
			and
			not (fi.eContainer().category=#process)
		)
	to
		f: AADLBA!DataPort
		(
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier
		)
	do
	{
		thisModule.setDirection(f, fi.feature);
	}
}

-- @extends m_Feature_Instance
rule m_EventPort_Instance
{
	from
		fi: AADLI!FeatureInstance 
		(
			fi.category=#eventPort
			and
			not (fi.eContainer().category=#thread)
			and
			not (fi.eContainer().category=#process)
		)
	to
		f: AADLBA!EventPort
	do
	{
		thisModule.setDirection(f, fi.feature);
	}
}

-- @extends m_Feature_Instance
rule m_EventDataPort_Instance
{
	from
		fi: AADLI!FeatureInstance 
		(
			fi.category=#eventDataPort
			and
			not (fi.eContainer().category=#thread)
			and
			not (fi.eContainer().category=#process)
		)
	to
		f: AADLBA!EventDataPort
		(
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier
		)
	do
	{
		thisModule.setDirection(f, fi.feature);
	}
}

abstract rule m_Component_Implementation {
 from
    impl : AADLI!ComponentImplementation
	(impl.needsCopy())
 to
 	implImg : AADLBA!ComponentImplementation (
 		name             			<- impl.name,
		ownedComment     			<- impl.ownedComment,
		ownedAccessConnection  		<- impl.getConnectionsInstancesImg('accessConnection'),
		ownedParameterConnection 	<- impl.getConnectionsInstancesImg('parameterConnection'),
		ownedRealization 			<- thisModule.Realization(impl.type.resolve())
 	)
 do
 {
 	thisModule.addImportedUnitFromInputModel(thisModule.public(), impl);
 }
}

-- @extends m_create_Thread_BA
abstract rule m_Thread_Instance {
	from
		c : AADLI!ComponentInstance (
			c.category = #thread 
			and 
			c.subcomponent.subcomponentType.oclIsKindOf(AADLI!ComponentImplementation)
		)
	using
 	{
 		impl : AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
 	}
	to
		sub : AADLBA!ThreadSubcomponent,
		implImg : AADLBA!ThreadImplementation,
		typeImg : AADLBA!ThreadType	
}

-- @extends m_Thread_Instance
rule m_ThreadEntrypoint { 
  from	
	c: AADLI!ComponentInstance
	using
	{
		impl : AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
		callSequences: Sequence(AADLBA!SubprogramCallSequence) = if(not c.needsToMapBehaviorAnnex()) then 
																	impl.ownedSubprogramCallSequence->select(e|e.isComputeEntryPointOf(c)) 
																	else Sequence{} endif;
		property_association: AADLBA!PropertyAssociation = thisModule.createComponentBehaviorEnumerators(c);
																	
		inModes: Sequence(AADLI!ModeInstance) = c.inMode;
	}
	to
		sub : AADLBA!ThreadSubcomponent mapsTo c,
		entryPointImg: AADLBA!SubprogramType
		(
			name <- c.uniqueName()+'_entrypoint',
			ownedDataAccess <- 	c.featureInstance->collect(
									fi | 
											if(fi.feature.oclIsTypeOf(AADLI!DataAccess)) then
												Sequence{thisModule.resolveMatchedSingleIfExists(fi, 'f_entrypoint')}
											->union
											(
												callSequences->collect(behavior | 
													impl.ownedAccessConnection->select(accessCnx | accessCnx.isPartOfCallSequence(behavior)
														and (
																accessCnx.source.connectionEnd = fi.feature
																or
																accessCnx.destination.connectionEnd = fi.feature
															)
													)
													->collect
													(
														accessCnx| thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior,accessCnx}, 'dataAccess')
													)
												)
											)
											else
												if(fi.isInputFeature()) then
													fi.collectEntrypointFeature()
												else 
--													if(fi.isOutputFeature()) then
														fi.srcConnectionInstance->collect(cnxInst| 
															fi.collectEntrypointFeature(cnxInst.connectionReference->first().connection)
														)
														->union(fi.srcConnectionInstance->collect(cnxInst| thisModule.resolveMatchedTupleIfExists(Sequence{fi, cnxInst.connectionReference->first().connection}, 'barrierEntryPointAccess')))
--													else
--														if(fi.isOutputFeature() and fi.isEventOrEventDataPort()) then
--															
--														
--														else
--															OclUndefined
--														endif
--													endif
												endif
											endif
								)->flatten()
								->union
								(
									if(callSequences->isEmpty()) then
										c.componentInstance->select(e|e.category=#data and AADLBA!DataSubcomponentHolder.allInstances()->exists(f|f.element = e.subcomponent))
										->collect(access | thisModule.resolveMatchedTupleIfExists(Sequence{c,access}, 'dataAccess'))
									else
										Sequence{}
									endif
								)
								->append
								(
									thisModule.resolveMatchedTupleIfExists(Sequence{c,impl.getBA()},'currentStateAccess')
								)
								->union
								(
									c.featureInstance->select(fi| fi.feature.oclIsKindOf(AADLI!Port) and fi.isUsedInFresh())
									->collect
									(
										fi| thisModule.createFreshnessIndicatorAccess(fi)
									)
								)
								->union
								(
									callSequences->collect(behavior |
										thisModule.collectPeriodicDelayed_LocalVariablesAccesses(c, behavior)
									)
								)
								->union
								(
									if(c.isSporadicThread()) then
										thisModule.collectSporadicThreadVariablesAccesses(c)
									else
										Sequence{}
									endif	
								)
								->union
								(
									if(c.isTimedThread()) then
										thisModule.collectTimedThreadVariablesAccesses(c)
									else
										Sequence{}
									endif
								)
								->union
								(
									impl.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )
									->select(e|e.source.connectionEnd.oclIsKindOf(AADLI!DataAccess))
										->collect(e|
											callSequences->collect(behavior |
											thisModule.resolveMatchedTupleIfExists(Sequence{c, behavior, e.source.connectionEnd},'dataAccess'))
										)
								)
								->union
								(
									impl.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )
									->select(e|e.destination.connectionEnd.oclIsKindOf(AADLI!DataAccess))
										->collect(e|
											callSequences->collect(behavior |
											thisModule.resolveMatchedTupleIfExists(Sequence{c, behavior, e.destination.connectionEnd},'dataAccess'))
										)
								)
								->flatten()->excluding(OclUndefined)->asSet(),
								
			ownedParameter <- impl.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )
								->select(e|e.source.connectionEnd.oclIsKindOf(AADLI!DataSubcomponent))
								->collect(e|
									callSequences->collect(behavior |
										thisModule.resolveMatchedTupleIfExists(Sequence{c.componentInstance->any(f|f.subcomponent=e.source.connectionEnd), behavior, e},'featureImg'))
									)
								->union
								(
									impl.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )
									->select(e|e.destination.connectionEnd.oclIsKindOf(AADLI!DataSubcomponent))
									->collect(e|
										callSequences->collect(behavior |
											thisModule.resolveMatchedTupleIfExists(Sequence{c.componentInstance->any(f|f.subcomponent=e.destination.connectionEnd), behavior, e},'featureImg'))
										)
								)
								->flatten()->excluding(OclUndefined)
			
		),
		entryPointImplImg: AADLBA!SubprogramImplementation
		(
			name <- c.uniqueName()+'_entrypoint.impl',
			ownedRealization<-thisModule.Realization(entryPointImg),
			ownedAnnexSubclause <- Sequence{behaviorAnnex},
			ownedDataSubcomponent <- thisModule.collectCommunicationsLocalVariables(c,impl.ownedSubprogramCallSequence)
												->union
												(
													c.featureInstance->select(e|e.isDataOrEventDataPort())
													->collect
													(
														f| thisModule.resolveMatchedSingleIfExists(f, 'localVariable')
													)
												)
												->union
												(
													thisModule.collectPeriodicDelayed_LocalVariables
													(c,impl.ownedSubprogramCallSequence)
												)
												->append(returnData)
												->union
												(
													if c.isSporadicThread() then
														thisModule.collectSporadicThreadVariables(c)
													else
														Sequence{}
													endif
												)
												->union(
													if c.isTimedThread() then
														thisModule.collectTimedThreadVariables(c)
													else
														Sequence{}
													endif
												)
												->union(
													impl.ownedSubprogramCallSequence->collect(
														e | e.ownedSubprogramCall->collect(f| thisModule.createSubprogramCallContext(f, c))
													)
												)
												->union
												(
													c.featureInstance->select(fi| fi.feature.oclIsKindOf(AADLI!Port) and fi.isUsedInCount())
													->collect
													(
														fi| thisModule.createPortCountSubcomponent(fi)
													)
												)
												->append(
													if c.needsModeVariable() then
														thisModule.resolveMatchedSingleIfExists(c, 'currentModeDataSubcomponent')
													else
														OclUndefined
													endif
												)
												->flatten()->excluding(OclUndefined)
		),
		returnData: AADLBA!DataSubcomponent
		(
			name <- c.uniqueName()+'_runtime_call_ret',
			dataSubcomponentType <- thisModule.getRuntimeReturnType()
		),
		callEntryPoint: AADLBA!SubprogramCall
		(
			name<-thisModule.callPrefix().concat('_entrypoint'), -- callEntryPoint in thread Implementation
			calledSubprogram<-entryPointImplImg
		),
		callSequenceImg: AADLBA!SubprogramCallSequence 
		(
			name <- 'main_call',
			ownedSubprogramCall <- Sequence{callEntryPoint}
		),
		
		
		modeCurrentValueAccess: AADLBA!DataAccess
		(
			kind <- #requires,
			name <- 'currentModeAccess',
			dataFeatureClassifier <- thisModule.getModeDataClassifier(c.getProcess())
		),
		
		behaviorAnnexForThread: AADLBA!BehaviorAnnex (
			name <- 'behavior_specification',
			states <- Sequence{mainState},
			transitions <- Sequence{dispatchTransitionForThread},
			actions		<- Sequence{dispatch_actionBlockForThread}
		),
		mainState: AADLBA!BehaviorState (
			initial <- true,
			final <- true,
			complete <- true,
			name <- 'main_state'
		),
		dispatchTransitionForThread: AADLBA!BehaviorTransition (
			name <- 'dispatch_transition',
			condition <- dispatchConditionForThread,	
			destinationState <- mainState,
			sourceState <- mainState,
			actionBlock <- dispatch_actionBlockForThread
		),
		dispatchConditionForThread: AADLBA!DispatchCondition,
		dispatch_actionBlockForThread: AADLBA!BehaviorActionBlock (
			content <- dispatch_target_actionsForThread
		),
		dispatch_target_actionsForThread: AADLBA!BehaviorActionSequence (
			actions <- 	if(inModes->isEmpty()) then
							Sequence{thisModule.createUniqueCallAction(c)}
						else
							Sequence{thisModule.createModeAction(c, inModes, inModes->at(1))}
						endif
		),
		
		
		behaviorAnnex: AADLBA!BehaviorAnnex
		(
			name        <- 'behavior_specification',
			states      <- Sequence{initState,waitDispatchState,execState,finalState},
			transitions <- (if(c.needsToMapBehaviorAnnex()) then
								thisModule.collectBAEntryPointTransitions(c)
							else
								thisModule.collectComputeEntryPointTransitions(c)
							endif
							)->union(Sequence{whichPortTransition,dispatchTransition})
							->flatten(),
			actions		<- Sequence{dispatch_actionBlock}->union(
										if(c.needsToMapBehaviorAnnex()) then
											thisModule.collectBAEntryPointActionBlocks(c)
										else
											thisModule.collectComputeEntryPointActionBlocks(c)
										endif
										->append(whichPortActionBlock)
									),
			variables   <- if(not c.subcomponent.classifier.getBA().oclIsUndefined()) then
								c.subcomponent.classifier.getBA().variables->collect(e|e.resolve(c))
							else
								Sequence{}
							endif
							->union(
								thisModule.collectBehaviorVariable(c)
							)
							->flatten()
							->append(activatedPort)
		),
		activatedPort: AADLBA!BehaviorVariable
		(
			name <- 'whichPortActivated',
			dataClassifier <- whichPortActivatedDataDlassifier
		),
		whichPortActivatedDataDlassifier: AADLBA!DataType
		(
			name <- c.uniqueName()+'_behaviorIdentifier_enum',
			ownedPropertyAssociation <- Sequence {
												
												thisModule.CreatePropertyAssociation
												(
												 	'Data_Representation',
													'DATA_MODEL',
													'Enum'.asEnumeration('DATA_MODEL').asNamedValue()
												),
												property_association,
												thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL',lv)
									}
		),
		lv: AADLBA!ListValue
		(
			ownedListElement <- Sequence{
				thisModule.CreateStringLiteralPropertyExpression(
				c.targetPackagePrefix().getProgrammationLanguageIdentifier()+
				c.uniqueName().getProgrammationLanguageIdentifier()+
				'_behaviorIdentifier_enum'.concat('_').concat('default_behavior')
				)
			}
		),
	    portIDEnumLiteral: AADLBA!StringLiteral
        (
          value <- 'default_behavior'
        ),
		execState: AADLBA!BehaviorState
		(
			initial  <- false,
			final    <- false,
			complete <- false,
			name <- 'BA_entrypoint_exec_state'
		),
		whichPortTransition: AADLBA!BehaviorTransition
		(
			name <- 'which_behavior_default_mode',
			sourceState <- initState,
			destinationState <- execState,
			actionBlock <- whichPortActionBlock
		),
		whichPortActionBlock: AADLBA!BehaviorActionBlock
		(content<-whichPortActions),
		whichPortActions: AADLBA!BehaviorActionSequence
		( 
			actions <- Sequence{updateDefaultBehaviorAction}
						->union(thisModule.collectThreadInitActions(c))
		),
		
		-- create action to activate default behavior
		
		updateDefaultBehaviorAction: AADLBA!AssignmentAction
		(
			target <- updateDefaultBehaviorVariableHolder,
			valueExpression <- updateDefaultBehaviorValueExpression
		),
		updateDefaultBehaviorVariableHolder: AADLBA!BehaviorVariableHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(c, 'activatedPort')
		),
		updateDefaultBehaviorValueExpression: AADLBA!ValueExpression
		(
			relations <- Sequence{updateDefaultBehaviorRelation}
		),
		updateDefaultBehaviorRelation: AADLBA!Relation
		(
			relationalOperator<-#None,
			firstExpression<-updateDefaultBehaviorExpression
		),
		updateDefaultBehaviorExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{updateDefaultBehaviorTerm}
		),
		updateDefaultBehaviorTerm: AADLBA!Term
		(
			factors <- Sequence{updateDefaultBehaviorFactor}
		),
		updateDefaultBehaviorFactor: AADLBA!Factor
		(
			firstValue <- thisModule.createClassifierPropertyReference
			                         (
			                         	whichPortActivatedDataDlassifier,
										property_association,
										portIDEnumLiteral
			                         )
		),
		initState: AADLBA!BehaviorState
		(
			initial  <- true,
			final    <- false,
			complete <- false,
			name     <- 'BA_entrypoint_init_state'
		),
		waitDispatchState: AADLBA!BehaviorState
		(
			initial  <- false,
			final    <- false,
			complete <- false,
			name     <- 'BA_entrypoint_wait_dispatch_state'
		),
		finalState: AADLBA!BehaviorState
		(
			initial  <- false,
			final    <- true,
			complete <- false,
			name     <- 'BA_entrypoint_final_state'
		),
		dispatchTransition: AADLBA!BehaviorTransition
		(
			name <- 'dispatch_transition',			
			destinationState  <- execState,
			sourceState       <- waitDispatchState,
			actionBlock <- dispatch_actionBlock
		),
		dispatch_actionBlock: AADLBA!BehaviorActionBlock
		(content<-dispatch_target_actions),
		dispatch_target_actions: AADLBA!BehaviorActionSequence
		( 
			actions <- c.collectDispatchActions()
		)
	do
	{
		thisModule.addImportedUnit(thisModule.public(), 'DATA_MODEL', 'Data_Model');
	}
}

rule ThreadAccessConnectionToMode
{
	from
		ci: AADLI!ComponentInstance,
		mi: AADLI!ModeInstance
		(
			ci.category = #thread
			and
			ci.inMode->includes(mi)
		)
	to
		targetModeAccessConnection: AADLBA!AccessConnection
		(
			name <- mi.name+'_'+ci.name+'_modeAccessConnection',
			source<-modeSubcomponentCE,
			accessCategory<-#data,
			destination<-modeAccessCE
		),
		modeSubcomponentCE: AADLBA!ConnectedElement
		(
			connectionEnd <- ci.getProcess().componentInstance->any(e | e.name = 'targetModeValue')
		),
		modeAccessCE: AADLBA!ConnectedElement
		(
			connectionEnd<-thisModule.resolveTemp(ci, 'modeCurrentValueAccess'),
			context <- ci
		)
}

rule createUniqueCallAction(c: AADLI!ComponentInstance)
{
	to
		ifActiveInMode: AADLBA!IfStatement (
			logicalValueExpression <- checkForActiveModeExpression,
			behaviorActions <- callEntryPointActionSequence
		),
		checkForActiveModeExpression: AADLBA!ValueExpression (
			relations <- Sequence{thisModule.createTrueRelation()}
		),
		callEntryPointActionSequence: AADLBA!BehaviorActionSequence (
			actions <- Sequence{callEntryPointAction}
		),
		callEntryPointAction: AADLBA!SubprogramCallAction
		(
			subprogram <- callEntryPointHolder,
			parameterLabels <- c.featureInstance
								->select(e | 	not (e.category = #subprogramAccess) and
												not (e.category = #subprogramGroupAccess) and
												not (e.category = #busAccess) and
												not (e.category = #abstractFeature)
										)
								->collect(e | 
									if(e.isInputFeature() or e.category=#dataAccess) then 
										thisModule.createFeatureHolder(e.getFeatureImg())
									else
										e.srcConnectionInstance->collect(ci|
											thisModule.createFeatureHolder(
												e.retreiveEntrypointFeature(ci.connectionReference->at(1).connection)
											)
										)
									endif
								)->append(
									let da:AADLBA!DataAccess = thisModule.resolveMatchedTupleIfExists(Sequence{c, c.subcomponent.classifier.getBA()}, 'currentStateAccessThread') in
									if(da.oclIsUndefined()) then
										OclUndefined
									else
										thisModule.createFeatureHolder(da)
									endif
								)
								->union( c.featureInstance->select(fi|fi.isEventPort() or fi.isEventDataPort() and fi.isOutputFeature())
										->collect(fi|
												fi.srcConnectionInstance->collect( cnxInst |
													let da:AADLBA!DataAccess = thisModule.resolveMatchedTupleIfExists(Sequence{fi,cnxInst.connectionReference->first().connection}, 'barrierEntryPointAccess') in
													if(da.oclIsUndefined()) then
														OclUndefined
													else
														thisModule.createFeatureHolder(da)
													endif
												)
										)
								)
								->append(
									let da:AADLBA!DataAccess = thisModule.resolveMatchedSingleIfExists(c, 'EVENT_ID_LOCAL_ACCESS') in
									if(da.oclIsUndefined()) then
										OclUndefined
									else
										thisModule.createFeatureHolder(da)
									endif
								)
								->flatten()->excluding(OclUndefined)
		),
		callEntryPointHolder: AADLBA!CalledSubprogramHolder
		(
			element <- thisModule.resolveTemp(c,'entryPointImplImg')
		)
		
	do
	{
		ifActiveInMode;
	}
}

lazy rule createNotInModeAction
{
	from 
		c: AADLI!ComponentInstance
	to
		notInModeAction: AADLBA!ElseStatement (
			behaviorActions <- callNotInModeActionSequence
		),
		callNotInModeActionSequence: AADLBA!BehaviorActionSequence (
			actions <- Sequence{thisModule.createNotInModeCall(c)}
		)
	do
	{
		notInModeAction;
	}
}

lazy rule createNotInModeCall
{
	from 
		c: AADLI!ComponentInstance
}

lazy rule createModeAction
{
	from 
		c: AADLI!ComponentInstance,
		inModes: Sequence(AADLI!ModeInstance),
		mode: AADLI!ModeInstance
	using
	{
		remainingModes: Sequence(AADLI!ModeInstance) = 
			inModes->excluding(mode);
	}
	to
		ifActiveInMode: AADLBA!IfStatement (
			logicalValueExpression <- checkForActiveModeExpression,
			behaviorActions <- callEntryPointActionSequence,
			elif <- (c.inMode->first() <> mode) ,
			elseStatement <- if(remainingModes.isEmpty()) then
								thisModule.createNotInModeAction(c)
							else
								thisModule.createModeAction(
									c, remainingModes, remainingModes->first()
								)
							endif
		),
		checkForActiveModeExpression: AADLBA!ValueExpression (
			relations <- Sequence{thisModule.createModeTestRelation(c, mode)}
		),
		
		callEntryPointActionSequence: AADLBA!BehaviorActionSequence (
			actions <- Sequence{callEntryPointAction}
		),
		callEntryPointAction: AADLBA!SubprogramCallAction
		(
			subprogram <- callEntryPointHolder,
			parameterLabels <- c.featureInstance
								->select(e | 	not (e.category = #subprogramAccess) and
												not (e.category = #subprogramGroupAccess) and
												not (e.category = #busAccess) and
												not (e.category = #abstractFeature)
										)
								->collect(e | 
									if(e.isInputFeature() or e.category=#dataAccess) then 
										thisModule.createFeatureInHolder(e, mode)
									else
										e.srcConnectionInstance->collect(ci|
											thisModule.createFeatureOutHolder(e, ci, mode)
										)
									endif
								)->append(
									let da:AADLBA!DataAccess = thisModule.resolveMatchedTupleIfExists(Sequence{c, c.subcomponent.classifier.getBA()}, 'currentStateAccessThread') in
									if(da.oclIsUndefined()) then
										OclUndefined
									else
										thisModule.createFeatureHolder(da)
									endif
								)
								->flatten()->excluding(OclUndefined)
		),
		callEntryPointHolder: AADLBA!CalledSubprogramHolder
		(
			element <- thisModule.resolveTemp(c,'entryPointImplImg')
		)
	do
	{
		ifActiveInMode;
	}
}

helper def: createFeatureInHolder(fi: AADLI!FeatureInstance, mi: AADLI!ModeInstance) : AADLBA!DataAccessHolder =
	if(fi.connectedInMode(mi.mode)) then
		thisModule.createFeatureHolder(fi.getFeatureImg(mi))
	else
		thisModule.createFeatureHolder(fi.getFeatureImg())
	endif
;

helper def: createFeatureOutHolder(fi: AADLI!FeatureInstance, ci: AADLI!ConnectionInstance, mi: AADLI!ModeInstance): Sequence(AADLBA!DataAccessHolder) = 
	if(ci.connectionReference->at(1).connection.inModeOrTransition->includes(mi.mode)) then
		thisModule.createFeatureHolder(
			fi.retreiveEntrypointFeature(ci.connectionReference->at(1).connection, mi.mode)
		)
	else
		thisModule.createFeatureHolder(
			fi.retreiveEntrypointFeature(ci.connectionReference->at(1).connection)
		)
	endif
;

rule createFeatureHolder(da: AADLI!DataAccess)
{
	to
		h: AADLBA!DataAccessHolder
		(
			element <- da
		)
	do
	{
		h;
	}
}

rule createTrueRelation()
{
	to
		rel: AADLBA!Relation
		(
			relationalOperator<-#None,
			firstExpression<-expr
		),
		expr: AADLBA!SimpleExpression
		(
			terms <- Sequence{term}
		),
		term: AADLBA!Term
		(
			factors <- Sequence{fact}
		),
		fact: AADLBA!Factor
		(
			firstValue <- babTrue
		),
		babTrue: AADLBA!BehaviorBooleanLiteral
		(
			value <- true
		)
	do
	{
		rel;
	}
}

lazy rule createModeTestRelation
{
	from
		c: AADLI!ComponentInstance,
		mi: AADLI!ModeInstance
	to
		rel: AADLBA!Relation
		(
			relationalOperator<-#Equal,
			firstExpression<-modeCurrentValueExpression,
			secondExpression<-modeConstantValueExpression
		),
		
		modeCurrentValueExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{modeCurrentValueTerm}
		),
		modeCurrentValueTerm: AADLBA!Term
		(
			factors <- Sequence{modeCurrentValueFactor}
		),
		modeCurrentValueFactor: AADLBA!Factor
		(
			firstValue <- modeCurrentValueHolder
		),
		modeCurrentValueHolder: AADLBA!DataAccessHolder
		(
			element <- thisModule.resolveTemp(c, 'modeCurrentValueAccess')
		),
		
		
		modeConstantValueExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{modeConstantValueTerm}
		),
		modeConstantValueTerm: AADLBA!Term
		(
			factors <- Sequence{modeConstantValueFactor}
		),
		modeConstantValueFactor: AADLBA!Factor
		(
			firstValue <- thisModule.bindDatatypeEnumStringliteral
							(
								thisModule.getModeDataClassifier(c.getProcess()),
								mi.name
							)
		)
	do
	{
		rel;
	}
}


helper def: getModeDataClassifier(c: AADLI!ComponentInstance) : AADLBA!DataClassifier = 
	AADLBA!DataType.allInstances (c.subcomponent.classifier.eContainer())
								->any(e|e.name = c.name + '_modeDataClassifier')
;

helper context AADLI!ComponentInstance def: collectDispatchActions():Sequence(AADLBA!BehaviorAction) = 
	if(self.isSporadicThread()) then 
		thisModule.collectSporadicBehaviorActions(self) 
	else 
		Sequence{thisModule.resolveMatchedSingleIfExists(self,'waitDispatchCall'),
		thisModule.resolveMatchedSingleIfExists(self,'resetEventCall')
	}
	endif
		->union(thisModule.collectTransitionChoiceActions(self))->excluding(OclUndefined)
;
	
unique lazy rule createSubprogramCallContext
{
	from
		sc: AADLI!SubprogramCall,
		c: AADLI!ComponentInstance
		(
			sc.getSubprogramClassifier().needsContext()
		)
	using
	{
		spgClassifier: AADLI!SubprogramClassifier = sc.getSubprogramClassifier();
		initValuePE: AADLBA!PropertyExpression = thisModule.CreateStringLiteralPropertyExpression(sc.getContextInitValue(c));
	}
	to
		callContext: AADLBA!DataSubcomponent
		(
			name <- sc.name+'_context',
			ownedPropertyAssociation <- Sequence {thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL',lv)}
			
		),
		lv: AADLBA!ListValue
		(
			ownedListElement <- Sequence{initValuePE}
		)
	do
	{	
		callContext.dataSubcomponentType <- thisModule.resolveTemp(spgClassifier.getType(), 'ctxt');
		callContext;
	}
}

helper context AADLI!SubprogramCall def: getContextInitValue(c: AADLI!ComponentInstance) : String =
	let impl: AADLI!ThreadImplementation = c.subcomponent.classifier in
	let subT : AADLI!SubprogramType = self.getSubprogramClassifier().getType() in
	let subFeatureSequence : Sequence(AADLI!Feature) = 
		subT.ownedEventPort
				->union(subT.ownedEventDataPort)
				->union(subT.ownedParameter)
				->union(subT.ownedDataAccess)
	in
	let featureConnectionSequence : Sequence(AADLI!Connection) = 
		subFeatureSequence->
		collect ( e | impl.ownedConnection
			->select( f | 
			(f.source.context = self and f.source.connectionEnd = e )  or 
			(f.destination.context = self and f.destination.connectionEnd = e)
			)
		)->flatten() in
		
	let featureSequence : Sequence(AADLI!Feature) = featureConnectionSequence -> collect ( c | 
			if (c.source.context = self) then 
					c.destination.connectionEnd
				else if (c.destination.context = self) then
					c.source.connectionEnd
				else 
					OclUndefined
				endif endif	
		)->flatten () in
		thisModule.concatStrings(featureSequence -> collect ( e | e.getFeatureInitValue(self,c))->flatten()->excluding(OclUndefined))
		;

helper context AADLI!EventPort def : getFeatureInitValue (subCall : AADLI!SubprogramCall, c: AADLI!ComponentInstance) : String = 
	c.featureInstance->any(f|f.feature=self).getOutputPortId(c.getProcess()).toString()
	;
helper context AADLI!EventDataPort def : getFeatureInitValue (subCall : AADLI!SubprogramCall, c: AADLI!ComponentInstance) : String = 
	c.featureInstance->any(f|f.feature=self).getOutputPortId(c.getProcess()).toString()
	;
helper context AADLI!DataPort def : getFeatureInitValue (subCall : AADLI!SubprogramCall, c: AADLI!ComponentInstance) : String =
	if(self.direction.getName() = 'in') then
		self.name
	else
		c.featureInstance->any(f|f.feature=self).getOutputPortId(c.getProcess()).toString()
	endif
	;

helper context AADLI!DataAccess def : getFeatureInitValue (subCall : AADLI!SubprogramCall, c: AADLI!ComponentInstance) : String = 
	let impl: AADLI!ThreadImplementation = c.subcomponent.classifier in
	let accessCnxs : Sequence(AADLI!AccessConnection) = impl.ownedAccessConnection->select( c | 
			c.source.connectionEnd = self or c.destination.connectionEnd = self
			)->flatten() in
	thisModule.resolveMatchedTupleIfExists(Sequence{c, subCall.eContainer(),accessCnxs->first()}, 'dataAccess').name
	;
helper context AADLI!Parameter def : getFeatureInitValue (subCall : AADLI!SubprogramCall, c: AADLI!ComponentInstance) : String =
	let var : AADLBA!DataSubcomponent = thisModule.resolveMatchedTupleIfExists(Sequence{c,subCall.eContainer(),self}, 'paramCnxVariable') in
	let subI : AADLBA!SubprogramImplementation = thisModule.resolveMatchedSingleIfExists(c,'entryPointImplImg')in 
	'& '+subI.getProgrammationLanguageIdentifier()+'_'+var.name
	;	
helper context AADLI!DataSubcomponent def : getFeatureInitValue (subCall : AADLI!SubprogramCall,  c: AADLI!ComponentInstance) : String = 
	let cnx : AADLI!Connection = c.subcomponent.classifier.ownedConnection->select( c | 
			c.source.connectionEnd = self or c.destination.connectionEnd = self
			)->flatten()->excluding(OclUndefined)->first() in	 
	if (cnx.oclIsTypeOf(AADLI!AccessConnection)) then
	let d : OclAny = thisModule.resolveMatchedTupleIfExists(Sequence{c, subCall.eContainer(),cnx}, 'accessConnection') in
		if (d.destination.connectionEnd.oclIsTypeOf(AADLBA!DataSubcomponent)) then
		d.source.connectionEnd.name
		else 
		d.destination.connectionEnd.name
		endif
	else if	(cnx.oclIsTypeOf(AADLI!ParameterConnection)) then
	let di : AADLI!ComponentInstance = c.componentInstance->any(e | e.subcomponent.subcomponentType = self or e.subcomponent = self) in
	let d : OclAny = thisModule.resolveMatchedTupleIfExists(Sequence{di, subCall.eContainer(),cnx}, 'parameterConnection') in
		if (d.source.connectionEnd.oclIsTypeOf(AADLBA!SubcomponentType)) then
		d.destination.connectionEnd.name
		else
		d.source.connectionEnd.name
		endif	
	else 
		OclUndefined
	endif endif
	;
helper context AADLBA!ConnectedElement def : getContextName() : String = 
	if (self.context.oclIsUndefined()) then '' else self.context.name endif;
			
helper context OclAny def : getFeatureInitValue (subCall : AADLI!SubprogramCall,  c: AADLI!ComponentInstance) : String = 
	OclUndefined
	;	


unique lazy rule createReceiveInputCall
{
	from
		fi:AADLI!FeatureInstance
}

unique lazy rule collectTransitionChoiceActions
{
	from
		c: AADLI!ComponentInstance
	using
	{
		orderedPorts : Sequence(AADLI!FeatureInstance) = thisModule.theHOOK.getFeaturesOrderedByCriticality(c);
		checkforMessageAction: AADLBA!IfStatement = OclUndefined;
		results : Sequence(AADLI!BehaviorActions) = Sequence{};
	}
	do
	{
		if(not orderedPorts->select(port | c.subcomponent.classifier.ownedSubprogramCallSequence->exists(b | b.isComputeEntryPointOf(port) ) )->isEmpty()) 
		{
			for(port in orderedPorts->select(port | c.subcomponent.classifier.ownedSubprogramCallSequence->exists(b | b.isComputeEntryPointOf(port))))
			{
				for(b in c.subcomponent.classifier.ownedSubprogramCallSequence->select(b | b.isComputeEntryPointOf(port)))
				{
					checkforMessageAction <- thisModule.resolveMatchedTupleIfExists(Sequence{port, b},'checkforMessageAction');
					if(not orderedPorts->first().equals(port))
						checkforMessageAction.elif<-true;
					results<-results.including(thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'getCountAction'));
					results<-results.including(thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'count_assignement'));
					results<-results.including(checkforMessageAction);
					if(orderedPorts->last().equals(port))
						checkforMessageAction.elseStatement<-thisModule.createDefaultAssignement(c);
				}
			}
		}
		results;
	}
}


rule createDefaultAssignement(c:AADLI!ComponentInstance)
{
	to
		seq: AADLBA!BehaviorActionSequence
		(
			actions<-Sequence{updateDefaultBehaviorAction}
		),
		updateDefaultBehaviorAction: AADLBA!AssignmentAction
		(
			target <- updateDefaultBehaviorVariableHolder,
			valueExpression <- updateDefaultBehaviorValueExpression
		),
		updateDefaultBehaviorVariableHolder: AADLBA!BehaviorVariableHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(c, 'activatedPort')
		),
		updateDefaultBehaviorValueExpression: AADLBA!ValueExpression
		(
			relations <- Sequence{updateDefaultBehaviorRelation}
		),
		updateDefaultBehaviorRelation: AADLBA!Relation
		(
			relationalOperator<-#None,
			firstExpression<-updateDefaultBehaviorExpression
		),
		updateDefaultBehaviorExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{updateDefaultBehaviorTerm}
		),
		updateDefaultBehaviorTerm: AADLBA!Term
		(
			factors <- Sequence{updateDefaultBehaviorFactor}
		),
		updateDefaultBehaviorFactor: AADLBA!Factor
		(
			firstValue <- thisModule.createClassifierPropertyReference
			                         (
			                         	thisModule.resolveMatchedSingleIfExists(c, 'whichPortActivatedDataDlassifier'),
										thisModule.createComponentBehaviorEnumerators(c),
										thisModule.resolveMatchedSingleIfExists(c, 'portIDEnumLiteral')
			                         )
		),
		res: AADLBA!ElseStatement
		(
			behaviorActions <- seq
		)
	do
	{
		res;
	}
}

--helper def: collectTransitionChoiceActions(c: AADLI!ComponentInstance) : Sequence(AADLBA!BehaviorActions)=
--	let orderedPorts : Sequence(AADLI!FeatureInstance) = thisModule.theHOOK.getFeaturesOrderedByCriticality(c) in
--	if(orderedPorts->select(port | c.subcomponent.classifier.ownedSubprogramCallSequence->exists(b | b.isComputeEntryPointOf(port) ) )->isEmpty()) then
--		Sequence{thisModule.resolveMatchedSingleIfExists(c, 'updateDefaultBehaviorAction')}
--	else
--		orderedPorts->select(port | c.subcomponent.classifier.ownedSubprogramCallSequence->exists(b | b.isComputeEntryPointOf(port)))
--				->collect(port | 
--					c.subcomponent.classifier.ownedSubprogramCallSequence->select(b | b.isComputeEntryPointOf(port))
--					->collect(
--						b|
--							Sequence{
--								thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'getCountAction'),
--								thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'count_assignement'),
--								thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'checkforMessageAction')
--							}
--					)
--				)
--				->flatten()
--	endif
--;

helper def: collectBehaviorVariable(c: AADLI!ComponentInstance): Sequence(AADLBA!BehaviorVariable) =
	let orderedPorts : Sequence(AADLI!FeatureInstance) = thisModule.theHOOK.getFeaturesOrderedByCriticality(c) in
	orderedPorts->select(port | c.subcomponent.classifier.ownedSubprogramCallSequence->exists(b | b.isComputeEntryPointOf(port)))
				->collect(port | 
					c.subcomponent.classifier.ownedSubprogramCallSequence->select(b | b.isComputeEntryPointOf(port))
					->collect(
						b|
							Sequence{
								thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'count_variable'),
								thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'status_variable')
							}
					)
				)
				->flatten()
;
	
abstract rule m_ThreadBehavior
{
	from
		c: AADLI!ComponentInstance
		(
			c.category=#thread 
		)
	using
	{
		impl : AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
	}
	to
		computeEntryPointTransition: AADLBA!BehaviorTransition
		(
			sourceState <- thisModule.resolveMatchedSingleIfExists(c, 'execState'),
			destinationState <- thisModule.resolveMatchedSingleIfExists(c, 'waitDispatchState'), --- TODO: add 'if(c.modeInstance->isEmpty()) ... else ... endif
			actionBlock <- computeEntryPointActionBlock,
			condition <- thisModule.createComputeEntryPointConditionForComponent(c),
			priority <- 0.longValue()
		),
		computeEntryPointActionBlock: AADLBA!BehaviorActionBlock
		(content<-computeEntryPointActions),
		computeEntryPointActions: AADLBA!BehaviorActionSequence
}

lazy abstract rule createComputeEntryPointCondition
{
	from
		object: AADLI!InstanceObject
	to
		computeEntryPointCondition: AADLBA!ValueExpression
		(
			relations <- Sequence{comparisonRelation}
		),
		comparisonRelation: AADLBA!Relation
		(
			relationalOperator<-#Equal,
			firstExpression<-behaviorIdentifiverValueExpression,
			secondExpression<-portIDExpression
		),
		behaviorIdentifiverValueExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{behaviorIdentifiverValueTerm}
		),
		behaviorIdentifiverValueTerm: AADLBA!Term
		(
			factors <- Sequence{behaviorIdentifiverValueFactor}
		),
		behaviorIdentifiverValueFactor: AADLBA!Factor
		(
			firstValue <- behaviorIdentifiverValueHolder
		),
		behaviorIdentifiverValueHolder: AADLBA!BehaviorVariableHolder,
		
		portIDExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{portIDTerm}
		),
		portIDTerm: AADLBA!Term
		(
			factors <- Sequence{portIDFactor}
		),
		portIDFactor: AADLBA!Factor
		
	do
	{
		computeEntryPointCondition;
	}
}

-- @extends createComputeEntryPointCondition
unique lazy rule createComputeEntryPointConditionForPort
{
	from
		object: AADLI!FeatureInstance
	to
		computeEntryPointCondition: AADLBA!ValueExpression,
	    portIDEnumLiteral: AADLBA!StringLiteral
        (
          value <- object.name
        ),
		behaviorIdentifiverValueHolder: AADLBA!BehaviorVariableHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(object.getComponentInstance(), 'activatedPort')
		),
		portIDFactor: AADLBA!Factor
		(
			firstValue <- thisModule.createClassifierPropertyReference
		                       (
		                       		thisModule.resolveMatchedSingleIfExists(object.getComponentInstance(), 'whichPortActivatedDataDlassifier'),
									thisModule.createComponentBehaviorEnumerators(object.getComponentInstance()),
									portIDEnumLiteral
		                       )
		)
	do
	{
		computeEntryPointCondition;
	}
}
-- @extends createComputeEntryPointCondition
lazy rule createComputeEntryPointConditionForComponent
{
	from
		object: AADLI!ComponentInstance
	to
		computeEntryPointCondition: AADLBA!ValueExpression,
		behaviorIdentifiverValueHolder: AADLBA!BehaviorVariableHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(object, 'activatedPort')
		),
		portIDFactor: AADLBA!Factor
		(
			firstValue <- thisModule.createClassifierPropertyReference
		                       (
		                       		thisModule.resolveMatchedSingleIfExists(object, 'whichPortActivatedDataDlassifier'),
									thisModule.createComponentBehaviorEnumerators(object),
									thisModule.resolveMatchedSingleIfExists(object, 'portIDEnumLiteral')
		                       )
		)
	do
	{
		computeEntryPointCondition;
	}
}



rule m_PortBehavior
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence
		(
			fi.getComponentInstance().category=#thread
			and
			behavior.isComputeEntryPointOf(fi)
			and
			behavior.modesIsComputeEntryPointOf(fi)->isEmpty()
		)
	using
	{
		c: AADLI!ComponentInstance = fi.getComponentInstance();
		orderedPorts: AADLI!FeatureInstance = thisModule.theHOOK.getFeaturesOrderedByCriticality(c);
		fiIndex: Integer = orderedPorts->indexOf(fi);
	}
	to
		-- ports image connections
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- fi.name+'_accessCnx_'+behavior.name,
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.getFeatureImg()
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature()
		),
		
		-- Behavior for selectioning port behavior
		computeEntryPointTransition: AADLBA!BehaviorTransition
		(
			name <- behavior.name,
			sourceState <- thisModule.resolveMatchedSingleIfExists(c, 'execState'), --- TODO: add 'if(c.modeInstance->isEmpty()) ... else ... endif
			destinationState <- thisModule.resolveMatchedSingleIfExists(c, 'waitDispatchState'),
			actionBlock <- computeEntryPointActionBlock,
			condition <- thisModule.createComputeEntryPointConditionForPort(fi),
			priority <- thisModule.theHOOK.getFeaturesOrderedByCriticality(c)->indexOf(fi).longValue()
		),
		computeEntryPointActionBlock: AADLBA!BehaviorActionBlock
		(content<-computeEntryPointActions),
		computeEntryPointActions: AADLBA!BehaviorActionSequence,

		-- 1) IfStatement
		checkforMessageAction: AADLBA!IfStatement
		(
			logicalValueExpression <- checkforMessageExpression,
			behaviorActions <- updateActivatedPortAction
		),
		count_variable: AADLBA!BehaviorVariable, --- TODO: PF dependent definition of dataClassifier field
		getCountValue: AADLBA!BehaviorVariableHolder
		(
			element <- count_variable
		),
		getCountAction: AADLBA!SubprogramCallAction, --- TODO: PF dependent definition of SubprogramCallAction content,
		
		
		checkforMessageExpression: AADLBA!ValueExpression
		(
			relations <- Sequence{checkforMessageRelation}
		),
		checkforMessageRelation: AADLBA!Relation
		(
			relationalOperator<-#NotEqual,
			firstExpression<-getCountExpression,
			secondExpression<-zeroValueConstantExpression
		),
		getCountExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{getCountTerm}
		),
		zeroValueConstantExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{zeroValueConstantTerm}
		),
		zeroValueConstantTerm: AADLBA!Term
		(
			factors <- Sequence{zeroValueConstantFactor}
		),
		zeroValueConstantFactor: AADLBA!Factor
		(
			firstValue <- zeroValueConstant
		),
		zeroValueConstant: AADLBA!BehaviorIntegerLiteral
		(
			value <- 0.longValue()
		),
		getCountTerm: AADLBA!Term
		(
			factors <- Sequence{countFactor}
		),
		countFactor: AADLBA!Factor
		(
			firstValue <- count_variable_holder
		),
		count_variable_holder: AADLBA!BehaviorVariableHolder
		(
			element <- count_variable
		),
		
		updateActivatedPortAction: AADLBA!BehaviorActionSequence
		(
			actions <- Sequence{updateActivatedPortAssignment, thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior}, 'call')}
		),
		-- 2) AssignmentAction
		updateActivatedPortAssignment: AADLBA!AssignmentAction
		(
			target <- updateActivatedPortBehaviorVariableHolder,
			valueExpression <- updateActivatedPortValueExpression
		),
		updateActivatedPortBehaviorVariableHolder: AADLBA!BehaviorVariableHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(c, 'activatedPort')
		),
		updateActivatedPortValueExpression: AADLBA!ValueExpression
		(
			relations <- Sequence{updateActivatedPortRelation}
		),
		updateActivatedPortRelation: AADLBA!Relation
		(
			relationalOperator<-#None,
			firstExpression<-updateActivatedPortExpression
		),
		updateActivatedPortExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{updateActivatedPortTerm}
		),
		updateActivatedPortTerm: AADLBA!Term
		(
			factors <- Sequence{updateActivatedPortFactor}
		),
		updateActivatedPortFactor: AADLBA!Factor
		(
			firstValue <- thisModule.createClassifierPropertyReference
			                         (
			                           	thisModule.resolveMatchedSingleIfExists(c, 'whichPortActivatedDataDlassifier'),
										thisModule.createComponentBehaviorEnumerators(c),
										thisModule.resolveLazySingleIfExists(fi, 'createComputeEntryPointConditionForPort', 'portIDEnumLiteral')			
			                         )
		)
  	do
  	{
  		destinationCE.setContext(thisModule.resolveMatchedSingleIfExists(fi.getComponentInstance(), 'callEntryPoint'));
		computeEntryPointActions.actions <- thisModule.populateFeatureComputeEntryPointActions(fi, behavior);
  	}
}

-- @extends m_PortBehavior
rule m_PortBehavior_Mode
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		mode: AADLI!Mode
		(fi.connectedInMode(mode))
	to
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- fi.name+'_accessCnx_'+behavior.name,
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.getFeatureImg(mode)
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature(mode)
		)
}
	

rule populateFeatureComputeEntryPointActions (fi: AADLI!FeatureInstance,
										behavior: AADLI!SubprogramCallSequence)
{
	using
	{
		portsInvoledInCall: Sequence(AADLI!FeatureInstance) = Sequence{};
		c: AADLI!ComponentInstance = fi.getComponentInstance();
		intermediateCallActionSequence: Sequence(AADLBA!BehaviorAction) = Sequence{};			
	}
	do
	{
		if(fi.isInputFeature() and fi.isEventDataPort() and fi.isPeriodicDelayedPort())
		{
			intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectReceiveInputsCalls(fi, behavior));
		}
		
		if(fi.isInputFeature() and fi.isDataPort())
		{
			intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectDataNextValueCalls(fi,behavior));
		}

		for(call in behavior.ownedSubprogramCall)
		{
			if(fi.isInputFeature() and fi.isEventOrEventDataPort())
			{
				for(paramCnx in c.subcomponent.classifier.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->select(paramCnxIter|paramCnxIter.source.context=call and paramCnxIter.destination.connectionEnd = fi.feature))
				{
					intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectDataPutValueCalls(fi,behavior,paramCnx));
				}
				for(paramCnx in c.subcomponent.classifier.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->select(paramCnxIter|paramCnxIter.destination.context=call  and paramCnxIter.source.connectionEnd = fi.feature))
				{
					intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectDataPutValueCalls(fi,behavior,paramCnx));
				}
			}
			
			portsInvoledInCall <- thisModule.getPortsInvoledInCall(c,call);
			if(portsInvoledInCall->isEmpty())
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.append
					(
						thisModule.resolveMatchedTupleIfExists(Sequence{fi,behavior,call}, 'subprogramCallAction')
					);
			}
			else
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.append
					(
						thisModule.createCheckedCall
						(
							thisModule.getPortsInvoledInCall(c,call),
							thisModule.resolveMatchedTupleIfExists(Sequence{fi,behavior,call}, 'subprogramCallAction')
						)
					);
			}
			
			if(fi.isOutputFeature() and fi.isEventOrEventDataPort())
			{
				for(paramCnx in c.subcomponent.classifier.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->select(paramCnxIter|paramCnxIter.source.context=call and paramCnxIter.destination.connectionEnd = fi.feature))
				{
					for(cnxInst in fi.srcConnectionInstance)
					{
						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(fi, behavior, paramCnx, cnxInst));
					}
				}
				for(paramCnx in c.subcomponent.classifier.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->select(paramCnxIter|paramCnxIter.destination.context=call  and paramCnxIter.source.connectionEnd = fi.feature))
				{
					for(cnxInst in fi.srcConnectionInstance)
					{
						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(fi, behavior, paramCnx, cnxInst));
					}
				}
				
				-- users have to send events in their own code or BA subclauses. The code is kept (commented) in case there is a need for it
				-- in special cases
				
--				for(portCnx in c.subcomponent.classifier.ownedPortConnection->select(portCnxIter|portCnxIter.source.context=call  and portCnxIter.destination.connectionEnd = fi.feature))
--				{
--					for(cnxInst in fi.srcConnectionInstance)
--					{
--						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(fi, behavior, portCnx, cnxInst));
--					}
--				}
--				for(portCnx in c.subcomponent.classifier.ownedPortConnection->select(portCnxIter|portCnxIter.destination.context=call  and portCnxIter.source.connectionEnd = fi.feature))
--				{
--					for(cnxInst in fi.srcConnectionInstance)
--					{
--						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(fi, behavior, portCnx, cnxInst));
--					}
--				}
			}
		}
		if(fi.isOutputFeature() and fi.isDataPort())
		{
			for(cnxInst in fi.srcConnectionInstance)
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectDataPutValueCalls(fi, behavior, cnxInst));
			}
		}
		for(source in c.featureInstance->select(e| e.isOutputFeature() and e.isEventDataPort() and e.isPeriodicDelayedPort()))
		{
			for(cnxInst in fi.srcConnectionInstance)
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.append(thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior, cnxInst.connectionReference->first().connection} ,'callSendOutput'));
			}
		}
		intermediateCallActionSequence;
	}
}

-- @extends m_ThreadBehavior
rule m_ComputeEntrypointCallSequence { 
  from	
	c: AADLI!ComponentInstance,
	behavior: AADLI!SubprogramCallSequence
	(
		c.category=#thread 
		and 
		behavior.isComputeEntryPointOf(c)
		and
		(not c.subcomponent.subcomponentType.needsToMapBehaviorAnnex())
	)
	using
	{
		impl : AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
	}
	to
		computeEntryPointActions: AADLBA!BehaviorActionSequence,
		computeEntryPointTransition: AADLBA!BehaviorTransition
		(
			name <- behavior.name
		)
	do
	{
		computeEntryPointActions.actions <- thisModule.populateComputeEntryPointActions(c, behavior)->excluding(OclUndefined);
	}
}


helper def : getPortsInvoledInCall(c: AADLI!ComponentInstance, call: AADLI!SubprogramCall) : Sequence(AADLI!FeatureInstance) = 
	c.featureInstance->select(e| 
		e.isInputFeature() and 
		c.subcomponent.classifier.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->exists(paramCnxIter|
			paramCnxIter.source.context=call and 
			paramCnxIter.destination.connectionEnd = e.feature)
	)
	->union(
		c.featureInstance->select(e| 
		e.isInputFeature() and
		c.subcomponent.classifier.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->exists(paramCnxIter|
			paramCnxIter.destination.context=call and 
			paramCnxIter.source.connectionEnd = e.feature)
		)
	)
;

rule createCheckedCall(features: Sequence(AADLI!FeatureInstance), checkedCall: AADLBA!BehaviorAction)
{
	to
  		checkedAction: AADLBA!IfStatement
		(
			logicalValueExpression <- checkforMessageExpression,
			behaviorActions <- thisModule.errorsCheckActions(checkedCall)
		),
		checkforMessageExpression: AADLBA!ValueExpression
		(
			relations <- features->collect(e|thisModule.createCheckforMessageExpression(e)),
			logicalOperators <- features->excluding(features->first())->collect(e| #And)
		)
	do
	{
		checkedAction;
	}
}


rule createCheckforMessageExpression(fi: AADLI!FeatureInstance)
{
	using
	{
		RETURN_CODE: AADLBA!DataSubcomponent = thisModule.CreateReturnSubcomponentFromPort(fi);
	}
	to

		checkforMessageRelation: AADLBA!Relation
		(
			relationalOperator<-#Equal,
			firstExpression<-getCountExpression,
			secondExpression<-noErrorValueConstantExpression
		),
		getCountExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{getCountTerm}
		),
		noErrorValueConstantExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{noErrorValueConstantTerm}
		),
		noErrorValueConstantTerm: AADLBA!Term
		(
			factors <- Sequence{noErrorValueConstantFactor}
		),
		noErrorValueConstantFactor: AADLBA!Factor
		(
			firstValue <- thisModule.createNoErrorValueConstant()
		),
		getCountTerm: AADLBA!Term
		(
			factors <- Sequence{countFactor}
		),
		countFactor: AADLBA!Factor
		(
			firstValue <- count_variable_holder
		),
		count_variable_holder: AADLBA!DataSubcomponentHolder
		(
			element <- RETURN_CODE
		)
	do
	{
		checkforMessageRelation;
	}
}

rule createNoErrorValueConstant()
{
	to
		noErrorValueConstant: AADLBA!BehaviorIntegerLiteral
		(
			value <- 0.longValue()
		)
	do
	{
		noErrorValueConstant;
	}
}


rule errorsCheckActions(checkedCall: AADLBA!SubprogramCallAction)
{
	to
		errorsCheckActions: AADLBA!BehaviorActionSequence
		(
			actions <- Sequence{checkedCall}
		)
		
	do
	{
		errorsCheckActions;
	}
}



rule populateComputeEntryPointActions (c: AADLI!ComponentInstance,
										behavior: AADLI!SubprogramCallSequence)
{
	using
	{
		intermediateCallActionSequence: Sequence(AADLBA!SubprogramCallAction) = 
			if c.needsModeVariable() then
				Sequence{thisModule.createModeVariableUpdate(c)}
			else 
				Sequence{} 
			endif
			->union
			(
				c.featureInstance->select(fi| 
					fi.isInputFeature() and
					(fi.isEventPort() or fi.isEventDataPort())
				)
				->collect(fi|thisModule.createReceiveInputCall(fi))
			);
		portsInvoledInCall: Sequence(AADLI!FeatureInstance) = Sequence{};
	}
	do
	{
		
		for(destination in c.featureInstance->select(e| e.isInputFeature() and e.isEventDataPort() and e.isPeriodicDelayedPort()))
		{
			intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectReceiveInputsCalls(destination, behavior));
		}
		
		for(destination in c.featureInstance->select(e| e.isInputFeature() and e.isDataPort()))
		{
			intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectDataNextValueCalls(destination, behavior));
		}

		for(call in behavior.ownedSubprogramCall)
		{
			for(destination in c.featureInstance->select(e| e.isInputFeature() and e.isEventOrEventDataPort()))
			{
				for(paramCnx in c.subcomponent.classifier.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->select(paramCnxIter|paramCnxIter.source.context=call and paramCnxIter.destination.connectionEnd = destination.feature))
				{
					intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataNextValueCalls(destination, behavior, paramCnx));
				}
				for(paramCnx in c.subcomponent.classifier.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->select(paramCnxIter|paramCnxIter.destination.context=call  and paramCnxIter.source.connectionEnd = destination.feature))
				{
					intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataNextValueCalls(destination, behavior, paramCnx));
				}
			}
			portsInvoledInCall <- thisModule.getPortsInvoledInCall(c,call);
			if(portsInvoledInCall->isEmpty())
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.append
					(
						thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior,call}, 'subprogramCallAction')
					);
			}
			else
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.append
					(
						thisModule.createCheckedCall
						(
							thisModule.getPortsInvoledInCall(c,call),
							thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior,call}, 'subprogramCallAction')
						)
					);
			}
			
			for(source in c.featureInstance->select(e| e.isOutputFeature() and e.isEventOrEventDataPort()))
			{
				for(paramCnx in c.subcomponent.classifier.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->select(paramCnxIter|paramCnxIter.source.context=call and paramCnxIter.destination.connectionEnd = source.feature))
				{
					for(cnxInst in source.srcConnectionInstance)
					{
						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(source, behavior, paramCnx, cnxInst));
					}
				}
				for(paramCnx in c.subcomponent.classifier.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->select(paramCnxIter|paramCnxIter.destination.context=call  and paramCnxIter.source.connectionEnd = source.feature))
				{
					for(cnxInst in source.srcConnectionInstance)
					{
						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(source, behavior, paramCnx, cnxInst));
					}
				}
				-- next is commented because port connections means subprogram has ports, which has to be managed in
				-- user code. However, this is kept in case it becomes useful later.
				
--				for(portCnx in c.subcomponent.classifier.ownedPortConnection->select(portCnxIter|portCnxIter.source.context=call  and portCnxIter.destination.connectionEnd = source.feature))
--				{
--					for(cnxInst in source.srcConnectionInstance)
--					{
--						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(source, behavior, portCnx, cnxInst));
--					}
--				}
--				for(portCnx in c.subcomponent.classifier.ownedPortConnection->select(portCnxIter|portCnxIter.destination.context=call  and portCnxIter.source.connectionEnd = source.feature))
--				{
--					for(cnxInst in source.srcConnectionInstance)
--					{
--						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(source, behavior, portCnx, cnxInst));
--					}
--				}
			}
		}
		for(source in c.featureInstance->select(e| e.isOutputFeature() and e.isDataPort()))
		{	
			for(cnxInst in source.srcConnectionInstance)
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectDataPutValueCalls(source, behavior, cnxInst));
			}
		}
		if (thisModule.Unique_Send_Output_Per_Thread)
		{
			intermediateCallActionSequence <- intermediateCallActionSequence.append(
				thisModule.resolveLazySingleIfExists(c, 'createPDPLocalVariables_Mutex', 'callSendOutput'));
		}
		else
		{
			for(source in c.featureInstance->select(e| e.isOutputFeature() and e.isEventDataPort() and e.isPeriodicDelayedPort()))
			{
				for(cnxInst in source.srcConnectionInstance)
				{
					intermediateCallActionSequence <- intermediateCallActionSequence.append(thisModule.resolveMatchedTupleIfExists(Sequence{source, behavior, cnxInst.connectionReference->first().connection} ,'callSendOutput'));
				}
			}
		}
		intermediateCallActionSequence;
	}
}

lazy rule CreateParameterHolder
{
	from
		param: AADLBA!Parameter
	to
		holder: AADLBA!ParameterHolder
		(
			element<-param
		)
	do
	{
		holder;
	}
}

lazy rule CreateDataAccessHolder
{
	from
		dataAccess:AADLBA!DataAccess
	to
		holder: AADLBA!DataAccessHolder
		(
			element<-dataAccess
		)
	do
	{
		holder;
	}
}

lazy rule CreateDataSubcomponentHolder
{
	from
		dataSubcomponent:AADLBA!DataSubcomponent
	to
		holder: AADLBA!DataSubcomponentHolder
		(
			element<-dataSubcomponent
		)
	do
	{
		holder;
	}
}

helper context AADLI!SubprogramCall def: getSubprogramClassifier(): AADLI!SubprogramClassifier =
	if(self.calledSubprogram.oclIsKindOf(AADLI!SubprogramClassifier)) then
		self.calledSubprogram
	else if(self.calledSubprogram.oclIsTypeOf(AADLI!SubprogramAccess)) then
			self.calledSubprogram.subprogramFeatureClassifier
		else
			if(self.calledSubprogram.oclIsTypeOf(AADLI!SubprogramSubcomponent)) then
				self.calledSubprogram.subcomponentType
			else
				OclUndefined
			endif
		endif
	endif
;

lazy rule populateParameterLabels
{
	from
		subprogramCall: AADLI!SubprogramCall,
		behavior: AADLI!SubprogramCallSequence,
		c: AADLI!ComponentInstance
	using
	{
		intermediateParameterLabelList: Sequence(AADLBA!ElementHolder) = Sequence{};	
	}
	do{
		if((subprogramCall.calledSubprogram.oclIsKindOf(AADLI!SubprogramClassifier) and subprogramCall.calledSubprogram.needsContext())or 
		(subprogramCall.calledSubprogram.oclIsTypeOf(AADLI!SubprogramAccess) and subprogramCall.calledSubprogram.subprogramFeatureClassifier.needsContext()))
		{
			intermediateParameterLabelList <- thisModule.populateParameterLabelsNeedsContext (subprogramCall, behavior, c);
		}else{
			intermediateParameterLabelList <- thisModule.populateParameterLabelsNoContext (subprogramCall, behavior, c);			
		}
		intermediateParameterLabelList;
	}	
}		


lazy rule populateParameterLabelsNeedsContext
{
	from
		subprogramCall: AADLI!SubprogramCall,
		behavior: AADLI!SubprogramCallSequence,
		c: AADLI!ComponentInstance (
			(
			subprogramCall.calledSubprogram.oclIsKindOf(AADLI!SubprogramClassifier) and 			
			subprogramCall.calledSubprogram.needsContext()
			)
			or 
			(
			subprogramCall.calledSubprogram.oclIsTypeOf(AADLI!SubprogramAccess) and 
			subprogramCall.calledSubprogram.subprogramFeatureClassifier.needsContext()
			)
		)
	using
	{
	 	impl: AADLI!ThreadImplementation = c.subcomponent.classifier;
		spgClassifier: AADLI!SubprogramClassifier = OclUndefined;
		intermediateParameterLabelList: Sequence(AADLBA!ElementHolder) = Sequence{};
		orderedFeatures: Sequence(AADLBA!Feature) = Sequence{};
		d: AADLBA!DataSubcomponent = OclUndefined;
		cnxs : Sequence(AADLI!ParameterConnection) = Sequence{};
		
	}
	do
	{
		thisModule.addImportedUnitFromInputModel(thisModule.public(), subprogramCall.calledSubprogram);
  		if(subprogramCall.calledSubprogram.oclIsKindOf(AADLI!SubprogramClassifier))
  		{
  			spgClassifier <:= subprogramCall.calledSubprogram;
  			orderedFeatures <- spgClassifier.getOrderedFeature();
  		}
	  	else if(subprogramCall.calledSubprogram.oclIsTypeOf(AADLI!SubprogramAccess))
  		{
	  		spgClassifier <:= subprogramCall.calledSubprogram.subprogramFeatureClassifier;
  			orderedFeatures <- spgClassifier.getOrderedFeature();
  		}
	  	
	  	for(sc in behavior.ownedSubprogramCall)
	  	{
	  		if(sc.getSubprogramClassifier()=spgClassifier)
	  		{
	  			intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.CreateDataSubcomponentHolder(thisModule.createSubprogramCallContext(sc,c)));
	  		}
	  	}	  	
		intermediateParameterLabelList;
	}
}


lazy rule populateParameterLabelsNoContext
{
	from
		subprogramCall: AADLI!SubprogramCall,
		behavior: AADLI!SubprogramCallSequence,
		c: AADLI!ComponentInstance 
		( not((
			subprogramCall.calledSubprogram.oclIsKindOf(AADLI!SubprogramClassifier) and 			
			subprogramCall.calledSubprogram.needsContext()
			)
			or 
			(
			subprogramCall.calledSubprogram.oclIsTypeOf(AADLI!SubprogramAccess) and 
			subprogramCall.calledSubprogram.subprogramFeatureClassifier.needsContext()
			))
		)
	using
	{
	 	impl: AADLI!ThreadImplementation = c.subcomponent.classifier;
		spgClassifier: AADLI!SubprogramClassifier = OclUndefined;
		intermediateParameterLabelList: Sequence(AADLBA!ElementHolder) = Sequence{};
		orderedFeatures: Sequence(AADLBA!Feature) = Sequence{};
		d: AADLBA!DataSubcomponent = OclUndefined;
		cnxs : Sequence(AADLI!ParameterConnection) = Sequence{};
		
	}
	do
	{
		thisModule.addImportedUnitFromInputModel(thisModule.public(), subprogramCall.calledSubprogram);
  		if(subprogramCall.calledSubprogram.oclIsKindOf(AADLI!SubprogramClassifier))
  		{
  			spgClassifier <:= subprogramCall.calledSubprogram;
  			orderedFeatures <- spgClassifier.getOrderedFeature();
  		}
	  	else if(subprogramCall.calledSubprogram.oclIsTypeOf(AADLI!SubprogramAccess))
  		{
	  		spgClassifier <:= subprogramCall.calledSubprogram.subprogramFeatureClassifier;
  			orderedFeatures <- spgClassifier.getOrderedFeature();
  		}
	  	
  		for(feature in orderedFeatures)
  		{
  			if(feature.oclIsTypeOf(AADLI!DataAccess))
 			{
  				for(cnx in impl.getAllConnections()->select(e| e.oclIsKindOf(AADLI!AccessConnection) )->select(e | e.accessCategory = #data and e.source.connectionEnd = feature and behavior.ownedSubprogramCall->exists(f | e.source.context = f)))
				{
  					intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.CreateDataAccessHolder(thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior, cnx}, 'dataAccess')));
				}
  				for(cnx in impl.getAllConnections()->select(e| e.oclIsKindOf(AADLI!AccessConnection) )->select(e | e.accessCategory = #data and e.destination.connectionEnd = feature and behavior.ownedSubprogramCall->exists(f | e.destination.context = f)))
				{
  					intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.CreateDataAccessHolder(thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior, cnx}, 'dataAccess')));
				}  			
  			} -- end dataaccess
			
  			if(feature.oclIsKindOf(AADLI!Parameter))
  			{
				--We get all the parameter connections with specific source and subprogram context ; in order to fill the subprogram call with out parameter
				cnxs <- impl.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->select(e | e.source.connectionEnd = feature and e.source.context = subprogramCall);
  				--We suppress all the parameter connections that have the same source to keep just one ; in order to generate only one local variable
  				cnxs <- cnxs -> iterate ( c ; list : Sequence(AADLI!ParameterConnection) = Sequence{} |
  					if ( not (list -> collect ( l | l.source.connectionEnd) -> exists (ce | ce = c.source.connectionEnd ))) 
  						then 
							list.append(c)
						else
							list
					endif
  				);
  				
  				for(cnx in cnxs)
				{
					if(cnx.destination.connectionEnd.oclIsTypeOf(AADLI!Parameter))
					{
						intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.Parameter_to_Parameter_Connection_ends(c, behavior, cnx.source.connectionEnd));
					}
					else if(cnx.destination.connectionEnd.oclIsTypeOf(AADLI!DataAccess))
					{
						d <- thisModule.resolveMatchedTupleIfExists(Sequence{c, behavior, cnx.destination.connectionEnd}, 'dataAccess');
						if(not d.oclIsUndefined())
							intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.CreateDataAccessHolder(d));
					}
					else if(cnx.destination.connectionEnd.oclIsTypeOf(AADLI!DataSubcomponent))
					{
						
						d <- thisModule.resolveMatchedTupleIfExists(Sequence{c.componentInstance->any(e|cnx.destination.connectionEnd = e.subcomponent), behavior, cnx}, 'featureImg');
						if(not d.oclIsUndefined())
							intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.CreateParameterHolder(d));
						
					}
					else if(cnx.destination.connectionEnd.oclIsKindOf(AADLI!Port))
					{
						intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.resolveMatchedTupleIfExists(Sequence{c.featureInstance->any(e|e.feature = cnx.destination.connectionEnd), behavior, cnx}, 'holder'));
					}
				}
  				
  				-- We get all the parameter connections with specific destination and context ; in order to fill the called subprogram with in parameter
  				cnxs <- impl.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->select(e | e.destination.connectionEnd = feature and e.destination.context = subprogramCall);
  				
  				for(cnx in cnxs)
				{
					if(cnx.source.connectionEnd.oclIsTypeOf(AADLI!Parameter))
					{						
							intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.Parameter_to_Parameter_Connection_ends(c, behavior, cnx.source.connectionEnd));
					}
					else if(cnx.source.connectionEnd.oclIsTypeOf(AADLI!DataAccess))
					{
						d <- thisModule.resolveMatchedTupleIfExists(Sequence{c, behavior, cnx.source.connectionEnd}, 'dataAccess');
						if(not d.oclIsUndefined())
							intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.CreateDataAccessHolder(d));
					}
					else if(cnx.source.connectionEnd.oclIsTypeOf(AADLI!DataSubcomponent))
					{
						d <- thisModule.resolveMatchedTupleIfExists(Sequence{c.componentInstance->any(e|cnx.source.connectionEnd = e.subcomponent), behavior, cnx}, 'featureImg');
						if(not d.oclIsUndefined())
							intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.CreateParameterHolder(d));
					}
					else if(cnx.source.connectionEnd.oclIsKindOf(AADLI!Port))
					{
						intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.resolveMatchedTupleIfExists(Sequence{c.featureInstance->any(e|e.feature = cnx.source.connectionEnd), behavior, cnx}, 'holder'));
					}
				}
  				
  			}
  			
  		}
	
		intermediateParameterLabelList;
	}
}

rule m_PortSubprogramCall {
  from
	fi: AADLI!FeatureInstance,
	behavior: AADLI!SubprogramCallSequence,
	subprogramCall: AADLI!SubprogramCall
	(behavior.isComputeEntryPointOf(fi))
  using
  {
	c: AADLI!ComponentInstance = fi.getComponentInstance();
	impl: AADLI!ThreadImplementation = c.subcomponent.classifier;
	calledSubprogram : AADLI!SubprogramClassifier = subprogramCall.getSubprogramClassifier();
	intermediateParameterLabelList: Sequence(AADLBA!ElementHolder) = Sequence{};
  }
  to
  	subprogramCallAction: AADLBA!SubprogramCallAction
	(
		subprogram <- callHolder 
	),
	callHolder: AADLBA!CalledSubprogramHolder
	(
		element <- calledSubprogram
	)
  do
  {
	intermediateParameterLabelList <- thisModule.populateParameterLabels(subprogramCall, behavior, c);
  	subprogramCallAction.parameterLabels <- intermediateParameterLabelList->excluding(OclUndefined);	
  }
}

rule m_ComponentSubprogramCall {
  from
	c: AADLI!ComponentInstance,
	behavior: AADLI!SubprogramCallSequence,
	subprogramCall: AADLI!SubprogramCall
	(behavior.isComputeEntryPointOf(c))
  using
  {
	impl: AADLI!ThreadImplementation = c.subcomponent.classifier;
	intermediateParameterLabelList: Sequence(AADLBA!ElementHolder) = Sequence{};
	calledSubprogram : AADLI!SubprogramClassifier = subprogramCall.getSubprogramClassifier();
  }
  to
  	subprogramCallAction: AADLBA!SubprogramCallAction
	(
		subprogram <- callHolder 
	),
	callHolder: AADLBA!CalledSubprogramHolder
	(
		element <- calledSubprogram
	)
  do
  {
  	intermediateParameterLabelList <- thisModule.populateParameterLabels(subprogramCall, behavior, c);
  	subprogramCallAction.parameterLabels <- intermediateParameterLabelList->excluding(OclUndefined);
  }
}

helper context AADLI!ParameterConnection def: isParamToPortConnection(): Boolean =
	self.source.connectionEnd.oclIsTypeOf(AADLI!Port)
	or
	self.destination.oclIsTypeOf(AADLI!Port)
;

helper context AADLI!ParameterConnection def: isParamToParamConnection(): Boolean =
	self.source.connectionEnd.oclIsTypeOf(AADLI!Parameter)
	and
	self.destination.connectionEnd.oclIsTypeOf(AADLI!Parameter)
;

helper context AADLI!AccessConnection def: isAccessToParamConnection(): Boolean = 
	(
		self.source.context.oclIsKindOf(AADLI!SubprogramCall) and self.source.connectionEnd.oclIsTypeOf(AADLI!DataAccess)
	)
	or
	(
		self.destination.context.oclIsKindOf(AADLI!SubprogramCall) and self.destination.connectionEnd.oclIsTypeOf(AADLI!DataAccess)
	)
;

helper context AADLI!Connection def: isPartOfCallSequence(behavior: AADLI!Element): Boolean =
	if(behavior.oclIsKindOf(AADLI!SubprogramCallSequence)) then
		behavior.ownedSubprogramCall->exists(e|self.source.context = e or self.destination.context = e)
	else
		false
	endif
;

abstract rule m_Parameter_to_DataAccess_Connection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		accessCnx: AADLI!AccessConnection
		(
			behavior.isComputeEntryPointOf(c)
		)
	to
		dataAccess: AADLBA!DataAccess
		(
			kind <- #requires
		),
		accessConnection: AADLBA!AccessConnection
		(
			name <- accessCnx.uniqueName()+'_entrypoint',
			accessCategory <- #data,
			source <- ceSource,
			destination <- ceDestination
		),
		ceSource: AADLBA!ConnectedElement
		(connectionEnd <- dataAccess),
		ceDestination: AADLBA!ConnectedElement
}

-- @extends m_Parameter_to_DataAccess_Connection
rule m_Parameter_to_DataAccess_SourceConnection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		accessCnx: AADLI!AccessConnection
		(
			behavior.ownedSubprogramCall->exists(e|accessCnx.source.context = e)
			and
			accessCnx.source.connectionEnd.oclIsKindOf(AADLI!DataAccess)
		)
	using
	{
		callAccess: AADLBA!DataAccess = accessCnx.source.connectionEnd;
	}
	to
		dataAccess: AADLBA!DataAccess
		(
			name <- behavior.qualified_name()+'_'+callAccess.qualified_name()+'_entrypoint',
			dataFeatureClassifier <- callAccess.dataFeatureClassifier
		),
		accessConnection: AADLBA!AccessConnection
		(
			name <- accessCnx.uniqueName()+'_entrypoint'
		),
		ceSource: AADLBA!ConnectedElement
		(connectionEnd <- dataAccess),
		ceDestination: AADLBA!ConnectedElement
		(connectionEnd <- accessCnx.destination.connectionEnd)
	do
	{
		ceSource.setContext(thisModule.resolveMatchedSingleIfExists(c,'callEntryPoint'));
	}
}

-- @extends m_Parameter_to_DataAccess_Connection
rule m_Parameter_to_DataAccess_DestinationConnection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		accessCnx: AADLI!AccessConnection
		(
			accessCnx.destination.connectionEnd.oclIsKindOf(AADLI!DataAccess)
			and
			behavior.ownedSubprogramCall->exists(e|accessCnx.destination.context = e)
		)
	using
	{
		callAccess: AADLBA!DataAccess = accessCnx.destination.connectionEnd;
	}
	to
		dataAccess: AADLBA!DataAccess
		(
			name <- behavior.qualified_name()+'_'+callAccess.qualified_name()+'_entrypoint',
			dataFeatureClassifier <- callAccess.dataFeatureClassifier
		),
		accessConnection: AADLBA!AccessConnection
		(
			name <- accessCnx.uniqueName()+'_entrypoint'
		),
		ceSource: AADLBA!ConnectedElement
		(connectionEnd <- accessCnx.source.connectionEnd),
		ceDestination: AADLBA!ConnectedElement
		(connectionEnd <- dataAccess)
	do
	{
		ceDestination.setContext(thisModule.resolveMatchedSingleIfExists(c,'callEntryPoint'));
	}
}

rule m_Parameter_to_PortInstance_Connection
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			(paramCnx.source.connectionEnd = fi.feature
			or
			paramCnx.destination.connectionEnd = fi.feature)
			and
			paramCnx.isPartOfCallSequence(behavior)
			and
			behavior.isComputeEntryPointOf(fi.getComponentInstance())
			and
			fi.feature.oclIsKindOf(AADLI!Port)
		)
	to
		holder: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(fi, 'localVariable')
		)
}


abstract rule m_Parameter_to_DataInstance_Connection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			(paramCnx.source.connectionEnd = c.subcomponent
			or
			paramCnx.destination.connectionEnd = c.subcomponent)
			and
			paramCnx.isPartOfCallSequence(behavior)
			and
			behavior.isComputeEntryPointOf(c.getContainingThread())
			and
			c.subcomponent.subcomponentType.oclIsKindOf(AADLI!DataClassifier)
		)
	to
		parameterConnection: AADLBA!ParameterConnection
		(
			name <- paramCnx.name,
			source<-paramConnectedElement,
			destination<-subcomponentConnectedElement
		),
		paramConnectedElement: AADLBA!ConnectedElement
		(
			connectionEnd <- featureImg
		),
		subcomponentConnectedElement: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveMatchedSingleIfExists(c,'sub')
		),
		featureImg: AADLBA!Parameter
		(
			dataFeatureClassifier <- c.subcomponent.subcomponentType 
		)
	do
	{
		paramConnectedElement.setContext(thisModule.resolveMatchedSingleIfExists(c.getContainingThread(), 'callEntryPoint'));
	}
		
}

-- @extends m_Parameter_to_DataInstance_Connection
rule m_Parameter_to_DataInstance_SourceConnection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			paramCnx.source.connectionEnd = c.subcomponent
		)
	to
		featureImg: AADLBA!Parameter
		(
			name <-  paramCnx.uniqueName()+'_'+paramCnx.destination.connectionEnd.name
		)	
}

-- @extends m_Parameter_to_DataInstance_Connection
rule m_Parameter_to_DataInstance_DestinationConnection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			paramCnx.destination.connectionEnd = c.subcomponent
		)
	to
		featureImg: AADLBA!Parameter
		(
			name <-   paramCnx.uniqueName()+'_'+paramCnx.source.connectionEnd.name
		)	
}

rule m_Parameter_to_DataAccess_Connection_sub
{
	from 
		c: AADLI!ComponentInstance, 
		behavior: AADLI!SubprogramCallSequence,		
		cnxE_src : AADLI!ConnectionEnd
		(						
			behavior.isComputeEntryPointOf(c) and 
			cnxE_src.isPartOfCallSequence(behavior,c) and			
			cnxE_src.belongsToParamToDataConnection(c) 
			
		)
	to
		dataAccess : AADLBA!DataAccess (
			name <- cnxE_src.name,
			dataFeatureClassifier <- cnxE_src.dataFeatureClassifier,
			kind <- #requires
		),
		accessConnection: AADLBA!AccessConnection (
			accessCategory <- #data,
			name <- cnxE_src.name+'_cnx',
			source <- ce_src,
			destination <- ce_dest
		),
		ce_src : AADLBA!ConnectedElement (
			context <- thisModule.resolveMatchedSingleIfExists(c, 'callEntryPoint'),
			connectionEnd <- dataAccess	
		),
		ce_dest : AADLBA!ConnectedElement (			
			connectionEnd <- dataAccess	
		)
}

rule m_DataAccess_to_Parameter_Connection_sub
{
	from 
		c: AADLI!ComponentInstance, 
		behavior: AADLI!SubprogramCallSequence,		
		cnxE_src : AADLI!ConnectionEnd
		(						
			behavior.isComputeEntryPointOf(c) and 
			cnxE_src.isPartOfCallSequence(behavior,c) and			
			cnxE_src.belongsToDataToParamConnection(c)
		)

	to
		dataAccess : AADLBA!DataAccess (
			name <- cnxE_src.name,
			dataFeatureClassifier <- cnxE_src.dataFeatureClassifier,
			kind <- #requires
		),
		accessConnection: AADLBA!AccessConnection (
			accessCategory <- #data,
			name <- cnxE_src.name+'_cnx',
			source <- ce_src,
			destination <- ce_dest
		),
		ce_src : AADLBA!ConnectedElement (
			connectionEnd <- dataAccess	
		),
		ce_dest : AADLBA!ConnectedElement (
			context <- thisModule.resolveMatchedSingleIfExists(c, 'callEntryPoint'),
			connectionEnd <- dataAccess	
		)	
}

helper context AADLI!ConnectionEnd def: belongsToParamToDataConnection(c_inst :  AADLI!ComponentInstance ): Boolean =
	let paramCnx : Sequence (AADLI!ParameterConnection) =  c_inst.subcomponent.getSubcomponentType().ownedParameterConnection-> select(c | c.destination.connectionEnd = self) in
	self.oclIsTypeOf(AADLI!DataAccess) and paramCnx -> exists ( c | c.source.connectionEnd.oclIsTypeOf(AADLI!Parameter) )
	;

helper context AADLI!ConnectionEnd def: belongsToDataToParamConnection(c_inst :  AADLI!ComponentInstance ): Boolean =
	let paramCnx : Sequence (AADLI!ParameterConnection) =  c_inst.subcomponent.getSubcomponentType().ownedParameterConnection-> select(c | c.source.connectionEnd = self) in
	self.oclIsTypeOf(AADLI!DataAccess) and paramCnx -> exists ( c | c.destination.connectionEnd.oclIsTypeOf(AADLI!Parameter) )
	;

helper context AADLI!ConnectionEnd def: belongsToParamToParamConnection(c_inst :  AADLI!ComponentInstance ): Boolean =
	let paramCnx : Sequence (AADLI!ParameterConnection) =  c_inst.subcomponent.getSubcomponentType().ownedParameterConnection-> select(c | c.source.connectionEnd = self) in
	self.oclIsTypeOf(AADLI!Parameter) and paramCnx -> exists ( c | c.destination.connectionEnd.oclIsTypeOf(AADLI!Parameter) )
	;

helper context AADLI!ConnectionEnd def: isPartOfCallSequence(behavior: AADLI!Element,c_inst :  AADLI!ComponentInstance): Boolean =
	let paramCnx : Sequence (AADLI!ParameterConnection) =  c_inst.subcomponent.getSubcomponentType().ownedParameterConnection-> select(c | c.source.connectionEnd = self) in
	
	if(behavior.oclIsKindOf(AADLI!SubprogramCallSequence)) then
		paramCnx -> forAll ( c | behavior.ownedSubprogramCall->exists(e|c.source.context = e or c.destination.context = e))
	else
		false
	endif
;


helper context AADLI!SubprogramCallSequence def: isComputeEntryPointOf(c: AADLI!InstanceObject): Boolean =
	c.ownedPropertyAssociation->exists(
				e | 
				e.property.name = 'Compute_Entrypoint_Call_Sequence'
				and
				e.ownedValue->exists(f|f.ownedValue.containmentPathElement->first().namedElement=self)
			)
;

rule m_Parameter_to_Parameter_Connection
{
	from 
		c: AADLI!ComponentInstance, 
		behavior: AADLI!SubprogramCallSequence,		
		cnxE_src : AADLI!ConnectionEnd
		(						
			behavior.isComputeEntryPointOf(c) and 
			cnxE_src.isPartOfCallSequence(behavior,c) and			
			cnxE_src.belongsToParamToParamConnection(c)
		)

	to
		paramCnxVariable: AADLBA!DataSubcomponent
		(
			name <- cnxE_src.qualified_name()+'_localVariable',
			dataSubcomponentType <- cnxE_src.dataFeatureClassifier
		)
}

lazy rule Parameter_to_Parameter_Connection_ends
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		cnxE_src : AADLI!ConnectionEnd
		(
			behavior.isComputeEntryPointOf(c) and 
			cnxE_src.belongsToParamToParamConnection(c) and
			cnxE_src.isPartOfCallSequence(behavior,c) 
			
		)
	to
		holder: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior,cnxE_src}, 'paramCnxVariable')
		)
	do
	{
		holder;
	}
}

lazy rule Parameter_to_Parameter_Connection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			paramCnx.isParamToParamConnection()
			and
			paramCnx.isPartOfCallSequence(behavior)
			and
			behavior.isComputeEntryPointOf(c)
		)
	to
		holder: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior,paramCnx.source.connectionEnd}, 'paramCnxVariable')
		)
	do
	{
		holder;
	}
}



--  	- m_Port_ComputeEntrypointCallSequence: for each pair (call sequence, feature instance)
--  		such that:
--  			feature instance is a thread port
--  			and
--  			call sequence is a compute entrypoint of the owner of the feature instance
--  		produce:
--  			nothing yet
abstract rule m_Port_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence
		(
			fi.isThreadPort()
			and
			behavior.isComputeEntryPointOf(fi.getComponentInstance())
		)
}

--  	- m_Input_Port_ComputeEntrypointCallSequence extends m_Port_ComputeEntrypointCallSequence: for each pair (call sequence, feature instance)
--  		such that:
--  			feature instance is an input port
--  		produce:
--  			nothing yet

--connexion
-- @extends m_Port_ComputeEntrypointCallSequence
rule m_Input_Port_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence
		(
			fi.isInputFeature()
		)
	to
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- fi.name+'_accessCnx_'+behavior.name,
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.getFeatureImg()
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature()
		)
	do
	{
		destinationCE.setContext(thisModule.resolveMatchedSingleIfExists(fi.getComponentInstance(), 'callEntryPoint'));
	}
}

-- @extends m_Input_Port_ComputeEntrypointCallSequence
rule m_Input_Port_ComputeEntrypointCallSequence_Mode
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		mode: AADLI!Mode
		(
			fi.connectedInMode(mode)
		)
	to
		f_connection: AADLBA!AccessConnection
		(
			name <- fi.name+'_accessCnx_'+behavior.name+'_'+mode.name
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.getFeatureImg(mode)
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature(mode)
		)
}


-- @extends m_Input_Port_ComputeEntrypointCallSequence
abstract rule m_Input_EventOrEventDataPort_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			fi.isInputFeature()
			and
			(fi.isEventPort() or fi.isEventDataPort())
			and
			(paramCnx.source.connectionEnd = fi.feature
				or
				paramCnx.destination.connectionEnd = fi.feature)
		)
}




--  	- m_Input_EventPort_ComputeEntrypointCallSequence extends m_Input_Port_ComputeEntrypointCallSequence: for each tuple (call sequence, feature instance, parameter connection)
--  		such that
--  			feature instance is an event port
--  			parameter connection source is the feature instance
--  		produce
--  			(i) a subprogram call getValue
--  			(ii) a connection from image f of feature instance to parameter of getValue
--  			(iii) a connection from image localVariable of feature instance to parameter of getValue

-- @extends m_Input_EventOrEventDataPort_ComputeEntrypointCallSequence
abstract rule m_Input_EventPort_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			fi.isEventPort()
		)
}

--  	- m_Input_EventDataPort_ComputeEntrypointCallSequence extends m_Input_Port_ComputeEntrypointCallSequence
--  		such that
--  			feature instance is an event port
--  			parameter connection source is the feature instance
--  		produce
--  			(i) a subprogram call getValue
--  			(ii) a connection from image f of feature instance to parameter of getValue
--  			(iii) a connection from image localVariable of feature instance to parameter of getValue

-- @extends m_Input_EventOrEventDataPort_ComputeEntrypointCallSequence,m_Parameter_to_PortInstance_Connection
rule m_Input_EventDataPort_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			fi.isEventDataPort()
		)
}

--  	- m_Input_DataPort_ComputeEntrypointCallSequence extends m_Input_Port_ComputeEntrypointCallSequence: for each pair (call sequence, feature instance)
--  		such that:
--  			feature instance is a data port
--  		produce:
--  			(i) a subprogram call getValue
--  			(ii) a connection from image f of feature instance to parameter of getValue
--  			(iii) a connection from image localVariable of feature instance to parameter of getValue

-- @extends m_Input_Port_ComputeEntrypointCallSequence
abstract rule m_Input_DataPort_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence
		(
			fi.isDataPort()
		)
	to
		call:AADLBA!SubprogramCallAction
}


--  	- m_Output_Port_ComputeEntrypointCallSequence extends m_Port_ComputeEntrypointCallSequence: for each tuple (call sequence, feature instance, connection instance)
--  		such that:
--  			feature instance is an output port
--  			and
--  			feature instance is the source of the connection instance

-- @extends m_Port_ComputeEntrypointCallSequence,m_OutputFeature_Filter
rule m_Output_Port_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		cnxRef: AADLI!PortConnection
		(
			fi.srcConnectionInstance->exists(e|e.connectionReference->exists(cnx| cnx.connection = cnxRef))
		)
	to
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- fi.name+'_accessCnx_'+behavior.name+'_'+cnxRef.name,
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveMatchedTupleIfExists(Sequence{fi,cnxRef},'f')
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature(cnxRef)
		)
	do
	{
		destinationCE.setContext(thisModule.resolveMatchedSingleIfExists(fi.getComponentInstance(), 'callEntryPoint'));
	}
}

-- @extends m_Output_Port_ComputeEntrypointCallSequence
rule m_Output_Port_ComputeEntrypointCallSequence_Mode
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		cnxRef: AADLI!PortConnection,
		mode: AADLI!Mode
		(cnxRef.inModeOrTransition->includes(mode))
	to
		f_connection: AADLBA!AccessConnection
		(
			name <- fi.name+'_accessCnx_'+behavior.name+'_'+cnxRef.name+'_'+mode.name
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveMatchedTupleIfExists(Sequence{fi,cnxRef,mode},'f')
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature(cnxRef, mode)
		)
}

--  	- m_Output_EventOrEventDataPort_ComputeEntrypointCallSequence extends m_Output_Port_ComputeEntrypointCallSequence: for each tuple (call sequence, feature instance, parameter connection, connection instance)
--  		such that:
--  			feature instance is the source of connection instance
--  			feature instance is an event data port
--  		produce:
--  			(i) a subprogram call putValue
--  			(ii) a connection from image f of feature instance to parameter of putValue
--  			(iii) a connection from image localVariable of feature instance to parameter of putValue

-- @extends m_Port_ComputeEntrypointCallSequence,m_OutputFeature_Filter
abstract rule m_Output_EventOrEventDataPort_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection,
		cnxRef: AADLI!PortConnection		
		(
			(fi.isEventPort() or fi.isEventDataPort())
			and
			(cnxRef.source.connectionEnd = fi.feature)
			and
			(paramCnx.source.connectionEnd = fi.feature
				or
				paramCnx.destination.connectionEnd = fi.feature)
			and
			fi.srcConnectionInstance->exists(e| e.connectionReference.first().connection = cnxRef)
		)
	to
		call: AADLBA!SubprogramCallAction
}


--  	- m_Output_EventPort : for each tuple (call sequence, feature instance, port connection, connection instance)
--  		such that:
--  			feature instance is the source of a connection instance
--  			feature instance is an event port
--				feature instance is the dest of a port connection with a subprogram feature
--  		produce:
--  			(i) a subprogram call putValue
--  			(ii) a connection from image f of feature instance to parameter of putValue
--  			(iii) a connection from image localVariable of feature instance to parameter of putValue

-- @extends m_OutputFeature_Filter
abstract rule m_Output_EventPort
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		portCnx: AADLI!PortConnection,
		cnxRef: AADLI!PortConnection		
		(
			fi.isEventPort()
			and
			(cnxRef.source.connectionEnd = fi.feature)
			and
			portCnx.destination.connectionEnd = fi.feature
			and
			(behavior.ownedSubprogramCall->exists(e| portCnx.source.context = e))
		)
	to
		call: AADLBA!SubprogramCallAction
}

-- @extends m_OutputFeature_Filter
abstract rule m_Output_EventDataPort
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		portCnx: AADLI!PortConnection,
		cnxRef: AADLI!PortConnection		
		(
			fi.isEventDataPort()
			and
			(cnxRef.source.connectionEnd = fi.feature)
			and
			portCnx.destination.connectionEnd = fi.feature
			and
			(behavior.ownedSubprogramCall->exists(e| portCnx.source.context = e))
		)
	to
		call: AADLBA!SubprogramCallAction
}

--  	- m_Output_DataPort_ComputeEntrypointCallSequence extends m_Output_Port_ComputeEntrypointCallSequence: for each tuple (call sequence, feature instance, connection instance)
--  	  	such that:
--  			feature instance is a data port
--  		produce:
--  			(i) a subprogram call putValue
--  			(ii) a connection from image f of feature instance to parameter of putValue
--  			(iii) a connection from image localVariable of feature instance to parameter of putValue

-- @extends m_Output_Port_ComputeEntrypointCallSequence
rule m_Output_DataPort_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		cnxRef: AADLI!PortConnection		
		(
			fi.isDataPort()
			and
			(cnxRef.source.connectionEnd = fi.feature
				or cnxRef.destination.connectionEnd = fi.feature)
		)
}



-----------------------------------------------------------------
--- End of refactoring
-----------------------------------------------------------------

unique lazy rule createSubprogramCallSequence {
 from
 	implImg: AADLBA!ThreadImplementation
 to
	seq: AADLBA!SubprogramCallSequence(
			name <- 'callSeq_Default'
		)
}


helper context AADLBA!ThreadImplementation def : createBAVariablesForSpgParameters() : Sequence(AADLBA!BehaviorVariable) =
	self.behavior().getAllOutParameters()->collect(p|thisModule.CreateVariableForParameter(p))
;

unique lazy rule CreateVariableForParameter {
 from
	p : AADLI!Parameter
 using
 {
	pName : String = p.eContainer().name.concat('_').concat(p.name);
 }
 to
	v : AADLBA!BehaviorVariable (
		dataClassifier <- p.dataFeatureClassifier
	)
  do 
  { 
  	pName.debug('  create behavior variable');
  	v;
  }
}


lazy rule CreateAction_SubprogramCall
{
 from
	behavior: AADLBA!BehaviorAnnex,
	call: AADLBA!SubprogramCall
 using
 {
 	seq : AADLBA!SubprogramCallSequence = call.eContainer();
 	owner : AADLBA!ComponentImplementation = seq.eContainer();
 }
 to
   callAction			: AADLBA!SubprogramCallAction (
		subprogram					<- subprogramRef,
		parameterLabels				<- call.calledSubprogram.ownedParameter
										->collect(p|behavior.getBehaviorVariableForParameter(owner, call, p))
										->select(v|not v.oclIsUndefined()) -- remove when input ports will be removed
										->collect(v|thisModule.CreateBAName(v.getName(), v))
	),
	
	subprogramRef		: AADLBA!CalledSubprogramHolder (
		subprogram 					<- call.calledSubprogram
	)
 do { callAction; }
}

--rule addParameterConnection(implImg: AADLBA!ThreadImplementation, name: String, param: AADLBA!Parameter, ctx:AADLBA!Context, variable: AADLBA!DataSubcomponent)
--{
--  to
--	connectedParam: AADLBA!ConnectedElement
--	(
--		connectionEnd<-param
--	),
--	connectedSubcomponent: AADLBA!ConnectedElement
--	(
--		connectionEnd<-variable
--	),
--	paramConnection: AADLBA!ParameterConnection
--	(
--		name<-name,
--		source<-connectedParam,
--		destination<-connectedSubcomponent
--	)
--  do
--  {
--  	if(not ctx.oclIsUndefined())
--  		connectedParam.setContext(ctx);
--  	implImg.ownedParameterConnection <- implImg.ownedParameterConnection.including(paramConnection);
--  }
--}

lazy rule addSuprogramCallParameterConnection
{
	from
		implImg:AADLBA!ThreadImplementation,
		paramConnection: AADLI!ParameterConnection
	using
	{
		dataSubcomponent: AADLBA!DataSubcomponent = thisModule.addParameterLocalVariable(paramConnection.source, implImg);
	}
	do
	{
		thisModule.addParameterConnection(implImg, 'dest_'+paramConnection.destination.connectionEnd.name+'_'+paramConnection.source.connectionEnd.name,
							paramConnection.destination.getConnFeatureImg(implImg),
							paramConnection.destination.getConnContextImg(implImg),
							dataSubcomponent);
			
		thisModule.addParameterConnection(implImg, 'src_'+paramConnection.source.connectionEnd.name+'_'+paramConnection.destination.connectionEnd.name,
							paramConnection.source.getConnFeatureImg(implImg),
							paramConnection.source.getConnContextImg(implImg),
							dataSubcomponent);
	}
}

rule mapSubprogramParameters(implImg: AADLBA!ComponentImplementation, impl: AADLI!ComponentClassifier)
{
	do
	{
		for(paramConnection in impl.getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) ))
		{
			if(paramConnection.source.connectionEnd.oclIsKindOf(AADLI!Parameter) and paramConnection.destination.connectionEnd.oclIsKindOf(AADLI!Parameter))
			{
				thisModule.addSuprogramCallParameterConnection(implImg, paramConnection);
			}
		}
	}
}


unique lazy rule addParameterLocalVariable
{
	from
		paramConnectionEnd: AADLI!ParameterConnectionEnd,
		implImg: AADLBA!ThreadImplementation
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name <- 'from_'+paramConnectionEnd.connectionEnd.name,
			dataSubcomponentType <- paramConnectionEnd.getConnFeatureImg(implImg).dataFeatureClassifier
		)
	do
	{
		implImg.ownedDataSubcomponent <- implImg.ownedDataSubcomponent.including(dataSubcomponent.debug('Added Parameter Local Variable'));
		
	}
}

rule mapConstantParameter(p: AADLBA!Parameter,
						  value : String,
						  call: AADLI!SubprogramCall,
						  implImg : AADLBA!ComponentImplementation)
{
	using
	{
		initValuePE: AADLBA!PropertyExpression = thisModule.CreateStringLiteralPropertyExpression(value);
	}
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name <- 'constant_'+call.name+'_'+p.name,
			dataSubcomponentType <- p.dataFeatureClassifier,
			ownedPropertyAssociation <- Sequence {thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL',lv)}
		),
		lv: AADLBA!ListValue
		(
			ownedListElement <- Sequence{initValuePE}
		)
		
	do
	{
		implImg.ownedDataSubcomponent <- implImg.ownedDataSubcomponent.including(dataSubcomponent);
		
		thisModule.addParameterConnection(implImg, 'dest_'+dataSubcomponent.name,
							p,
							call,
							dataSubcomponent);
	}
}

helper context AADLBA!SubprogramCall def:getConnectedParamDataSubcomponent(p: AADLBA!Parameter) : AADLBA!DataSubcomponent =
	if(not self.eContainer().eContainer().getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->any
	( paramCnx |
		paramCnx.source.getContext() = self and paramCnx.source.connectionEnd = p
	).oclIsUndefined())
	then
		self.eContainer().eContainer().getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->any
		( paramCnx |
			paramCnx.source.getContext() = self and paramCnx.source.connectionEnd = p
		).destination.connectionEnd
	else 
		if(not self.eContainer().eContainer().getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->any
		( paramCnx |
			paramCnx.destination.getContext() = self and paramCnx.destination.connectionEnd = p
		).oclIsUndefined())
		then
			self.eContainer().eContainer().getAllConnections()->select(e| e.oclIsKindOf(AADLI!ParameterConnection) )->any
			( paramCnx |
				paramCnx.destination.getContext() = self and paramCnx.destination.connectionEnd = p
			).source.connectionEnd
		else
			OclUndefined.debug('ERROR: Could not find Parameter Connection for '+p.name+' in '+self.name)
		endif
	endif
;

helper context AADLBA!SubprogramCall def:getConnectedAccessDataSubcomponent(p: AADLBA!DataAccess) : AADLBA!DataSubcomponent =
	if(not self.eContainer().eContainer().getAllConnections()->select(e| e.oclIsKindOf(AADLI!AccessConnection) )->any
	( accessCnx |
		accessCnx.source.getContext() = self and accessCnx.source.connectionEnd = p
	).oclIsUndefined())
	then
		self.eContainer().eContainer().getAllConnections()->select(e| e.oclIsKindOf(AADLI!AccessConnection) )->any
		( accessCnx |
			accessCnx.source.getContext() = self and accessCnx.source.connectionEnd = p
		).destination.connectionEnd
	else 
		if(not self.eContainer().eContainer().getAllConnections()->select(e| e.oclIsKindOf(AADLI!AccessConnection) )->any
		( accessCnx |
			accessCnx.destination.getContext() = self and accessCnx.destination.connectionEnd = p
		).oclIsUndefined())
		then
			self.eContainer().eContainer().getAllConnections()->select(e| e.oclIsKindOf(AADLI!AccessConnection) )->any
			( accessCnx |
				accessCnx.destination.getContext() = self and accessCnx.destination.connectionEnd = p
			).source.connectionEnd
		else
			OclUndefined
		endif
	endif
;

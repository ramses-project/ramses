--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLI=http:///AADL2/instance
-- @atlcompiler emftvm

module SubprogramCallsCommonRefinementSteps;

create 
	OUT 				   : AADLBA
from 
	IN 					   : AADLI,
	BASE_TYPES			   : AADLBA,
	AADL_RUNTIME		   : AADLBA,
	DATA_MODEL			   : AADLBA,
	SCHEDULER_CONSTANTS	   : AADLBA,
	SCHEDULER_REALIZATIONS : AADLBA,
	SCHEDULER_RUNTIME	   : AADLBA;

helper def : Unique_Send_Output_Per_Thread : Boolean = false;



helper def: collectDataNextValueCalls(fi: AADLI!FeatureInstance, behavior:AADLI!SubprogramCallSequence): Sequence(AADLBA!SubprogramCall) =
	Sequence{thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior} ,'call')}
;

helper def: collectEventDataNextValueCalls(fi: AADLI!FeatureInstance, behavior:AADLI!SubprogramCallSequence, paramCnx:AADLBA!ParameterConnection): Sequence(AADLBA!SubprogramCall) =
	Sequence{thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior, paramCnx} ,'call')}
;

helper def: collectDataPutValueCalls(fi: AADLI!FeatureInstance, behavior:AADLI!SubprogramCallSequence, cnxInst:AADLI!ConnectionInstance): Sequence(AADLBA!SubprogramCall) =
	Sequence{
		thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior, cnxInst.connectionReference->first().connection} ,'call')
	}
;

helper def: collectEventDataPutValueCalls(fi: AADLI!FeatureInstance, behavior:AADLI!SubprogramCallSequence, paramCnx:AADLBA!Connection, cnxInst:AADLI!ConnectionInstance): Sequence(AADLBA!SubprogramCall) =
	Sequence{
		thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior, paramCnx, cnxInst.connectionReference->first().connection} ,'call')
	}
;

helper def: collectReceiveInputsCalls(fi: AADLI!FeatureInstance, behavior:AADLI!SubprogramCallSequence) : Sequence(AADLBA!SubprogramCall) =
	Sequence{
		thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior} ,'callReceiveInputs')
	}
;

helper def: collectCommunicationsLocalVariables(c: AADLI!ComponentInstance, callSequences: Sequence(AADLI!SubprogramCallSequence)): Sequence(AADLBA!DataSubcomponent)=
	Sequence{}
;

helper def: collectThreadInitActions(c: AADLI!ComponentInstance): Sequence(AADLBA!BehaviorAction) =
	Sequence{}
;

helper def: collectComputeEntryPointTransitions(c: AADLI!ComponentInstance): Sequence(AADLBA!BehaviorTransition) =
	c.featureInstance->select(fi| not fi.getComputeEntryPoints().oclIsUndefined() )
	->collect
	( fi |
		fi.getComputeEntryPoints()->collect
			(
				cep | thisModule.resolveMatchedTupleIfExists(Sequence{fi, cep}, 'computeEntryPointTransition')
			)
	)
	->union(
			c.getComputeEntryPoints()->collect(cep | thisModule.resolveMatchedTupleIfExists(Sequence{c, cep}, 'computeEntryPointTransition'))
		)
	->flatten()
;


helper def: collectBAEntryPointTransitions(c: AADLI!ComponentInstance): Sequence(AADLBA!BehaviorTransition) =
	Sequence{thisModule.resolveMatchedTupleIfExists(Sequence{c, c.subcomponent.classifier.getBA()}, 'computeEntryPointTransition')}
;

helper def: collectBAEntryPointActionBlocks(c: AADLI!ComponentInstance): Sequence(AADLBA!BehaviorActionBlock) =
	Sequence{thisModule.resolveMatchedTupleIfExists(Sequence{c, c.subcomponent.classifier.getBA()}, 'computeEntryPointActionBlock')}
;

helper def: collectComputeEntryPointActionBlocks(c: AADLI!ComponentInstance): Sequence(AADLBA!BehaviorActionBlock) =
	c.featureInstance->select(fi| not fi.getComputeEntryPoints()->isEmpty() )
	->collect
	( fi |
		fi.getComputeEntryPoints()->collect
			(
				cep | thisModule.resolveMatchedTupleIfExists(Sequence{fi, cep}, 'computeEntryPointActionBlock')
			)
	)
	->union(
			c.getComputeEntryPoints()->collect(cep | thisModule.resolveMatchedTupleIfExists(Sequence{c, cep}, 'computeEntryPointActionBlock'))
		)
	->append(thisModule.resolveMatchedSingleIfExists(c, 'whichPortActionBlock'))
	->flatten()
;

-- @extends m_Thread_Instance
rule m_ThreadEntrypoint { 
  from	
	c: AADLI!ComponentInstance
	using
	{
		impl : AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
		callSequences: Sequence(AADLBA!SubprogramCallSequence) = if(not c.needsToMapBehaviorAnnex()) then impl.ownedSubprogramCallSequence->select(e|e.isComputeEntryPointOf(c))
																 else Sequence{} endif;
	}
	to
		sub : AADLBA!ThreadSubcomponent mapsTo c,
		entryPointImg: AADLBA!SubprogramType
		(
			name <- c.uniqueName()+'_entrypoint',
			ownedDataAccess <- 	
									c.featureInstance->select(e| e.feature.oclIsTypeOf(AADLI!DataAccess))
									->collect(
											e|thisModule.resolveMatchedSingleIfExists(e, 'f_entrypoint')
										)	
									->union(
										c.featureInstance->select(e| e.isInputFeature())
											->collect(
											e|thisModule.resolveMatchedSingleIfExists(e, 'f_entrypoint')
										)	
									)
									->union(
										c.featureInstance->select(e| e.isOutputFeature())
											->collect
											(
												e| e.srcConnectionInstance->collect(cnxInst| thisModule.resolveMatchedTupleIfExists(Sequence{e, cnxInst.connectionReference->first().connection}, 'f_entrypoint'))
											)
									)
									->union
									(
										callSequences->collect(behavior | 
											impl.ownedAccessConnection->select(accessCnx | accessCnx.isPartOfCallSequence(behavior))
											->collect
											(
												accessCnx| thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior,accessCnx}, 'dataAccess')
											)
										)
									)
									->append
									(
										thisModule.resolveMatchedTupleIfExists(Sequence{c,impl.getBA()},'currentStateAccess')
									)
									->union
									(
										c.featureInstance->select(fi| fi.feature.oclIsKindOf(AADLI!Port) and fi.isUsedInFresh())
										->collect
										(
											fi| thisModule.createFreshnessIndicatorAccess(fi)
										)
									)
									->union
									(
										callSequences->collect(behavior |
											thisModule.collectPeriodicDelayed_LocalVariablesAccesses(c, behavior)
										)
									)
									->union
									(
										if(c.isSporadicThread()) then
											thisModule.collectSporadicThreadVariablesAccesses(c)
										else
											Sequence{}
										endif
										
									)
									->flatten()->excluding(OclUndefined)->asSet(),
			ownedParameter <- impl.ownedParameterConnection
								->select(e|e.source.connectionEnd.oclIsKindOf(AADLI!DataSubcomponent))
								->collect(e|
									callSequences->collect(behavior |
										thisModule.resolveMatchedTupleIfExists(Sequence{c.componentInstance->any(f|f.subcomponent=e.source.connectionEnd), behavior, e},'featureImg'))
									)
								->union
								(
									impl.ownedParameterConnection
									->select(e|e.destination.connectionEnd.oclIsKindOf(AADLI!DataSubcomponent))
									->collect(e|
										callSequences->collect(behavior |
											thisModule.resolveMatchedTupleIfExists(Sequence{c.componentInstance->any(f|f.subcomponent=e.destination.connectionEnd), behavior, e},'featureImg'))
										)
								)
								->flatten()
			
		),
		entryPointImplImg: AADLBA!SubprogramImplementation
		(
			name <- c.uniqueName()+'_entrypoint.impl',
			ownedRealization<-thisModule.Realization(entryPointImg),
			ownedAnnexSubclause <- Sequence{behaviorAnnex},
			ownedDataSubcomponent <- thisModule.collectCommunicationsLocalVariables(c,impl.ownedSubprogramCallSequence)
												->union
												(
													c.featureInstance->select(e|e.isDataOrEventDataPort())
													->collect
													(
														f| thisModule.resolveMatchedSingleIfExists(f, 'localVariable')
													)
												)
												->union
												(
													thisModule.collectPeriodicDelayed_LocalVariables
													(c,impl.ownedSubprogramCallSequence)
												)
												->append(returnData)
												->union
												(
													if c.isSporadicThread() then
														thisModule.collectSporadicThreadVariables(c)
													else
														Sequence{}
													endif
												)
												->flatten()->excluding(OclUndefined)
		),
		returnData: AADLBA!DataSubcomponent
		(
			name <- c.uniqueName()+'_runtime_call_ret',
			dataSubcomponentType <- thisModule.getRuntimeReturnType()
		),
		callEntryPoint: AADLBA!SubprogramCall
		(
			name<-thisModule.callPrefix().concat('_entrypoint'), -- callEntryPoint in thread Implementation
			calledSubprogram<-entryPointImplImg
		),
		callSequenceImg: AADLBA!SubprogramCallSequence 
		(
			name <- 'main_call',
			ownedSubprogramCall <- Sequence{callEntryPoint}
		),
		behaviorAnnex: AADLBA!BehaviorAnnex
		(
			name        <- 'behavior_specification',
			states      <- Sequence{initState,waitDispatchState,execState,finalState},
			transitions <- (if(c.needsToMapBehaviorAnnex()) then
								thisModule.collectBAEntryPointTransitions(c)
							else
								thisModule.collectComputeEntryPointTransitions(c)
							endif
							)->union(Sequence{whichPortTransition,dispatchTransition})
							->flatten(),
			actions		<- Sequence{dispatch_actionBlock}->union(
										if(c.needsToMapBehaviorAnnex()) then
											thisModule.collectBAEntryPointActionBlocks(c)
										else
											thisModule.collectComputeEntryPointActionBlocks(c)
										endif
									),
			variables   <- if(not c.subcomponent.classifier.getBA().oclIsUndefined()) then
								c.subcomponent.classifier.getBA().variables
							else
								Sequence{}
							endif
							->union(
								thisModule.collectBehaviorVariable(c)
							)
							->flatten()
							->append(activatedPort)
		),
		activatedPort: AADLBA!BehaviorVariable
		(
			name <- 'whichPortActivated',
			dataClassifier <- whichPortActivatedDataDlassifier
		),
		whichPortActivatedDataDlassifier: AADLBA!DataType
		(
			name <- c.uniqueName()+'_behaviorIdentifier_enum',
			ownedPropertyAssociation <- Sequence {
												
												thisModule.CreatePropertyAssociation
												(
												 	'Data_Representation',
													'DATA_MODEL',
													'Enum'.asEnumeration('DATA_MODEL').asNamedValue()
												),
												thisModule.CreatePropertyAssociation
												(
												 	'Enumerators',
													'DATA_MODEL',
													 thisModule.CreateListValueFromListOfString(Sequence{'default_behavior'}->union(c.featureInstance->select(fi|fi.isInputFeature())->collect(e|e.name)))
												),
												thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL',lv)
									}
		),
		lv: AADLBA!ListValue
		(
			ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression(c.targetPackagePrefix()+c.uniqueName()+'_behaviorIdentifier_enum'.concat('_').concat('default_behavior'))}
		),
		portIDEnumLiteral: AADLBA!StringLiteral
		(
			value <- 'default_behavior'
		),
		execState: AADLBA!BehaviorState
		(
			initial  <- false,
			final    <- false,
			complete <- false,
			name <- 'BA_entrypoint_exec_state'
		),
		whichPortTransition: AADLBA!BehaviorTransition
		(
			name <- 'which_behavior_default_mode',
			sourceState <- initState,
			destinationState <- execState,
			actionBlock <- whichPortActionBlock
		),
		whichPortActionBlock: AADLBA!BehaviorActionBlock
		(content<-whichPortActions),
		whichPortActions: AADLBA!BehaviorActionSequence
		( 
			actions <- Sequence{updateDefaultBehaviorAction}
						->union(thisModule.collectThreadInitActions(c))
		),
		
		-- create action to activate default behavior
		
		updateDefaultBehaviorAction: AADLBA!AssignmentAction
		(
			target <- updateDefaultBehaviorVariableHolder,
			valueExpression <- updateDefaultBehaviorValueExpression
		),
		updateDefaultBehaviorVariableHolder: AADLBA!BehaviorVariableHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(c, 'activatedPort')
		),
		updateDefaultBehaviorValueExpression: AADLBA!ValueExpression
		(
			relations <- Sequence{updateDefaultBehaviorRelation}
		),
		updateDefaultBehaviorRelation: AADLBA!Relation
		(
			relationalOperator<-#None,
			firstExpression<-updateDefaultBehaviorExpression
		),
		updateDefaultBehaviorExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{updateDefaultBehaviorTerm}
		),
		updateDefaultBehaviorTerm: AADLBA!Term
		(
			factors <- Sequence{updateDefaultBehaviorFactor}
		),
		updateDefaultBehaviorFactor: AADLBA!Factor
		(
			firstValue <- updateDefaultBehavior
		),
		updateDefaultBehavior: AADLBA!BehaviorEnumerationLiteral
		(
			component <- whichPortActivatedDataDlassifier,
			enumLiteral <- portIDEnumLiteral
		),
		
		initState: AADLBA!BehaviorState
		(
			initial  <- true,
			final    <- false,
			complete <- false,
			name     <- 'BA_entrypoint_init_state'
		),
		waitDispatchState: AADLBA!BehaviorState
		(
			initial  <- false,
			final    <- false,
			complete <- false,
			name     <- 'BA_entrypoint_wait_dispatch_state'
		),
		finalState: AADLBA!BehaviorState
		(
			initial  <- false,
			final    <- true,
			complete <- false,
			name     <- 'BA_entrypoint_final_state'
		),
		dispatchTransition: AADLBA!BehaviorTransition
		(
			name <- 'dispatch_transition',
			destinationState  <- execState,
			sourceState       <- waitDispatchState,
			actionBlock <- dispatch_actionBlock
		),
		dispatch_actionBlock: AADLBA!BehaviorActionBlock
		(content<-dispatch_target_actions),
		dispatch_target_actions: AADLBA!BehaviorActionSequence
		( 
			actions <- c.collectDispatchActions()
		)
	do
	{
		thisModule.addImportedUnit(thisModule.public(), 'DATA_MODEL', 'Data_Model');
	}
}

helper context AADLI!ComponentInstance def: collectDispatchActions():Sequence(AADLBA!BehaviorAction) = 
	if(self.isSporadicThread()) then thisModule.collectSporadicBehaviorActions(self) else Sequence{thisModule.resolveMatchedSingleIfExists(self,'waitDispatchCall')} endif
		->union(
				self.featureInstance->select(fi| 
					fi.isInputFeature() and
					(fi.isEventPort() or fi.isEventDataPort())
			)
			->collect(fi|thisModule.createReceiveInputCall(fi))
		)
		->union(thisModule.collectTransitionChoiceActions(self))->excluding(OclUndefined)
;

unique lazy rule createReceiveInputCall
{
	from
		fi:AADLI!FeatureInstance
}

unique lazy rule collectTransitionChoiceActions
{
	from
		c: AADLI!ComponentInstance
	using
	{
		orderedPorts : Sequence(AADLI!FeatureInstance) = thisModule.theHOOK.getFeaturesOrderedByCriticality(c);
		checkforMessageAction: AADLBA!IfStatement = OclUndefined;
		results : Sequence(AADLI!BehaviorActions) = Sequence{};
	}
	do
	{
		if(not orderedPorts->select(port | c.subcomponent.classifier.ownedSubprogramCallSequence->exists(b | b.isComputeEntryPointOf(port) ) )->isEmpty()) 
		{
			for(port in orderedPorts->select(port | c.subcomponent.classifier.ownedSubprogramCallSequence->exists(b | b.isComputeEntryPointOf(port))))
			{
				for(b in c.subcomponent.classifier.ownedSubprogramCallSequence->select(b | b.isComputeEntryPointOf(port)))
				{
					checkforMessageAction <- thisModule.resolveMatchedTupleIfExists(Sequence{port, b},'checkforMessageAction');
					if(not orderedPorts->first().equals(port))
						checkforMessageAction.elif<-true;
					results<-results.including(thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'getCountAction'));
					results<-results.including(thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'count_assignement'));
					results<-results.including(checkforMessageAction);
					if(orderedPorts->last().equals(port))
						checkforMessageAction.elseStatement<-thisModule.createDefaultAssignement(c);
				}
			}
		}
		results;
	}
}

rule createDefaultAssignement(c:AADLI!ComponentInstance)
{
	to
		seq: AADLBA!BehaviorActionSequence
		(
			actions<-Sequence{updateDefaultBehaviorAction}
		),
		updateDefaultBehaviorAction: AADLBA!AssignmentAction
		(
			target <- updateDefaultBehaviorVariableHolder,
			valueExpression <- updateDefaultBehaviorValueExpression
		),
		updateDefaultBehaviorVariableHolder: AADLBA!BehaviorVariableHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(c, 'activatedPort')
		),
		updateDefaultBehaviorValueExpression: AADLBA!ValueExpression
		(
			relations <- Sequence{updateDefaultBehaviorRelation}
		),
		updateDefaultBehaviorRelation: AADLBA!Relation
		(
			relationalOperator<-#None,
			firstExpression<-updateDefaultBehaviorExpression
		),
		updateDefaultBehaviorExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{updateDefaultBehaviorTerm}
		),
		updateDefaultBehaviorTerm: AADLBA!Term
		(
			factors <- Sequence{updateDefaultBehaviorFactor}
		),
		updateDefaultBehaviorFactor: AADLBA!Factor
		(
			firstValue <- updateDefaultBehavior
		),
		updateDefaultBehavior: AADLBA!BehaviorEnumerationLiteral
		(
			component <- thisModule.resolveMatchedSingleIfExists(c, 'whichPortActivatedDataDlassifier'),
			enumLiteral <- thisModule.resolveMatchedSingleIfExists(c, 'portIDEnumLiteral')
		),
		res: AADLBA!ElseStatement
		(
			behaviorActions <- seq
		)
	do
	{
		res;
	}
}

--helper def: collectTransitionChoiceActions(c: AADLI!ComponentInstance) : Sequence(AADLBA!BehaviorActions)=
--	let orderedPorts : Sequence(AADLI!FeatureInstance) = thisModule.theHOOK.getFeaturesOrderedByCriticality(c) in
--	if(orderedPorts->select(port | c.subcomponent.classifier.ownedSubprogramCallSequence->exists(b | b.isComputeEntryPointOf(port) ) )->isEmpty()) then
--		Sequence{thisModule.resolveMatchedSingleIfExists(c, 'updateDefaultBehaviorAction')}
--	else
--		orderedPorts->select(port | c.subcomponent.classifier.ownedSubprogramCallSequence->exists(b | b.isComputeEntryPointOf(port)))
--				->collect(port | 
--					c.subcomponent.classifier.ownedSubprogramCallSequence->select(b | b.isComputeEntryPointOf(port))
--					->collect(
--						b|
--							Sequence{
--								thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'getCountAction'),
--								thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'count_assignement'),
--								thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'checkforMessageAction')
--							}
--					)
--				)
--				->flatten()
--	endif
--;

helper def: collectBehaviorVariable(c: AADLI!ComponentInstance): Sequence(AADLBA!BehaviorVariable) =
	let orderedPorts : Sequence(AADLI!FeatureInstance) = thisModule.theHOOK.getFeaturesOrderedByCriticality(c) in
	orderedPorts->select(port | c.subcomponent.classifier.ownedSubprogramCallSequence->exists(b | b.isComputeEntryPointOf(port)))
				->collect(port | 
					c.subcomponent.classifier.ownedSubprogramCallSequence->select(b | b.isComputeEntryPointOf(port))
					->collect(
						b|
							Sequence{
								thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'count_variable'),
								thisModule.resolveMatchedTupleIfExists(Sequence{port, b}, 'status_variable')
							}
					)
				)
				->flatten()
;
	
abstract rule m_ThreadBehavior
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!Element
		(
			c.category=#thread 
		)
	using
	{
		impl : AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
	}
	to
		computeEntryPointTransition: AADLBA!BehaviorTransition
		(
			name <- behavior.name,
			sourceState <- thisModule.resolveMatchedSingleIfExists(c, 'execState'),
			destinationState <- thisModule.resolveMatchedSingleIfExists(c, 'waitDispatchState'), --- TODO: add 'if(c.modeInstance->isEmpty()) ... else ... endif
			actionBlock <- computeEntryPointActionBlock,
			condition <- thisModule.createComputeEntryPointConditionForComponent(c),
			priority <- 0.longValue()
		),
		computeEntryPointActionBlock: AADLBA!BehaviorActionBlock
		(content<-computeEntryPointActions),
		computeEntryPointActions: AADLBA!BehaviorActionSequence
}

lazy abstract rule createComputeEntryPointCondition
{
	from
		object: AADLI!InstanceObject
	to
		computeEntryPointCondition: AADLBA!ValueExpression
		(
			relations <- Sequence{comparisonRelation}
		),
		comparisonRelation: AADLBA!Relation
		(
			relationalOperator<-#Equal,
			firstExpression<-behaviorIdentifiverValueExpression,
			secondExpression<-portIDExpression
		),
		behaviorIdentifiverValueExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{behaviorIdentifiverValueTerm}
		),
		behaviorIdentifiverValueTerm: AADLBA!Term
		(
			factors <- Sequence{behaviorIdentifiverValueFactor}
		),
		behaviorIdentifiverValueFactor: AADLBA!Factor
		(
			firstValue <- behaviorIdentifiverValueHolder
		),
		behaviorIdentifiverValueHolder: AADLBA!BehaviorVariableHolder,
		
		portIDExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{portIDTerm}
		),
		portIDTerm: AADLBA!Term
		(
			factors <- Sequence{portIDFactor}
		),
		portIDFactor: AADLBA!Factor
		(
			firstValue <- portIDEnum
		),
		portIDEnum: AADLBA!BehaviorEnumerationLiteral,
		portIDEnumLiteral: AADLBA!StringLiteral
	do
	{
		computeEntryPointCondition;
	}
}

-- @extends createComputeEntryPointCondition
unique lazy rule createComputeEntryPointConditionForPort
{
	from
		object: AADLI!FeatureInstance
	to
		computeEntryPointCondition: AADLBA!ValueExpression,
		portIDEnumLiteral: AADLBA!StringLiteral
		(
			value <- object.name
		),
		behaviorIdentifiverValueHolder: AADLBA!BehaviorVariableHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(object.getComponentInstance(), 'activatedPort')
		),
		portIDEnum: AADLBA!BehaviorEnumerationLiteral
		(
			component <- thisModule.resolveMatchedSingleIfExists(object.getComponentInstance(), 'whichPortActivatedDataDlassifier'),
			enumLiteral <- portIDEnumLiteral
		)
	do
	{
		computeEntryPointCondition;
	}
}
-- @extends createComputeEntryPointCondition
lazy rule createComputeEntryPointConditionForComponent
{
	from
		object: AADLI!ComponentInstance
	to
		computeEntryPointCondition: AADLBA!ValueExpression,
		behaviorIdentifiverValueHolder: AADLBA!BehaviorVariableHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(object, 'activatedPort')
		),
		portIDEnum: AADLBA!BehaviorEnumerationLiteral
		(
			component <- thisModule.resolveMatchedSingleIfExists(object, 'whichPortActivatedDataDlassifier'),
			enumLiteral <- thisModule.resolveMatchedSingleIfExists(object, 'portIDEnumLiteral')
		)
	do
	{
		computeEntryPointCondition;
	}
}

rule m_PortBehavior
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence
		(
			fi.getComponentInstance().category=#thread
			and
			behavior.isComputeEntryPointOf(fi)
			and
			behavior.modesIsComputeEntryPointOf(fi)->isEmpty()
		)
	using
	{
		c: AADLI!ComponentInstance = fi.getComponentInstance();
		orderedPorts: AADLI!FeatureInstance = thisModule.theHOOK.getFeaturesOrderedByCriticality(c);
		fiIndex: Integer = orderedPorts->indexOf(fi);
	}
	to
		-- ports image connections
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- fi.name+'_accessCnx_'+behavior.name,
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.getFeatureImg()
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveMatchedSingleIfExists(fi, 'f_entrypoint')
		),
		
		-- Behavior for selectioning port behavior
		computeEntryPointTransition: AADLBA!BehaviorTransition
		(
			name <- behavior.name,
			sourceState <- thisModule.resolveMatchedSingleIfExists(c, 'execState'), --- TODO: add 'if(c.modeInstance->isEmpty()) ... else ... endif
			destinationState <- thisModule.resolveMatchedSingleIfExists(c, 'waitDispatchState'),
			actionBlock <- computeEntryPointActionBlock,
			condition <- thisModule.createComputeEntryPointConditionForPort(fi),
			priority <- thisModule.theHOOK.getFeaturesOrderedByCriticality(c)->indexOf(fi).longValue()
		),
		computeEntryPointActionBlock: AADLBA!BehaviorActionBlock
		(content<-computeEntryPointActions),
		computeEntryPointActions: AADLBA!BehaviorActionSequence,

		-- 1) IfStatement
		checkforMessageAction: AADLBA!IfStatement
		(
			logicalValueExpression <- checkforMessageExpression,
			behaviorActions <- updateActivatedPortAction
		),
		count_variable: AADLBA!BehaviorVariable, --- TODO: PF dependent definition of dataClassifier field
		getCountValue: AADLBA!BehaviorVariableHolder
		(
			element <- count_variable
		),
		getCountAction: AADLBA!SubprogramCallAction, --- TODO: PF dependent definition of SubprogramCallAction content,
		
		
		checkforMessageExpression: AADLBA!ValueExpression
		(
			relations <- Sequence{checkforMessageRelation}
		),
		checkforMessageRelation: AADLBA!Relation
		(
			relationalOperator<-#NotEqual,
			firstExpression<-getCountExpression,
			secondExpression<-zeroValueConstantExpression
		),
		getCountExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{getCountTerm}
		),
		zeroValueConstantExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{zeroValueConstantTerm}
		),
		zeroValueConstantTerm: AADLBA!Term
		(
			factors <- Sequence{zeroValueConstantFactor}
		),
		zeroValueConstantFactor: AADLBA!Factor
		(
			firstValue <- zeroValueConstant
		),
		zeroValueConstant: AADLBA!BehaviorIntegerLiteral
		(
			value <- 0.longValue()
		),
		getCountTerm: AADLBA!Term
		(
			factors <- Sequence{countFactor}
		),
		countFactor: AADLBA!Factor
		(
			firstValue <- count_variable_holder
		),
		count_variable_holder: AADLBA!BehaviorVariableHolder
		(
			element <- count_variable
		),
		
		updateActivatedPortAction: AADLBA!BehaviorActionSequence
		(
			actions <- Sequence{updateActivatedPortAssignment, thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior}, 'call')}
		),
		-- 2) AssignmentAction
		updateActivatedPortAssignment: AADLBA!AssignmentAction
		(
			target <- updateActivatedPortBehaviorVariableHolder,
			valueExpression <- updateActivatedPortValueExpression
		),
		updateActivatedPortBehaviorVariableHolder: AADLBA!BehaviorVariableHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(c, 'activatedPort')
		),
		updateActivatedPortValueExpression: AADLBA!ValueExpression
		(
			relations <- Sequence{updateActivatedPortRelation}
		),
		updateActivatedPortRelation: AADLBA!Relation
		(
			relationalOperator<-#None,
			firstExpression<-updateActivatedPortExpression
		),
		updateActivatedPortExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{updateActivatedPortTerm}
		),
		updateActivatedPortTerm: AADLBA!Term
		(
			factors <- Sequence{updateActivatedPortFactor}
		),
		updateActivatedPortFactor: AADLBA!Factor
		(
			firstValue <- updateActivatedPort
		),
		updateActivatedPort: AADLBA!BehaviorEnumerationLiteral
		(
			component <- thisModule.resolveMatchedSingleIfExists(c, 'whichPortActivatedDataDlassifier'),
			enumLiteral <- thisModule.resolveLazySingleIfExists(fi, 'createComputeEntryPointConditionForPort', 'portIDEnumLiteral')
		)
		
  	do
  	{
  		destinationCE.setContext(thisModule.resolveMatchedSingleIfExists(fi.getComponentInstance(), 'callEntryPoint'));
		computeEntryPointActions.actions <- thisModule.populateFeatureComputeEntryPointActions(fi, behavior);
  	}
}


rule populateFeatureComputeEntryPointActions (fi: AADLI!FeatureInstance,
										behavior: AADLI!SubprogramCallSequence)
{
	using
	{
		intermediateCallActionSequence: Sequence(AADLBA!BehaviorAction) = Sequence{};
		portsInvoledInCall: Sequence(AADLI!FeatureInstance) = Sequence{};
		c: AADLI!ComponentInstance = fi.getComponentInstance();
	}
	do
	{
		if(fi.isInputFeature() and fi.isEventDataPort() and fi.isPeriodicDelayedPort())
		{
			intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectReceiveInputsCalls(fi, behavior));
		}
		
		if(fi.isInputFeature() and fi.isDataPort())
		{
			intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectDataNextValueCalls(fi,behavior));
		}

		for(call in behavior.ownedSubprogramCall)
		{
			if(fi.isInputFeature() and fi.isEventOrEventDataPort())
			{
				for(paramCnx in c.subcomponent.classifier.ownedParameterConnection->select(paramCnxIter|paramCnxIter.source.context=call and paramCnxIter.destination.connectionEnd = fi.feature))
				{
					intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectDataPutValueCalls(fi,behavior,paramCnx));
				}
				for(paramCnx in c.subcomponent.classifier.ownedParameterConnection->select(paramCnxIter|paramCnxIter.destination.context=call  and paramCnxIter.source.connectionEnd = fi.feature))
				{
					intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectDataPutValueCalls(fi,behavior,paramCnx));
				}
			}
			
			portsInvoledInCall <- thisModule.getPortsInvoledInCall(c,call);
			if(portsInvoledInCall->isEmpty())
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.append
					(
						thisModule.resolveMatchedTupleIfExists(Sequence{fi,behavior,call}, 'subprogramCallAction')
					);
			}
			else
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.append
					(
						thisModule.createCheckedCall
						(
							thisModule.getPortsInvoledInCall(c,call),
							thisModule.resolveMatchedTupleIfExists(Sequence{fi,behavior,call}, 'subprogramCallAction')
						)
					);
			}
			
			if(fi.isOutputFeature() and fi.isEventOrEventDataPort())
			{
				for(paramCnx in c.subcomponent.classifier.ownedParameterConnection->select(paramCnxIter|paramCnxIter.source.context=call and paramCnxIter.destination.connectionEnd = fi.feature))
				{
					for(cnxInst in fi.srcConnectionInstance)
					{
						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(fi, behavior, paramCnx, cnxInst));
					}
				}
				for(paramCnx in c.subcomponent.classifier.ownedParameterConnection->select(paramCnxIter|paramCnxIter.destination.context=call  and paramCnxIter.source.connectionEnd = fi.feature))
				{
					for(cnxInst in fi.srcConnectionInstance)
					{
						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(fi, behavior, paramCnx, cnxInst));
					}
				}
				for(portCnx in c.subcomponent.classifier.ownedPortConnection->select(portCnxIter|portCnxIter.source.context=call  and portCnxIter.destination.connectionEnd = fi.feature))
				{
					for(cnxInst in fi.srcConnectionInstance)
					{
						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(fi, behavior, portCnx, cnxInst));
					}
				}
				for(portCnx in c.subcomponent.classifier.ownedPortConnection->select(portCnxIter|portCnxIter.destination.context=call  and portCnxIter.source.connectionEnd = fi.feature))
				{
					for(cnxInst in fi.srcConnectionInstance)
					{
						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(fi, behavior, portCnx, cnxInst));
					}
				}
			}
		}
		if(fi.isOutputFeature() and fi.isDataPort())
		{
			for(cnxInst in fi.srcConnectionInstance)
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectDataPutValueCalls(fi, behavior, cnxInst));
			}
		}
		for(source in c.featureInstance->select(e| e.isOutputFeature() and e.isEventDataPort() and e.isPeriodicDelayedPort()))
		{
			for(cnxInst in fi.srcConnectionInstance)
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.append(thisModule.resolveMatchedTupleIfExists(Sequence{fi, behavior, cnxInst.connectionReference->first().connection} ,'callSendOutput'));
			}
		}
		intermediateCallActionSequence;
	}
}

-- @extends m_ThreadBehavior
rule m_ComputeEntrypointCallSequence { 
  from	
	c: AADLI!ComponentInstance,
	behavior: AADLI!SubprogramCallSequence
	(
		c.category=#thread 
		and 
		behavior.isComputeEntryPointOf(c)
		and
		(not c.subcomponent.subcomponentType.needsToMapBehaviorAnnex())
	)
	using
	{
		impl : AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
	}
	to
		computeEntryPointActions: AADLBA!BehaviorActionSequence
	do
	{
		computeEntryPointActions.actions <- thisModule.populateComputeEntryPointActions(c, behavior);
	}
}


helper def : getPortsInvoledInCall(c: AADLI!ComponentInstance, call: AADLI!SubprogramCall) : Sequence(AADLI!FeatureInstance) = 
	c.featureInstance->select(e| 
		e.isInputFeature() and 
		c.subcomponent.classifier.ownedParameterConnection->exists(paramCnxIter|
			paramCnxIter.source.context=call and 
			paramCnxIter.destination.connectionEnd = e.feature)
	)
	->union(
		c.featureInstance->select(e| 
		e.isInputFeature() and
		c.subcomponent.classifier.ownedParameterConnection->exists(paramCnxIter|
			paramCnxIter.destination.context=call and 
			paramCnxIter.source.connectionEnd = e.feature)
		)
	)
;

rule createCheckedCall(features: Sequence(AADLI!FeatureInstance), checkedCall: AADLBA!BehaviorAction)
{
	to
  		checkedAction: AADLBA!IfStatement
		(
			logicalValueExpression <- checkforMessageExpression,
			behaviorActions <- thisModule.errorsCheckActions(checkedCall)
		),
		checkforMessageExpression: AADLBA!ValueExpression
		(
			relations <- features->collect(e|thisModule.createCheckforMessageExpression(e)),
			logicalOperators <- features->excluding(features->first())->collect(e| #And)
		)
	do
	{
		checkedAction;
	}
}


rule createCheckforMessageExpression(fi: AADLI!FeatureInstance)
{
	using
	{
		RETURN_CODE: AADLBA!DataSubcomponent = thisModule.CreateReturnSubcomponentFromPort(fi);
	}
	to

		checkforMessageRelation: AADLBA!Relation
		(
			relationalOperator<-#Equal,
			firstExpression<-getCountExpression,
			secondExpression<-noErrorValueConstantExpression
		),
		getCountExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{getCountTerm}
		),
		noErrorValueConstantExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{noErrorValueConstantTerm}
		),
		noErrorValueConstantTerm: AADLBA!Term
		(
			factors <- Sequence{noErrorValueConstantFactor}
		),
		noErrorValueConstantFactor: AADLBA!Factor
		(
			firstValue <- thisModule.createNoErrorValueConstant()
		),
		getCountTerm: AADLBA!Term
		(
			factors <- Sequence{countFactor}
		),
		countFactor: AADLBA!Factor
		(
			firstValue <- count_variable_holder
		),
		count_variable_holder: AADLBA!DataSubcomponentHolder
		(
			element <- RETURN_CODE
		)
	do
	{
		checkforMessageRelation;
	}
}

rule createNoErrorValueConstant()
{
	to
		noErrorValueConstant: AADLBA!BehaviorIntegerLiteral
		(
			value <- 0.longValue()
		)
	do
	{
		noErrorValueConstant;
	}
}


rule errorsCheckActions(checkedCall: AADLBA!SubprogramCallAction)
{
	to
		errorsCheckActions: AADLBA!BehaviorActionSequence
		(
			actions <- Sequence{checkedCall}
		)
		
	do
	{
		errorsCheckActions;
	}
}



rule populateComputeEntryPointActions (c: AADLI!ComponentInstance,
										behavior: AADLI!SubprogramCallSequence)
{
	using
	{
		intermediateCallActionSequence: Sequence(AADLBA!SubprogramCallAction) = Sequence{};
		portsInvoledInCall: Sequence(AADLI!FeatureInstance) = Sequence{};
	}
	do
	{
		for(destination in c.featureInstance->select(e| e.isInputFeature() and e.isEventDataPort() and e.isPeriodicDelayedPort()))
		{
			intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectReceiveInputsCalls(destination, behavior));
		}
		
		for(destination in c.featureInstance->select(e| e.isInputFeature() and e.isDataPort()))
		{
			intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectDataNextValueCalls(destination, behavior));
		}

		for(call in behavior.ownedSubprogramCall)
		{
			for(destination in c.featureInstance->select(e| e.isInputFeature() and e.isEventOrEventDataPort()))
			{
				for(paramCnx in c.subcomponent.classifier.ownedParameterConnection->select(paramCnxIter|paramCnxIter.source.context=call and paramCnxIter.destination.connectionEnd = destination.feature))
				{
					intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataNextValueCalls(destination, behavior, paramCnx));
				}
				for(paramCnx in c.subcomponent.classifier.ownedParameterConnection->select(paramCnxIter|paramCnxIter.destination.context=call  and paramCnxIter.source.connectionEnd = destination.feature))
				{
					intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataNextValueCalls(destination, behavior, paramCnx));
				}
			}
			portsInvoledInCall <- thisModule.getPortsInvoledInCall(c,call);
			if(portsInvoledInCall->isEmpty())
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.append
					(
						thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior,call}, 'subprogramCallAction')
					);
			}
			else
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.append
					(
						thisModule.createCheckedCall
						(
							thisModule.getPortsInvoledInCall(c,call),
							thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior,call}, 'subprogramCallAction')
						)
					);
			}
			
			for(source in c.featureInstance->select(e| e.isOutputFeature() and e.isEventOrEventDataPort()))
			{
				for(paramCnx in c.subcomponent.classifier.ownedParameterConnection->select(paramCnxIter|paramCnxIter.source.context=call and paramCnxIter.destination.connectionEnd = source.feature))
				{
					for(cnxInst in source.srcConnectionInstance)
					{
						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(source, behavior, paramCnx, cnxInst));
					}
				}
				for(paramCnx in c.subcomponent.classifier.ownedParameterConnection->select(paramCnxIter|paramCnxIter.destination.context=call  and paramCnxIter.source.connectionEnd = source.feature))
				{
					for(cnxInst in source.srcConnectionInstance)
					{
						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(source, behavior, paramCnx, cnxInst));
					}
				}
				for(portCnx in c.subcomponent.classifier.ownedPortConnection->select(portCnxIter|portCnxIter.source.context=call  and portCnxIter.destination.connectionEnd = source.feature))
				{
					for(cnxInst in source.srcConnectionInstance)
					{
						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(source, behavior, portCnx, cnxInst));
					}
				}
				for(portCnx in c.subcomponent.classifier.ownedPortConnection->select(portCnxIter|portCnxIter.destination.context=call  and portCnxIter.source.connectionEnd = source.feature))
				{
					for(cnxInst in source.srcConnectionInstance)
					{
						intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectEventDataPutValueCalls(source, behavior, portCnx, cnxInst));
					}
				}
			}
		}
		for(source in c.featureInstance->select(e| e.isOutputFeature() and e.isDataPort()))
		{
			for(cnxInst in source.srcConnectionInstance)
			{
				intermediateCallActionSequence <- intermediateCallActionSequence.union(thisModule.collectDataPutValueCalls(source, behavior, cnxInst));
			}
		}
		if (thisModule.Unique_Send_Output_Per_Thread)
		{
			intermediateCallActionSequence <- intermediateCallActionSequence.append(
				thisModule.resolveMatchedSingleIfExists(c,'callSendOutput'));
		}
		else
		{
			for(source in c.featureInstance->select(e| e.isOutputFeature() and e.isEventDataPort() and e.isPeriodicDelayedPort()))
			{
				for(cnxInst in source.srcConnectionInstance)
				{
					intermediateCallActionSequence <- intermediateCallActionSequence.append(thisModule.resolveMatchedTupleIfExists(Sequence{source, behavior, cnxInst.connectionReference->first().connection} ,'callSendOutput'));
				}
			}
		}
		intermediateCallActionSequence;
	}
}

lazy rule CreateParameterHolder
{
	from
		param: AADLBA!Parameter
	to
		holder: AADLBA!ParameterHolder
		(
			element<-param
		)
	do
	{
		holder;
	}
}

lazy rule CreateDataAccessHolder
{
	from
		dataAccess:AADLBA!DataAccess
	to
		holder: AADLBA!DataAccessHolder
		(
			element<-dataAccess
		)
	do
	{
		holder;
	}
}

lazy rule CreateDataSubcomponentHolder
{
	from
		dataSubcomponent:AADLBA!DataSubcomponent
	to
		holder: AADLBA!DataSubcomponentHolder
		(
			element<-dataSubcomponent
		)
	do
	{
		holder;
	}
}

helper context AADLI!SubprogramCall def: getSubprogramClassifier(): AADLI!SubprogramClassifier =
	if(self.calledSubprogram.oclIsKindOf(AADLI!SubprogramClassifier)) then
		self.calledSubprogram
	else if(self.calledSubprogram.oclIsTypeOf(AADLI!SubprogramAccess)) then
			self.calledSubprogram.subprogramFeatureClassifier
		else
			OclUndefined
		endif
	endif
;

lazy rule populateParameterLabels
{
	from
		subprogramCall: AADLI!SubprogramCall,
		behavior: AADLI!SubprogramCallSequence,
		c: AADLI!ComponentInstance 
	using
	{
	 	impl: AADLI!ThreadImplementation = c.subcomponent.classifier;
		intermediateParameterLabelList: Sequence(AADLBA!ElementHolder) = Sequence{};
		orderedFeatures: Sequence(AADLBA!Feature) = Sequence{};
	}
	do
	{
		thisModule.addImportedUnitFromInputModel(thisModule.public(), subprogramCall.calledSubprogram);
  		if(subprogramCall.calledSubprogram.oclIsKindOf(AADLI!SubprogramClassifier))
  		{
  			orderedFeatures <- subprogramCall.calledSubprogram.getOrderedFeature();
  		}
	  	else if(subprogramCall.calledSubprogram.oclIsTypeOf(AADLI!SubprogramAccess))
  		{
  			orderedFeatures <- subprogramCall.calledSubprogram.subprogramFeatureClassifier.getOrderedFeature();
  		}
  		for(feature in orderedFeatures)
  		{
  			if(feature.oclIsTypeOf(AADLI!DataAccess))
 			{
  				for(cnx in impl.ownedAccessConnection->select(e | e.accessCategory = #data and e.source.connectionEnd = feature and behavior.ownedSubprogramCall->exists(f | e.source.context = f)))
				{
  					intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.CreateDataAccessHolder(thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior, cnx}, 'dataAccess')));
				}
  				for(cnx in impl.ownedAccessConnection->select(e | e.accessCategory = #data and e.destination.connectionEnd = feature and behavior.ownedSubprogramCall->exists(f | e.destination.context = f)))
				{
  					intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.CreateDataAccessHolder(thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior, cnx}, 'dataAccess')));
				}
  			}
  			else if(feature.oclIsKindOf(AADLI!Parameter))
  			{
  				for(cnx in impl.ownedParameterConnection->select(e | e.source.connectionEnd = feature and e.source.context = subprogramCall))
				{
					if(cnx.destination.connectionEnd.oclIsTypeOf(AADLI!Parameter))
					{
						intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.Parameter_to_Parameter_Connection(c, behavior, cnx));
					}
					else if(cnx.destination.connectionEnd.oclIsTypeOf(AADLI!DataSubcomponent))
					{
						intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.CreateParameterHolder(thisModule.resolveMatchedTupleIfExists(Sequence{c.componentInstance->any(e|cnx.destination.connectionEnd = e.subcomponent), behavior, cnx}, 'featureImg')));
					}
					else if(cnx.destination.connectionEnd.oclIsKindOf(AADLI!Port))
					{
						intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.resolveMatchedTupleIfExists(Sequence{c.featureInstance->any(e|e.feature = cnx.destination.connectionEnd), behavior, cnx}, 'holder'));
					}
				}
  				for(cnx in impl.ownedParameterConnection->select(e | e.destination.connectionEnd = feature and e.destination.context = subprogramCall))
				{
					if(cnx.source.connectionEnd.oclIsTypeOf(AADLI!Parameter))
					{
						intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.Parameter_to_Parameter_Connection(c, behavior, cnx));
					}
					else if(cnx.source.connectionEnd.oclIsTypeOf(AADLI!DataSubcomponent))
					{
						intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.CreateParameterHolder(thisModule.resolveMatchedTupleIfExists(Sequence{c.componentInstance->any(e|cnx.source.connectionEnd = e), behavior, cnx}, 'featureImg')));
					}
					else if(cnx.source.connectionEnd.oclIsKindOf(AADLI!Port))
					{
						intermediateParameterLabelList <- intermediateParameterLabelList.append(thisModule.resolveMatchedTupleIfExists(Sequence{c.featureInstance->any(e|e.feature = cnx.source.connectionEnd), behavior, cnx}, 'holder'));
					}
				}
  			}
  			
  		}
		intermediateParameterLabelList;
	}
}


rule m_PortSubprogramCall {
  from
	fi: AADLI!FeatureInstance,
	behavior: AADLI!SubprogramCallSequence,
	subprogramCall: AADLI!SubprogramCall
	(behavior.isComputeEntryPointOf(fi))
  using
  {
	c: AADLI!ComponentInstance = fi.getComponentInstance();
	impl: AADLI!ThreadImplementation = c.subcomponent.classifier;
	calledSubprogram : AADLI!SubprogramClassifier = subprogramCall.getSubprogramClassifier();
	intermediateParameterLabelList: Sequence(AADLBA!ElementHolder) = Sequence{};
  }
  to
  	subprogramCallAction: AADLBA!SubprogramCallAction
	(
		subprogram <- callHolder 
	),
	callHolder: AADLBA!CalledSubprogramHolder
	(
		element <- calledSubprogram
	)
  do
  {
	intermediateParameterLabelList <- thisModule.populateParameterLabels(subprogramCall, behavior, c);
  	subprogramCallAction.parameterLabels <- intermediateParameterLabelList;	
  }
}

rule m_ComponentSubprogramCall {
  from
	c: AADLI!ComponentInstance,
	behavior: AADLI!SubprogramCallSequence,
	subprogramCall: AADLI!SubprogramCall
	(behavior.isComputeEntryPointOf(c))
  using
  {
	impl: AADLI!ThreadImplementation = c.subcomponent.classifier;
	intermediateParameterLabelList: Sequence(AADLBA!ElementHolder) = Sequence{};
	calledSubprogram : AADLI!SubprogramClassifier = subprogramCall.getSubprogramClassifier();
  }
  to
  	subprogramCallAction: AADLBA!SubprogramCallAction
	(
		subprogram <- callHolder 
	),
	callHolder: AADLBA!CalledSubprogramHolder
	(
		element <- calledSubprogram
	)
  do
  {
  	intermediateParameterLabelList <- thisModule.populateParameterLabels(subprogramCall, behavior, c);
  	subprogramCallAction.parameterLabels <- intermediateParameterLabelList;	
  }
}

helper context AADLI!ParameterConnection def: isParamToPortConnection(): Boolean =
	self.source.connectionEnd.oclIsTypeOf(AADLI!Port)
	or
	self.destination.oclIsTypeOf(AADLI!Port)
;

helper context AADLI!ParameterConnection def: isParamToParamConnection(): Boolean =
	self.source.connectionEnd.oclIsTypeOf(AADLI!Parameter)
	and
	self.destination.connectionEnd.oclIsTypeOf(AADLI!Parameter)
;

helper context AADLI!AccessConnection def: isAccessToParamConnection(): Boolean = 
	(
		self.source.context.oclIsKindOf(AADLI!SubprogramCall) and self.source.connectionEnd.oclIsTypeOf(AADLI!DataAccess)
	)
	or
	(
		self.destination.context.oclIsKindOf(AADLI!SubprogramCall) and self.destination.connectionEnd.oclIsTypeOf(AADLI!DataAccess)
	)
;

helper context AADLI!Connection def: isPartOfCallSequence(behavior: AADLI!Element): Boolean =
	if(behavior.oclIsKindOf(AADLI!SubprogramCallSequence)) then
		behavior.ownedSubprogramCall->exists(e|self.source.context = e or self.destination.context = e)
	else
		false
	endif
;

abstract rule m_Parameter_to_DataAccess_Connection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		accessCnx: AADLI!AccessConnection
		(
			behavior.isComputeEntryPointOf(c)
		)
	to
		dataAccess: AADLBA!DataAccess
		(
			kind <- #requires
		),
		accessConnection: AADLBA!AccessConnection
		(
			name <- accessCnx.uniqueName()+'_entrypoint',
			accessCategory <- #data,
			source <- ceSource,
			destination <- ceDestination
		),
		ceSource: AADLBA!ConnectedElement
		(connectionEnd <- dataAccess),
		ceDestination: AADLBA!ConnectedElement
}

-- @extends m_Parameter_to_DataAccess_Connection
rule m_Parameter_to_DataAccess_SourceConnection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		accessCnx: AADLI!AccessConnection
		(
			behavior.ownedSubprogramCall->exists(e|accessCnx.source.context = e)
			and
			accessCnx.source.connectionEnd.oclIsKindOf(AADLI!DataAccess)
		)
	using
	{
		callAccess: AADLBA!DataAccess = accessCnx.source.connectionEnd;
	}
	to
		dataAccess: AADLBA!DataAccess
		(
			name <- behavior.name+'_'+callAccess.name+'_entrypoint',
			dataFeatureClassifier <- callAccess.dataFeatureClassifier
		),
		accessConnection: AADLBA!AccessConnection
		(
			name <- accessCnx.uniqueName()+'_entrypoint'
		),
		ceSource: AADLBA!ConnectedElement
		(connectionEnd <- dataAccess),
		ceDestination: AADLBA!ConnectedElement
		(connectionEnd <- accessCnx.destination.connectionEnd)
	do
	{
		ceSource.setContext(thisModule.resolveMatchedSingleIfExists(c,'callEntryPoint'));
	}
}

-- @extends m_Parameter_to_DataAccess_Connection
rule m_Parameter_to_DataAccess_DestinationConnection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		accessCnx: AADLI!AccessConnection
		(
			accessCnx.destination.connectionEnd.oclIsKindOf(AADLI!DataAccess)
			and
			behavior.ownedSubprogramCall->exists(e|accessCnx.destination.context = e)
		)
	using
	{
		callAccess: AADLBA!DataAccess = accessCnx.destination.connectionEnd;
	}
	to
		dataAccess: AADLBA!DataAccess
		(
			name <- behavior.name+'_'+callAccess.name+'_entrypoint',
			dataFeatureClassifier <- callAccess.dataFeatureClassifier
		),
		accessConnection: AADLBA!AccessConnection
		(
			name <- accessCnx.uniqueName()+'_entrypoint'
		),
		ceSource: AADLBA!ConnectedElement
		(connectionEnd <- accessCnx.source.connectionEnd),
		ceDestination: AADLBA!ConnectedElement
		(connectionEnd <- dataAccess)
	do
	{
		ceDestination.setContext(thisModule.resolveMatchedSingleIfExists(c,'callEntryPoint'));
	}
}

rule m_Parameter_to_PortInstance_Connection
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			(paramCnx.source.connectionEnd = fi.feature
			or
			paramCnx.destination.connectionEnd = fi.feature)
			and
			paramCnx.isPartOfCallSequence(behavior)
			and
			behavior.isComputeEntryPointOf(fi.getComponentInstance())
			and
			fi.feature.oclIsKindOf(AADLI!Port)
		)
	to
		holder: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(fi, 'localVariable')
		)
}

abstract rule m_Parameter_to_DataInstance_Connection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			(paramCnx.source.connectionEnd = c.subcomponent
			or
			paramCnx.destination.connectionEnd = c.subcomponent)
			and
			paramCnx.isPartOfCallSequence(behavior)
			and
			behavior.isComputeEntryPointOf(c.getContainingThread())
			and
			c.subcomponent.subcomponentType.oclIsKindOf(AADLI!DataClassifier)
		)
	to
		parameterConnection: AADLBA!ParameterConnection
		(
			name <- paramCnx.name,
			source<-paramConnectedElement,
			destination<-subcomponentConnectedElement
		),
		paramConnectedElement: AADLBA!ConnectedElement
		(
			connectionEnd <- featureImg
		),
		subcomponentConnectedElement: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveMatchedSingleIfExists(c,'sub')
		),
		featureImg: AADLBA!Parameter
		(
			dataFeatureClassifier <- c.subcomponent.subcomponentType 
		)
	do
	{
		paramConnectedElement.setContext(thisModule.resolveMatchedSingleIfExists(c.getContainingThread(), 'callEntryPoint'));
	}
		
}

-- @extends m_Parameter_to_DataInstance_Connection
rule m_Parameter_to_DataInstance_SourceConnection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			paramCnx.source.connectionEnd = c.subcomponent
		)
	to
		featureImg: AADLBA!Parameter
		(
			name <-  paramCnx.uniqueName()+'_'+paramCnx.destination.connectionEnd.name
		)	
}

-- @extends m_Parameter_to_DataInstance_Connection
rule m_Parameter_to_DataInstance_DestinationConnection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			paramCnx.destination.connectionEnd = c.subcomponent
		)
	to
		featureImg: AADLBA!Parameter
		(
			name <-   paramCnx.uniqueName()+'_'+paramCnx.source.connectionEnd.name
		)	
}

rule m_Access_to_DataInstance_Connection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		accessCnx: AADLI!AccessConnection
		(
			(accessCnx.source.connectionEnd = c.subcomponent
			or
			accessCnx.destination.connectionEnd = c.subcomponent)
			and
			accessCnx.isPartOfCallSequence(behavior)
			and
			behavior.isComputeEntryPointOf(c.getContainingThread())
			and
			c.subcomponent.subcomponentType.oclIsKindOf(AADLI!DataClassifier)
		)
	to
		accessCnxConnection: AADLBA!AccessConnection
		(
			name <- accessCnx.name,
			source<-accessConnectedElement,
			destination<-subcomponentConnectedElement
		),
		accessConnectedElement: AADLBA!ConnectedElement,
		subcomponentConnectedElement: AADLBA!ConnectedElement,
		featureImg: AADLBA!DataAccess
		
		
}

rule m_Parameter_to_Parameter_Connection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			paramCnx.isParamToParamConnection()
			and
			paramCnx.isPartOfCallSequence(behavior)
			and
			behavior.isComputeEntryPointOf(c)
		)
	to
		paramCnxVariable: AADLBA!DataSubcomponent
		(
			name <- paramCnx.uniqueName()+'_localVariable',
			dataSubcomponentType <- paramCnx.source.connectionEnd.dataFeatureClassifier
		)
	do
	{
		thisModule.addImportedUnitFromInputModel(thisModule.public(), paramCnx.source.connectionEnd.dataFeatureClassifier);
	}
}

lazy rule Parameter_to_Parameter_Connection
{
	from
		c: AADLI!ComponentInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			paramCnx.isParamToParamConnection()
			and
			paramCnx.isPartOfCallSequence(behavior)
			and
			behavior.isComputeEntryPointOf(c)
		)
	to
		holder: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.resolveMatchedTupleIfExists(Sequence{c,behavior,paramCnx}, 'paramCnxVariable')
		)
	do
	{
		holder;
	}
}

--  	- m_Port_ComputeEntrypointCallSequence: for each pair (call sequence, feature instance)
--  		such that:
--  			feature instance is a thread port
--  			and
--  			call sequence is a compute entrypoint of the owner of the feature instance
--  		produce:
--  			nothing yet
abstract rule m_Port_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence
		(
			fi.isThreadPort()
			and
			behavior.isComputeEntryPointOf(fi.getComponentInstance())
		)
}

--  	- m_Input_Port_ComputeEntrypointCallSequence extends m_Port_ComputeEntrypointCallSequence: for each pair (call sequence, feature instance)
--  		such that:
--  			feature instance is an input port
--  		produce:
--  			nothing yet

--connexion
-- @extends m_Port_ComputeEntrypointCallSequence
rule m_Input_Port_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence
		(
			fi.isInputFeature()
		)
	to
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- fi.name+'_accessCnx_'+behavior.name,
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.getFeatureImg()
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveMatchedSingleIfExists(fi, 'f_entrypoint')
		)
	do
	{
		destinationCE.setContext(thisModule.resolveMatchedSingleIfExists(fi.getComponentInstance(), 'callEntryPoint'));
	}
}

-- @extends m_Input_Port_ComputeEntrypointCallSequence
abstract rule m_Input_EventOrEventDataPort_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			fi.isInputFeature()
			and
			(fi.isEventPort() or fi.isEventDataPort())
			and
			(paramCnx.source.connectionEnd = fi.feature
				or
				paramCnx.destination.connectionEnd = fi.feature)
		)
}




--  	- m_Input_EventPort_ComputeEntrypointCallSequence extends m_Input_Port_ComputeEntrypointCallSequence: for each tuple (call sequence, feature instance, parameter connection)
--  		such that
--  			feature instance is an event port
--  			parameter connection source is the feature instance
--  		produce
--  			(i) a subprogram call getValue
--  			(ii) a connection from image f of feature instance to parameter of getValue
--  			(iii) a connection from image localVariable of feature instance to parameter of getValue

-- @extends m_Input_EventOrEventDataPort_ComputeEntrypointCallSequence
abstract rule m_Input_EventPort_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			fi.isEventPort()
		)
}

--  	- m_Input_EventDataPort_ComputeEntrypointCallSequence extends m_Input_Port_ComputeEntrypointCallSequence
--  		such that
--  			feature instance is an event port
--  			parameter connection source is the feature instance
--  		produce
--  			(i) a subprogram call getValue
--  			(ii) a connection from image f of feature instance to parameter of getValue
--  			(iii) a connection from image localVariable of feature instance to parameter of getValue

-- @extends m_Input_EventOrEventDataPort_ComputeEntrypointCallSequence,m_Parameter_to_PortInstance_Connection
rule m_Input_EventDataPort_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection
		(
			fi.isEventDataPort()
		)
}

--  	- m_Input_DataPort_ComputeEntrypointCallSequence extends m_Input_Port_ComputeEntrypointCallSequence: for each pair (call sequence, feature instance)
--  		such that:
--  			feature instance is a data port
--  		produce:
--  			(i) a subprogram call getValue
--  			(ii) a connection from image f of feature instance to parameter of getValue
--  			(iii) a connection from image localVariable of feature instance to parameter of getValue

-- @extends m_Input_Port_ComputeEntrypointCallSequence
rule m_Input_DataPort_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence
		(
			fi.isDataPort()
		)
	to
		call:AADLBA!SubprogramCallAction
}


--  	- m_Output_Port_ComputeEntrypointCallSequence extends m_Port_ComputeEntrypointCallSequence: for each tuple (call sequence, feature instance, connection instance)
--  		such that:
--  			feature instance is an output port
--  			and
--  			feature instance is the source of the connection instance

-- @extends m_Port_ComputeEntrypointCallSequence
rule m_Output_Port_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		cnxRef: AADLI!PortConnection
		(
			fi.isOutputFeature()
			and
			fi.srcConnectionInstance->exists(e|e.connectionReference->exists(cnx| cnx.connection = cnxRef))
		)
	to
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- fi.name+'_accessCnx_'+behavior.name,
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveMatchedTupleIfExists(Sequence{fi,cnxRef},'f')
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveMatchedTupleIfExists(Sequence{fi,cnxRef}, 'f_entrypoint')
		)
	do
	{
		destinationCE.setContext(thisModule.resolveMatchedSingleIfExists(fi.getComponentInstance(), 'callEntryPoint'));
	}
}

--  	- m_Output_EventOrEventDataPort_ComputeEntrypointCallSequence extends m_Output_Port_ComputeEntrypointCallSequence: for each tuple (call sequence, feature instance, parameter connection, connection instance)
--  		such that:
--  			feature instance is the source of connection instance
--  			feature instance is an event data port
--  		produce:
--  			(i) a subprogram call putValue
--  			(ii) a connection from image f of feature instance to parameter of putValue
--  			(iii) a connection from image localVariable of feature instance to parameter of putValue

-- @extends m_Port_ComputeEntrypointCallSequence
rule m_Output_EventOrEventDataPort_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		paramCnx: AADLI!ParameterConnection,
		cnxRef: AADLI!PortConnection		
		(
			fi.isOutputFeature()
			and
			(fi.isEventPort() or fi.isEventDataPort())
			and
			(cnxRef.source.connectionEnd = fi.feature)
			and
			(paramCnx.source.connectionEnd = fi.feature
				or
				paramCnx.destination.connectionEnd = fi.feature)
			and
			fi.srcConnectionInstance->exists(e| e.connectionReference.first().connection = cnxRef)
		)
	to
		call: AADLBA!SubprogramCallAction
}


--  	- m_Output_EventPort : for each tuple (call sequence, feature instance, port connection, connection instance)
--  		such that:
--  			feature instance is the source of a connection instance
--  			feature instance is an event port
--				feature instance is the dest of a port connection with a subprogram feature
--  		produce:
--  			(i) a subprogram call putValue
--  			(ii) a connection from image f of feature instance to parameter of putValue
--  			(iii) a connection from image localVariable of feature instance to parameter of putValue

rule m_Output_EventPort
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		portCnx: AADLI!PortConnection,
		cnxRef: AADLI!PortConnection		
		(
			fi.isOutputFeature() and fi.isEventPort()
			and
			(cnxRef.source.connectionEnd = fi.feature)
			and
			portCnx.destination.connectionEnd = fi.feature
			and
			(behavior.ownedSubprogramCall->exists(e| portCnx.source.context = e))
		)
	to
		call: AADLBA!SubprogramCallAction
}

--  	- m_Output_DataPort_ComputeEntrypointCallSequence extends m_Output_Port_ComputeEntrypointCallSequence: for each tuple (call sequence, feature instance, connection instance)
--  	  	such that:
--  			feature instance is a data port
--  		produce:
--  			(i) a subprogram call putValue
--  			(ii) a connection from image f of feature instance to parameter of putValue
--  			(iii) a connection from image localVariable of feature instance to parameter of putValue

-- @extends m_Output_Port_ComputeEntrypointCallSequence
rule m_Output_DataPort_ComputeEntrypointCallSequence
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!SubprogramCallSequence,
		cnxRef: AADLI!PortConnection		
		(
			fi.isDataPort()
			and
			(cnxRef.source.connectionEnd = fi.feature
				or cnxRef.destination.connectionEnd = fi.feature)
		)
}



-----------------------------------------------------------------
--- End of refactoring
-----------------------------------------------------------------









unique lazy rule createSubprogramCallSequence {
 from
 	implImg: AADLBA!ThreadImplementation
 to
	seq: AADLBA!SubprogramCallSequence(
			name <- 'callSeq_Default'
		)
}

unique lazy rule mapComputeEntrypoint
{
	from
		implImg : AADLBA!ComponentImplementation,
		c : AADLI!ComponentInstance,
		impl : AADLI!ComponentImplementation
	using
	{
		callImg : AADLBA!SubprogramCall = OclUndefined;
		fi: AADLI!FeatureInstance = c.featureInstance->any(e|e.name = impl.type.ownedEventPort->first().name);
		calledSubprogram: AADLBA!SubprogramClassifier = OclUndefined;
		referencedSubprogram: AADLI!Subprogram = impl.behaviorFromComputeEntryPoint();
	}
	to
		seq: AADLBA!SubprogramCallSequence(
			name <- 'callSeq_'+referencedSubprogram.name
		),
		call : AADLBA!SubprogramCall (
			name <- 'call_'+referencedSubprogram.name,
			calledSubprogram <- referencedSubprogram
		)
	do
	{
		
--		if(not impl.type.ownedEventPort->first().getModalPropertyValue('Compute_Entrypoint').oclIsUndefined())
--		{
--			thisModule.addNextValueSubprogramCall(seq, impl, implImg, fi);
--		}
--		seq.ownedSubprogramCall->add(call);
--		if (referencedSubprogram.oclIsKindOf(AADLI!SubprogramType))
--			call.calledSubprogram <- thisModule.Type(OclUndefined,referencedSubprogram);
--		else if(referencedSubprogram.oclIsKindOf(AADLI!SubprogramImplementation))
--			call.calledSubprogram <- thisModule.Implementation(OclUndefined,referencedSubprogram, thisModule.Type(OclUndefined,referencedSubprogram.getOwnedRealization().implemented));
--		seq;
	}
}

--rule mapInputParameterConnection(s2 : AADLBA!SubprogramCallSequence,
--								 impl : AADLI!ComponentImplementation,
--								 implImg : AADLBA!ComponentImplementation,
--								 call : AADLI!SubprogramCall,
--								 calledSubprogram: AADLBA!SubprogramClassifier,
--								 c : AADLI!ComponentInstance)
--{
--	do
--	{
--		for(paramCnx in impl.ownedParameterConnection)
--		{
--			if(paramCnx.destination.getContext() = call 
--					and calledSubprogram.ownedParameter.contains(paramCnx.destination.connectionEnd)
--					and paramCnx.destination.connectionEnd.isInputFeature())
--			{
--				thisModule.mapEachInputParameterConnection(paramCnx, s2, impl, implImg, c);
--			}
--		}
--	}	
--}
--
--rule mapEachInputParameterConnection(paramCnx: AADLBA!ParameterConnection,
--									  s2 : AADLBA!SubprogramCallSequence,
--								  	  impl : AADLI!ComponentImplementation,
--								      implImg : AADLBA!ComponentImplementation,
--								      c : AADLI!ComponentInstance)
--{
--	using
--	{
--		fi: AADLI!FeatureInstance = c.featureInstance->any(e|e.name = paramCnx.source.connectionEnd.name);
--	}
--	do
--	{
--		if(not fi.oclIsUndefined())
--		{
--			if(fi.feature.oclIsKindOf(AADLI!Port))
--			{
--				thisModule.addNextValueSubprogramCall(s2, impl, implImg, fi);
--			}
--	 	}
--	}
--}
--
--rule mapOutputParameterConnection(s2 : AADLBA!SubprogramCallSequence,
--								 impl : AADLI!ComponentImplementation,
--								 implImg : AADLBA!ComponentImplementation,
--								 call : AADLI!SubprogramCall,
--								 calledSubprogram: AADLBA!SubprogramClassifier,
--								 c : AADLI!ComponentInstance)
--{
--	do
--	{
--		for(paramCnx in impl.ownedParameterConnection)
--		{
--			if(paramCnx.source.getContext() = call 
--					and calledSubprogram.ownedParameter.contains(paramCnx.source.connectionEnd)
--					and paramCnx.source.connectionEnd.isOutputFeature())
--			{
--				thisModule.mapEachOutputParameterConnection(paramCnx, s2, impl, implImg, c);
--			}
--		}
--	}
--}
--
--rule mapEachOutputParameterConnection(paramCnx: AADLBA!ParameterConnection,
--									  s2 : AADLBA!SubprogramCallSequence,
--								  	  impl : AADLI!ComponentImplementation,
--								      implImg : AADLBA!ComponentImplementation,
--								      c : AADLI!ComponentInstance)
--{
--	using
--	{
--		fi: AADLI!FeatureInstance = c.featureInstance->any(e|e.name = paramCnx.destination.connectionEnd.name);
--	}
--	do
--	{
--		if(not fi.oclIsUndefined())
--		{
--			if(fi.feature.oclIsKindOf(AADLI!Port))
--			{
--				thisModule.addPutValueSubprogramCall(s2, impl, implImg, fi);
--			}
--		}
--	}
--}

--unique lazy rule mapCallSequence
--{
--	from
--		implImg : AADLBA!ComponentImplementation,
--		c : AADLI!ComponentInstance,
--		impl : AADLI!ComponentImplementation
--	to
--		s2 : AADLBA!SubprogramCallSequence (
--			name <- impl.behaviorFromImpl().name,
--			ownedSubprogramCall <- impl.behaviorFromImpl().ownedSubprogramCall
--										->collect(e| thisModule.SubprogramCall(c, e, impl, implImg))
--		)
--		
--	do
--	{
--		impl.behaviorFromImpl().debug('  copy call sequence');
--		thisModule.ThreadSubprogramCallSequence <- s2;
--		for(call in thisModule.getThreadSubprogramCallSequence().ownedSubprogramCall)
--		{
--			
--			-- if an in parameter is connected to an input port
--			-- we must call next_value here
--			
--			thisModule.mapInputParameterConnection(thisModule.ThreadSubprogramCallSequence, impl, implImg, call, thisModule.getCalledSubprogram(call), c);
--			
--			thisModule.ThreadSubprogramCallSequence <- thisModule.ThreadSubprogramCallSequence->including(call);
--			-- if an ou parameter is connected to an in data port or event data port
--			-- we must call put_value here
--			
--			thisModule.mapOutputParameterConnection(thisModule.ThreadSubprogramCallSequence, impl, implImg, call, thisModule.getCalledSubprogram(call), c);
--			
--			call.debug('  copy subprogram call');
--		}
--		s2.ownedSubprogramCall <- thisModule.getThreadSubprogramCallSequence().ownedSubprogramCall;
--		s2;
--	}
--}

helper def:getCalledSubprogram(call: AADLBA!SubprogramCall) : AADLBA!SubprogramClassifier =
	if(call.calledSubprogram.oclIsKindOf(AADLBA!SubprogramAccess)) then
		call.calledSubprogram.subprogramFeatureClassifier
	else
		call.calledSubprogram
	endif
;

helper def: ports_constantValue: Sequence(AADLBA!StringLiteral) = OclUndefined;
helper def: ports_constantValueParameters: Sequence(AADLBA!StringLiteral) = OclUndefined;
helper def: ports_parameterConstantValue: String = '';


--rule SubprogramCall (c: AADLI!ComponentInstance,
--					 s : AADLI!SubprogramCall, 
--					 impl : AADLI!ComponentImplementation, 
--					 implImg : AADLBA!ComponentImplementation) {
--	to
--		s2 : AADLBA!SubprogramCall (
--			name <- s.name,
--			calledSubprogram <- s.calledSubprogram
--		)
--	do
--	{
--		thisModule.addImportedUnitFromInputModel(thisModule.public(), s.calledSubprogram);		
--		if(not s.calledSubprogram.getPropertyAssociation('Source_Name').oclIsUndefined()
--					and not s.calledSubprogram.getPropertyAssociation('Source_Text').oclIsUndefined())
--		{
--			s2.calledSubprogram <- s.calledSubprogram.resolve();
--		}
--		else
--		{
--			if (s.calledSubprogram.oclIsKindOf(AADLI!SubprogramType))
--				s2.calledSubprogram <- thisModule.Type(OclUndefined,s.calledSubprogram);
--			else if(s.calledSubprogram.oclIsKindOf(AADLI!SubprogramImplementation))
--				s2.calledSubprogram <- thisModule.Implementation(OclUndefined,s.calledSubprogram, thisModule.Type(OclUndefined,s.calledSubprogram.getOwnedRealization().implemented));
--			else if (s.calledSubprogram.oclIsKindOf(AADLI!SubprogramAccess))
--				if(s.calledSubprogram.subprogramFeatureClassifier.oclIsKindOf(AADLI!SubprogramType))
--					s2.calledSubprogram <-  thisModule.Type(OclUndefined,s.calledSubprogram.subprogramFeatureClassifier);
--				else if (s.calledSubprogram.subprogramFeatureClassifier.oclIsKindOf(AADLI!SubprogramType))
--					s2.calledSubprogram <-  thisModule.Implementation(OclUndefined,s.calledSubprogram.subprogramFeatureClassifier, thisModule.Type(OclUndefined,s.calledSubprogram.subprogramFeatureClassifier.getOwnedRealization().implemented));
--		
--			if(not s.calledSubprogram.getModalPropertyValue('Constant_Value_Parameters').oclIsUndefined()
--				and not s.calledSubprogram.getModalPropertyValue('Constant_Value').oclIsUndefined())
--			{
--				thisModule.ports_constantValue <- s.calledSubprogram.getModalPropertyValue('Constant_Value').ownedValue;
--				thisModule.ports_constantValueParameters <- s.calledSubprogram.getModalPropertyValue('Constant_Value_Parameters').ownedValue;
--				-- WARNING : We use both s (from input model) and s2 (from output model)
--				-- in this code
--				-- It is ok if: 
--					-- 1) parameter constant values ('Constant_Value') and 
--					-- parameters ('Constant_Value_Parameters') are identified 
--					-- by strings in the property set
--					-- 2) properties are copied from source to target model
--					-- 3) parameters have the same name in the source and target model
--				for(p in s2.calledSubprogram.getSubprogramParameters())
--				{
--					for(constantParamString in thisModule.ports_constantValueParameters.ownedListElement)
--					{
--						if(constantParamString.value=p.name)
--						{
--							thisModule.ports_parameterConstantValue <- thisModule.ports_constantValue.ownedListElement->at(thisModule.ports_constantValueParameters.ownedListElement->indexOf(constantParamString)).value;
--							thisModule.mapConstantParameter(p, thisModule.ports_parameterConstantValue, s2, implImg);
--						}
--					}	
--				}
--			} else
--			{
--				if(not s2.calledSubprogram.getModalPropertyValue('Constant_Value_Parameters').oclIsUndefined()
--					and not s2.calledSubprogram.getModalPropertyValue('Constant_Value').oclIsUndefined())
--				{
--					thisModule.ports_constantValue <- s2.calledSubprogram.getModalPropertyValue('Constant_Value').ownedValue;
--					thisModule.ports_constantValueParameters <- s2.calledSubprogram.getModalPropertyValue('Constant_Value_Parameters').ownedValue;
--					for(p in s2.calledSubprogram.getSubprogramParameters())
--					{
--						for(constantParamString in thisModule.ports_constantValueParameters.ownedListElement)
--						{
--							if(constantParamString.value=p.name)
--							{
--								thisModule.ports_parameterConstantValue <- thisModule.ports_constantValue.ownedListElement->at(thisModule.ports_constantValueParameters.ownedListElement->indexOf(constantParamString)).value;
--								thisModule.mapConstantParameter(p, thisModule.ports_parameterConstantValue, s2, implImg);
--							}
--						}	
--					}
--				}
--			}
--		}
--		s2;
--	}
--}


helper context AADLBA!ThreadImplementation def : createBAVariablesForSpgParameters() : Sequence(AADLBA!BehaviorVariable) =
	self.behavior().getAllOutParameters()->collect(p|thisModule.CreateVariableForParameter(p))
;

unique lazy rule CreateVariableForParameter {
 from
	p : AADLI!Parameter
 using
 {
	pName : String = p.eContainer().name.concat('_').concat(p.name);
 }
 to
	v : AADLBA!BehaviorVariable (
		dataClassifier <- p.dataFeatureClassifier
	)
  do 
  { 
  	pName.debug('  create behavior variable');
  	v;
  }
}


lazy rule CreateAction_SubprogramCall
{
 from
	behavior: AADLBA!BehaviorAnnex,
	call: AADLBA!SubprogramCall
 using
 {
 	seq : AADLBA!SubprogramCallSequence = call.eContainer();
 	owner : AADLBA!ComponentImplementation = seq.eContainer();
 }
 to
   callAction			: AADLBA!SubprogramCallAction (
		subprogram					<- subprogramRef,
		parameterLabels				<- call.calledSubprogram.ownedParameter
										->collect(p|behavior.getBehaviorVariableForParameter(owner, call, p))
										->select(v|not v.oclIsUndefined()) -- remove when input ports will be removed
										->collect(v|thisModule.CreateBAName(v.getName(), v))
	),
	
	subprogramRef		: AADLBA!CalledSubprogramHolder (
		subprogram 					<- call.calledSubprogram
	)
 do { callAction; }
}

--rule addParameterConnection(implImg: AADLBA!ThreadImplementation, name: String, param: AADLBA!Parameter, ctx:AADLBA!Context, variable: AADLBA!DataSubcomponent)
--{
--  to
--	connectedParam: AADLBA!ConnectedElement
--	(
--		connectionEnd<-param
--	),
--	connectedSubcomponent: AADLBA!ConnectedElement
--	(
--		connectionEnd<-variable
--	),
--	paramConnection: AADLBA!ParameterConnection
--	(
--		name<-name,
--		source<-connectedParam,
--		destination<-connectedSubcomponent
--	)
--  do
--  {
--  	if(not ctx.oclIsUndefined())
--  		connectedParam.setContext(ctx);
--  	implImg.ownedParameterConnection <- implImg.ownedParameterConnection.including(paramConnection);
--  }
--}

lazy rule addSuprogramCallParameterConnection
{
	from
		implImg:AADLBA!ThreadImplementation,
		paramConnection: AADLI!ParameterConnection
	using
	{
		dataSubcomponent: AADLBA!DataSubcomponent = thisModule.addParameterLocalVariable(paramConnection.source, implImg);
	}
	do
	{
		thisModule.addParameterConnection(implImg, 'dest_'+paramConnection.destination.connectionEnd.name+'_'+paramConnection.source.connectionEnd.name,
							paramConnection.destination.getConnFeatureImg(implImg),
							paramConnection.destination.getConnContextImg(implImg),
							dataSubcomponent);
			
		thisModule.addParameterConnection(implImg, 'src_'+paramConnection.source.connectionEnd.name+'_'+paramConnection.destination.connectionEnd.name,
							paramConnection.source.getConnFeatureImg(implImg),
							paramConnection.source.getConnContextImg(implImg),
							dataSubcomponent);
	}
}

rule mapSubprogramParameters(implImg: AADLBA!ComponentImplementation, impl: AADLI!ComponentClassifier)
{
	do
	{
		for(paramConnection in impl.ownedParameterConnection)
		{
			if(paramConnection.source.connectionEnd.oclIsKindOf(AADLI!Parameter) and paramConnection.destination.connectionEnd.oclIsKindOf(AADLI!Parameter))
			{
				thisModule.addSuprogramCallParameterConnection(implImg, paramConnection);
			}
		}
	}
}


unique lazy rule addParameterLocalVariable
{
	from
		paramConnectionEnd: AADLI!ParameterConnectionEnd,
		implImg: AADLBA!ThreadImplementation
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name <- 'from_'+paramConnectionEnd.connectionEnd.name,
			dataSubcomponentType <- paramConnectionEnd.getConnFeatureImg(implImg).dataFeatureClassifier
		)
	do
	{
		implImg.ownedDataSubcomponent <- implImg.ownedDataSubcomponent.including(dataSubcomponent.debug('Added Parameter Local Variable'));
		
	}
}

rule mapConstantParameter(p: AADLBA!Parameter,
						  value : String,
						  call: AADLI!SubprogramCall,
						  implImg : AADLBA!ComponentImplementation)
{
	using
	{
		initValuePE: AADLBA!PropertyExpression = thisModule.CreateStringLiteralPropertyExpression(value);
	}
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name <- 'constant_'+call.name+'_'+p.name,
			dataSubcomponentType <- p.dataFeatureClassifier,
			ownedPropertyAssociation <- Sequence {thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL',lv)}
		),
		lv: AADLBA!ListValue
		(
			ownedListElement <- Sequence{initValuePE}
		)
		
	do
	{
		implImg.ownedDataSubcomponent <- implImg.ownedDataSubcomponent.including(dataSubcomponent);
		
		thisModule.addParameterConnection(implImg, 'dest_'+dataSubcomponent.name,
							p,
							call,
							dataSubcomponent);
	}
}

helper context AADLBA!SubprogramCall def:getConnectedParamDataSubcomponent(p: AADLBA!Parameter) : AADLBA!DataSubcomponent =
	if(not self.eContainer().eContainer().getOwnedParameterConnections()->any
	( paramCnx |
		paramCnx.source.getContext() = self and paramCnx.source.connectionEnd = p
	).oclIsUndefined())
	then
		self.eContainer().eContainer().getOwnedParameterConnections()->any
		( paramCnx |
			paramCnx.source.getContext() = self and paramCnx.source.connectionEnd = p
		).destination.connectionEnd
	else 
		if(not self.eContainer().eContainer().getOwnedParameterConnections()->any
		( paramCnx |
			paramCnx.destination.getContext() = self and paramCnx.destination.connectionEnd = p
		).oclIsUndefined())
		then
			self.eContainer().eContainer().getOwnedParameterConnections()->any
			( paramCnx |
				paramCnx.destination.getContext() = self and paramCnx.destination.connectionEnd = p
			).source.connectionEnd
		else
			OclUndefined.debug('ERROR: Could not find Parameter Connection for '+p.name+' in '+self.name)
		endif
	endif
;

helper context AADLBA!SubprogramCall def:getConnectedAccessDataSubcomponent(p: AADLBA!DataAccess) : AADLBA!DataSubcomponent =
	if(not self.eContainer().eContainer().getOwnedAccessConnections()->any
	( accessCnx |
		accessCnx.source.getContext() = self and accessCnx.source.connectionEnd = p
	).oclIsUndefined())
	then
		self.eContainer().eContainer().getOwnedAccessConnections()->any
		( accessCnx |
			accessCnx.source.getContext() = self and accessCnx.source.connectionEnd = p
		).destination.connectionEnd
	else 
		if(not self.eContainer().eContainer().getOwnedAccessConnections()->any
		( accessCnx |
			accessCnx.destination.getContext() = self and accessCnx.destination.connectionEnd = p
		).oclIsUndefined())
		then
			self.eContainer().eContainer().getOwnedAccessConnections()->any
			( accessCnx |
				accessCnx.destination.getContext() = self and accessCnx.destination.connectionEnd = p
			).source.connectionEnd
		else
			OclUndefined
		endif
	endif
;

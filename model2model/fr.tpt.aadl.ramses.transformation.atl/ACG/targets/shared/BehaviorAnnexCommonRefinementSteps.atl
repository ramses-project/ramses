--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore
-- @atlcompiler emftvm

module BehaviorAnnexCommonRefinementSteps;
create OUT : AADLBA 	from 		IN : AADLI,
									AADL_RUNTIME: AADLBA,
									DATA_MODEL: AADLBA,
									PROGRAMMING_PROPERTIES: AADLBA,
									HOOKS: ATLHOOKS,
									ARINC653_RUNTIME: AADLBA;

-- List


abstract rule m_Port_BehaviorAnnex
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!AnnexSubclause
		(
			behavior.oclIsTypeOf(AADLBA!BehaviorAnnex)
			and
			fi.isThreadPort()
			and
			(fi.getComponentInstance().subcomponent.subcomponentType.getBA()=behavior)
			and not fi.isPeriodicDelayedPort()
		)
}

unique lazy rule createUpdateFreshnessToSend
{
	from
		fi: AADLI!FeatureInstance,
		cnx: AADLI!PortConnection
	to		
		-------- Emitter freshness update
		sendFreshnessOutput: AADLBA!AssignmentAction
		(
			target <- sendFreshDataComponentReference,
			valueExpression <- sendValueExpressionOutput
		),
		sendFreshDataComponentReference: AADLBA!DataComponentReference
		(
			data<-Sequence{dataSubcomponentSend,dataSubcomponentStructSend}
		),
		dataSubcomponentSend: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveMatchedSingleIfExists(fi, 'localVariable')
		),
		dataSubcomponentStructSend: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveLazySingleIfExists(fi.feature.dataFeatureClassifier, 'createFreshnessDataStructure', 'struct_freshness_data_subcomponent')
		),
		sendValueExpressionOutput: AADLBA!ValueExpression
		(
			relations <- Sequence{sendRelationOutput}	
		),
		sendRelationOutput: AADLBA!Relation
		(
			firstExpression<-sendFirstExpressionOutput
		),
		sendFirstExpressionOutput: AADLBA!SimpleExpression
		(
			terms <- Sequence{sendFreshTermOutput}
		),
		sendFreshTermOutput: AADLBA!Term
		(
			factors <- Sequence{sendFreshFactorOutput}
		),
		sendFreshFactorOutput: AADLBA!Factor
		(
			firstValue <- dataAccessHolderSend
		),
		dataAccessHolderSend: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.createFreshnessIndicatorAccess(fi)
		),
		
		
		-- to be put before a the previous action
		updateFreshnessOutput: AADLBA!AssignmentAction
		(
			target <- updatePreviousFreshAccessHolderOutput,
			valueExpression <- updateValueExpressionOutput
		),
		updatePreviousFreshAccessHolderOutput:AADLBA!DataAccessHolder
		(
			element <- thisModule.createFreshnessIndicatorAccess(fi)
		),
		updateValueExpressionOutput: AADLBA!ValueExpression
		(
			relations <- Sequence{updateRelationOutput}	
		),
		updateRelationOutput: AADLBA!Relation
		(
			firstExpression<-updateFirstExpressionOutput
		),
		updateFirstExpressionOutput: AADLBA!SimpleExpression
		(
			terms <- Sequence{updateFreshTermOutput, updateConstantTermOutput},
			binaryAddingOperators <- Sequence{#Plus}
		),
		updateFreshTermOutput: AADLBA!Term
		(
			factors <- Sequence{updateFreshFactorOutput}
		),
		updateFreshFactorOutput: AADLBA!Factor
		(
			firstValue <- dataAccessHolderOutput
		),
		dataAccessHolderOutput: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.createFreshnessIndicatorAccess(fi)
		),
		updateConstantTermOutput: AADLBA!Term
		(
			factors <- Sequence{updateConstantFactorOutput}
		),
		updateConstantFactorOutput: AADLBA!Factor
		(
			firstValue <- valueConstantOutput
		),
		valueConstantOutput: AADLBA!BehaviorIntegerLiteral
		(
			value <- 1.longValue()
		)
	do
	{
		Sequence{updateFreshnessOutput,sendFreshnessOutput};
	}
}


-- @extends m_Port_BehaviorAnnex
rule m_Input_Port_BehaviorAnnex
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!AnnexSubclause
		(
			fi.isInputFeature()
		)
	using
	{
		annexSubclause: AADLBA!AnnexSubclause = fi.getComponentInstance().subcomponent.classifier.ownedAnnexSubclause->any(e|e.name = 'behavior_specification');
	}
	to
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- fi.name+'_accessCnx_'+fi.getComponentInstance().subcomponent.subcomponentType.ownedAnnexSubclause->indexOf(annexSubclause).toString(),
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveMatchedSingleIfExists(fi, 'f')
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature()
		)
	do
	{
		destinationCE.setContext(thisModule.resolveMatchedSingleIfExists(fi.getComponentInstance(), 'callEntryPoint'));
	}
}

-- @extends m_Port_BehaviorAnnex
rule m_Output_Port_BehaviorAnnex
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!AnnexSubclause,
		cnxRef: AADLI!PortConnection
		(
			fi.isOutputFeature()
			and
			fi.srcConnectionInstance->exists(e|e.connectionReference->exists(cnx| cnx.connection = cnxRef))
		)
	using
	{
		annexSubclause: AADLBA!AnnexSubclause = fi.getComponentInstance().subcomponent.classifier.ownedAnnexSubclause->any(e|e.name = 'behavior_specification');
	}
	to
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- cnxRef.uniqueName()+'_'+fi.name+'_accessCnx_'+fi.getComponentInstance().subcomponent.subcomponentType.ownedAnnexSubclause->indexOf(annexSubclause).toString(),
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature(cnxRef)
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature(cnxRef)
		)
	do
	{
		destinationCE.setContext(thisModule.resolveMatchedSingleIfExists(fi.getComponentInstance(), 'callEntryPoint'));
	}
}

rule m_Compute_EntryPoint_from_BA_dataAccess {
 from 
    c : AADLI!ComponentInstance,
	behavior: AADLI!AnnexSubclause,
	data: AADLI!ComponentInstance
	(
		c.category = #thread 
		and
		behavior.oclIsTypeOf(AADLBA!BehaviorAnnex)
	  	and
	  	c.subcomponent.classifier.getBA() = behavior
		and
		data.eContainer()=c
		and
		AADLBA!DataSubcomponentHolder.allInstances()->exists(f|f.element = data.subcomponent)
	)
  to
  	dataAccess: AADLBA!DataAccess
	(
		name <- data.name+'_accessForBA',
		dataFeatureClassifier <- data.subcomponent.dataSubcomponentType,
		kind <- #requires
	)
  do
  {
  	thisModule.addImportedUnitFromInputModel(thisModule.public(), data.subcomponent.dataSubcomponentType);
  }
}


-- @extends m_ThreadBehavior
rule m_Compute_EntryPoint_from_BA {
 from 
    c : AADLI!ComponentInstance,
	behavior: AADLI!AnnexSubclause
	( 	
		c.category = #thread 
		and
		behavior.oclIsTypeOf(AADLBA!BehaviorAnnex)
	  	and
	  	c.subcomponent.classifier.getBA() = behavior
	  	and
		c.subcomponent.subcomponentType.oclIsKindOf(AADLI!ComponentImplementation)
		and
		c.subcomponent.subcomponentType.needsToMapBehaviorAnnex()
	)
 using
 {
    impl: AADLI!Thread = c.subcomponent.subcomponentType;
 	implBA: AADLBA!BehaviorAnnex = c.subcomponent.subcomponentType.getBA();
	annexSubclause: AADLBA!AnnexSubclause = c.subcomponent.classifier.ownedAnnexSubclause->any(e|e.name = 'behavior_specification');
	stateTypeID: String = c.uniqueName().concat('_currentState');
 }
 to 
	behaviorAnnex: AADLBA!BehaviorAnnex
	(
		variables <- behavior.variables
	),
	stateType: AADLBA!DataType
	(
		name <- stateTypeID,
		ownedPropertyAssociation <- Sequence {
												
												thisModule.CreatePropertyAssociation
												(
												 	'Data_Representation',
													'DATA_MODEL',
													'Enum'.asEnumeration('DATA_MODEL').asNamedValue()
												),
												thisModule.CreatePropertyAssociation
												(
												 	'Enumerators',
													'DATA_MODEL',
													 thisModule.CreateListValueFromListOfString(implBA.states->collect(e|e.name))
												),
												thisModule.CreatePropertyAssociation
												(
												 	'Initial_Value',
													'DATA_MODEL',
													 thisModule.CreateListValueFromString(c.targetPackagePrefix()+stateTypeID.getProgrammationLanguageIdentifier().concat('_')+thisModule.getBAInitialStateIdentifier(implBA))
												)
									}
	),
	-- To be added in entryPointImg
	currentState: AADLBA!DataSubcomponent
	(
		name <- c.name+'Parent_BA_currentState',
		dataSubcomponentType <- stateType
	),
	-- to be added in implImg
	currentStateAccess: AADLBA!DataAccess
	(
		name <- 'Parent_BA_currentState_Access',
		dataFeatureClassifier <- stateType,
		kind <- #requires
	),
	currentStateAccessThread: AADLBA!DataAccess
	(
		name <- 'Parent_BA_currentState_Access',
		dataFeatureClassifier <- stateType,
		kind <- #requires
	),
	
	-- connect currentState feature of entryPointImg to the data subcomponent of the implImg that
	-- represents the state of implImg
	connectedAccess_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentStateAccess,
		context<-thisModule.resolveMatchedSingleIfExists(c, 'callEntryPoint')
	),
	connectedSubcomponent_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentStateAccessThread
	),
	accessConnection_CURRENT_STATE: AADLBA!AccessConnection
	(
		name<-'CNX_CURRENT_STATE_BA',
		source<-connectedAccess_CURRENT_STATE,
		destination<-connectedSubcomponent_CURRENT_STATE,
		accessCategory <- #data
	),
	
	connectedAccessThread_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentStateAccessThread,
		context<-c
	),
	connectedSubcomponentThread_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentState
	),
	accessConnection_CURRENT_STATE_THREAD: AADLBA!AccessConnection
	(
		name<-c.name+'_CNX_CURRENT_STATE_BA',
		source<-connectedAccessThread_CURRENT_STATE,
		destination<-connectedSubcomponentThread_CURRENT_STATE,
		accessCategory <- #data
	),
	
	computeEntryPointTransition: AADLBA!BehaviorTransition
	(
		name <- behavior.name+'_'+c.subcomponent.subcomponentType.ownedAnnexSubclause->indexOf(annexSubclause).toString()
	),
	computeEntryPointActions: AADLBA!BehaviorActionSequence
	(
		actions <- if c.needsModeVariable() then
					Sequence{thisModule.createModeVariableUpdate(c)}
					else 
					Sequence{} 
					endif
				->union
				(
					c.featureInstance->select(fi| 
						fi.isInputFeature() and
						(fi.isEventPort() or fi.isEventDataPort())
					)
					->collect(fi|thisModule.createReceiveInputCall(fi))
				)
				->union
				(
					behavior.transitions->collect(trans|trans.usedPortCount()->collect(e| thisModule.createPortCountValueUpdate(c.featureInstance->any(p|p.feature = e))))
					->flatten()
					->append(
						thisModule.resolveMatchedTupleIfExists(Sequence{c,
							behavior.transitions
								->sortedBy(e| 0.longValue().minus(e.priority))
								->first()},'ifStatement')
						)
				)
	)
 do
 {
 	thisModule.addImportedUnit(thisModule.public(), thisModule.getLoadedAADLRuntime, thisModule.getRuntimeName);
 	for(fi in c.featureInstance->select(fi | fi.feature.oclIsKindOf(AADLBA!Port) and fi.isUsedInFresh()))
 	{
 		thisModule.resolveLazySingleIfExists(fi, 'createFreshnessIndicator', 'freshnessIndicator_CnxDestination').setContext(thisModule.resolveMatchedSingleIfExists(c, 'callEntryPoint'));
 	}
 }
}

-- Next rule should be overriden as it is target specific
unique lazy rule createModeVariableUpdate
{
	from
		c: AADLI!ComponentInstance
	to
		
}

helper context OclAny def: resolve(c: AADLI!ComponentInstance): OclAny =
	if(self.oclIsUndefined()) then
		OclUndefined
	else
		self.debug(' WARNING, untreatead type')
	endif
;

helper context AADLBA!BehaviorActionBlock  def: resolve(c: AADLI!ComponentInstance): AADLBA!BehaviorActionBlock =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_actionBlock')
;

helper context AADLBA!BehaviorActionSequence def: resolve(c: AADLI!ComponentInstance): AADLBA!BehaviorActionSequence =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_behaviorActionSequence')
;

helper context AADLBA!AssignmentAction def: resolve(c: AADLI!ComponentInstance): AADLBA!SubprogramCallAction =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_assignmentAction')
;

helper context AADLBA!SubprogramCallAction def: resolve(c: AADLI!ComponentInstance): AADLBA!SubprogramCallAction =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_communicationAction')
;

helper context AADLBA!IfStatement def: resolve(c: AADLI!ComponentInstance): AADLBA!IfStatement =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_ifStatement')
;

helper context AADLBA!ElementHolder def: resolve(c: AADLI!ComponentInstance): AADLBA!ElementHolder =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_Holder')
;

lazy rule getValueComponentReference
{
	from
		fi:AADLI!FeatureInstance
	using
	{
		inderectlyUsed: AADLBA!DataImplementation = thisModule.createFreshnessDataStructure(fi.feature.dataFeatureClassifier);
		portImgSubcomponent: AADLBA!DataSubcomponent = thisModule.resolveMatchedSingleIfExists(fi, 'localVariable');
	}
	to
		valueDCR: AADLBA!DataComponentReference
		(
			data <- Sequence{portImgSubcomponentHolder, portImgFreshPrevSubcomponentHolder}
		),
		portImgSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- portImgSubcomponent
		),
		portImgFreshPrevSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.resolveLazySingleIfExists(
							fi.feature.dataFeatureClassifier, 'createFreshnessDataStructure', 'struct_functional_data_subcomponent'
						)
		)
	do
	{
		valueDCR;
	}
}

helper context AADLBA!PortHolder def: resolve(c: AADLI!ComponentInstance): AADLBA!ElementHolder =
	let fi:AADLI!FeatureInstance = c.featureInstance->any(e| e.feature = self.element) in
	if(fi.isUsedInFresh()) then 
		thisModule.getValueComponentReference(fi)
	else
		thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_Holder')
	endif
;

helper context AADLBA!ClassifierPropertyReference def: resolve(c: AADLI!ComponentInstance): AADLBA!ClassifierPropertyReference =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_classifierPropertyReference')
;

helper context AADLBA!PropertySetPropertyReference def: resolve(c: AADLI!ComponentInstance): AADLBA!PropertySetPropertyReference =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_propertySetPropertyReference')
;

helper context AADLBA!PropertyNameHolder def: resolve(c: AADLI!ComponentInstance): AADLBA!PropertyNameHolder =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_propertyNameHolder')
;

helper context AADLBA!UpperBound def: resolve(c: AADLI!ComponentInstance): AADLBA!UpperBound =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_upperBound')
;

helper context AADLBA!LowerBound def: resolve(c: AADLI!ComponentInstance): AADLBA!LowerBound =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_lowerBound')
;

helper context AADLBA!PropertyExpressionHolder def: resolve(c: AADLI!ComponentInstance): AADLBA!PropertyExpressionHolder =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_propertyExpressionHolder')
;

helper context AADLBA!PortFreshValue def: resolve(c: AADLI!ComponentInstance): AADLBA!ElementHolder =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'isFresh')
;

helper context AADLBA!Factor def: resolve(c: AADLI!ComponentInstance): AADLBA!ElementHolder =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_factor')
;

helper context AADLBA!Term def: resolve(c: AADLI!ComponentInstance): AADLBA!ElementHolder =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_term')
;

helper context AADLBA!BehaviorIntegerLiteral def: resolve(c: AADLI!ComponentInstance): AADLBA!BehaviorIntegerLiteral =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_behaviorIntegerLiteral')
;

helper context AADLBA!ValueExpression def: resolve(c: AADLI!ComponentInstance): AADLBA!ValueExpression =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_valueExpression')
;

helper context AADLBA!Relation def: resolve(c: AADLI!ComponentInstance): AADLBA!Relation =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_relation')
;

helper context AADLBA!SimpleExpression def: resolve(c: AADLI!ComponentInstance): AADLBA!SimpleExpression =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_simpleExpression')
;

helper context AADLBA!BehaviorTransition def: usedPortCount() : Sequence(AADLBA!Port) =
	thisModule.theHOOK.allPortCount(self)
;

-- next rule needs a target specific implementation
lazy rule createPortCountValueUpdate
{
	from
		fi: AADLI!FeatureInstance
}

rule m_BehaviorActionsFromThread
{
  from
	c: AADLI!ComponentInstance,
	src_transition: AADLBA!BehaviorTransition
	(
		c.category = #thread
		and
		c.subcomponent.subcomponentType.getBA() = src_transition.eContainer()
	)
  using
  {
	ba: AADLBA!BehaviorAnnex = src_transition.eContainer();
	currentStateAccess: AADLBA!DataAccess = thisModule.resolveMatchedTupleIfExists(Sequence{c,ba},'currentStateAccess');
	stateType: AADLBA!DataAccess = thisModule.resolveMatchedTupleIfExists(Sequence{c,ba},'stateType');
	-- FIXME: to be sorted according to priority.
	sortedTransitions: Sequence(AADLBA!BehaviorTransition) = ba.transitions->sortedBy(e| 0.longValue().minus(e.priority));
  }
  to
	ifStatement: AADLBA!IfStatement
	(
		logicalValueExpression <- isStateSource,
		elif <- if(sortedTransitions->first() = src_transition) then false else true endif,
		behaviorActions <- ifStatementActionSequence,
		elseStatement <- let index: Integer = sortedTransitions->indexOf(src_transition) in 
						if(index>0 and sortedTransitions->size() > index) then
							thisModule.resolveMatchedTupleIfExists(Sequence{c,
								sortedTransitions->at(index+1)}, 'ifStatement')
						else
							OclUndefined
						endif
	),
	ifStatementActionSequence: AADLBA!BehaviorActionSequence
	(
		actions <- 	if(src_transition.sourceState.complete=true)
					then
						c.featureInstance->select(f | (f.isInputFeature() or f.isInputOutputFeature()) and f.feature.oclIsTypeOf(AADLI!DataPort))
						->collect
							(port | 
								thisModule.resolveMatchedTupleIfExists(Sequence{port, src_transition.eContainer()}, 'call')
							)
					else
						Sequence{}
					endif
					->union
					(
						if(src_transition.actionBlock.oclIsUndefined()) then
							Sequence{}
						else
							if(src_transition.actionBlock.content.oclIsKindOf(AADLBA!BehaviorActionCollection)) then
								src_transition.actionBlock.content.actions->collect( e| e.resolve(c))
					   		else
					   			Sequence{src_transition.actionBlock.content.resolve(c)}
					   		endif
						endif
					)
					->flatten()
					->union(
						c.featureInstance->select(f| (f.isInputFeature() or f.isInputOutputFeature()) and f.feature.oclIsTypeOf(AADLI!DataPort) and f.isUsedInFresh())
						->collect( e | 
							thisModule.createFreshnessIndicatorUpdateAction(e)
						)
					)
					->union(
						c.featureInstance->select(f| (f.isOutputFeature() or f.isInputOutputFeature()) and f.feature.oclIsTypeOf(AADLI!DataPort) and f.isUsedInFresh())
						->collect( e | 
							e.srcConnectionInstance->collect(
								cnx| thisModule.createUpdateFreshnessToSend(e, cnx.connectionReference->first().connection)
							)
						)
					)
					->append(updateState)
					->union
					(
						if(src_transition.destinationState.complete=true)
						then
						c.featureInstance->select(f | (f.isOutputFeature() or f.isInputOutputFeature()) and f.feature.oclIsTypeOf(AADLI!DataPort))
						->collect(port | 
							port.srcConnectionInstance->collect
							(
								cnxInst | thisModule.resolveMatchedTupleIfExists(Sequence{port, src_transition.eContainer(), cnxInst.connectionReference->first().connection}, 'call')
							)
						)
						->append(thisModule.resolveMatchedTupleIfExists(Sequence{c,src_transition},'waitDispatchCall'))
						else
						Sequence{}
						endif
					)
					->flatten()
					->excluding(OclUndefined)
	),
	isStateSource: AADLBA!ValueExpression
	(
		relations <- Sequence{comparisonRelation}
						->union(if src_transition.condition.oclIsTypeOf(AADLBA!ValueExpression)
								then
									src_transition.condition.relations
									->collect(e|e.resolve(c))
								else
									Sequence{}
								endif	
								)
						->excluding(OclUndefined),
		logicalOperators <- if src_transition.condition.oclIsKindOf(AADLBA!ValueExpression) 
							then
								Sequence{#And}
								-> union(
									src_transition.condition.logicalOperators
								)
							else
								Sequence{}
							endif
	),
	comparisonRelation: AADLBA!Relation
	(
		relationalOperator<-#Equal,
		firstExpression<-comparisonFirstExpression,
		secondExpression<-comparisonSecondExpression
	),
	comparisonFirstExpression: AADLBA!SimpleExpression
	(
		terms <- Sequence{currentStateAccessTerm}
	),
	comparisonSecondExpression: AADLBA!SimpleExpression
	(
		terms <- Sequence{enumValueSourceStateTerm}
	),
	currentStateAccessTerm: AADLBA!Term
	(
		factors <- Sequence{currentStateAccessFactor}
	),
	enumValueSourceStateTerm: AADLBA!Term
	(
		factors <- Sequence{enumValueSourceStateFactor}
	),
	currentStateAccessFactor: AADLBA!Factor
	(
		firstValue <- currentStateAccessHolder
	),
	currentStateAccessHolder:AADLBA!DataAccessHolder
	(
		element <- currentStateAccess
	),
	enumValueSourceStateFactor: AADLBA!Factor
	(
		firstValue <- sourceStateID
	),
	sourceStateID: AADLBA!ClassifierPropertyReference
	(
		classifier <- stateType,
		properties <- Sequence {sourceStateIDPropertyNameHolder}
	),
	sourceStateIDPropertyNameHolder: AADLBA!PropertyNameHolder
	(
		property <- sourceStateIDPropertyExpressionHolder
	),
	sourceStateIDPropertyExpressionHolder: AADLBA!PropertyExpressionHolder
	(
		element <- stateType.getStringLiteral('Enumerators', src_transition.sourceState.name)
	),
	updateState: AADLBA!AssignmentAction
	(
		target <- updateStateAccessHolder,
		valueExpression <- updateValueExpression
	),
	updateStateAccessHolder:AADLBA!DataAccessHolder
	(
		element <- currentStateAccess
	),
	updateValueExpression: AADLBA!ValueExpression
	(
		relations <- Sequence{updateRelation}	
	),
	updateRelation: AADLBA!Relation
	(
		firstExpression<-updateFirstExpression
	),
	updateFirstExpression: AADLBA!SimpleExpression
	(
		terms <- Sequence{enumValueTargetStateTerm}
	),
	enumValueTargetStateTerm: AADLBA!Term
	(
		factors <- Sequence{enumValueTargetStateFactor}
	),
	enumValueTargetStateFactor: AADLBA!Factor
	(
		firstValue <- targetStateID
	),
	targetStateID: AADLBA!ClassifierPropertyReference
	(
		classifier <- stateType,
		properties <- Sequence {targetStateIDPropertyNameHolder}
	),
	targetStateIDPropertyNameHolder: AADLBA!PropertyNameHolder
	(
		property <- targetStateIDPropertyExpressionHolder
	),
	targetStateIDPropertyExpressionHolder: AADLBA!PropertyExpressionHolder
	(
		element <- stateType.getStringLiteral('Enumerators', src_transition.destinationState.name)
	)
}

---- @extends m_BehaviorActionsFromThread
--rule m_BehaviorActionsFromThread_Periodic
--{
--	from
--		c: AADLI!ComponentInstance,
--		src_transition: AADLBA!BehaviorTransition
--		(
--			c.isPeriodicThread()
--			and
--			c.subcomponent.subcomponentType.getBA() = src_transition.eContainer()
--			and
--			src_transition.destinationState.complete=true
--		)
--	using
--	{
--		ba: AADLBA!BehaviorAnnex = src_transition.eContainer();
--		spg : AADLBA!SubprogramType = thisModule.getWaitPeriodSubprogram;
--	}
--	to
--		callSequenceImg: AADLBA!SubprogramCallSequence,
--		returnData: AADLBA!DataSubcomponent,
--		waitDispatchCall: AADLBA!SubprogramCallAction
--		(
--			subprogram<-dispatchHolder,
--			parameterLabels <- Sequence{RETURN_DATA_Holder}
--		),
--		dispatchHolder: AADLBA!CalledSubprogramHolder
--		(
--			element <- spg
--		),
--		RETURN_DATA_Holder: AADLBA!DataSubcomponentHolder
--		(
--			element<-thisModule.resolveMatchedSingleIfExists(c, 'returnData')
--		)
--	do
--	{
--		thisModule.addImportedUnit(thisModule.public(), thisModule.getLoadedAADLRuntime, thisModule.getRuntimeName);
--	}
--}

unique lazy rule createFreshnessIndicatorUpdateAction
{
	from
		fi: AADLI!FeatureInstance
	to
		updateFreshness: AADLBA!AssignmentAction
		(
			target <- updatePreviousFreshAccessHolder,
			valueExpression <- updateValueExpression
		),
		updatePreviousFreshAccessHolder:AADLBA!DataAccessHolder
		(
			element <- thisModule.createFreshnessIndicatorAccess(fi)
		),
		updateValueExpression: AADLBA!ValueExpression
		(
			relations <- Sequence{updateRelation}	
		),
		updateRelation: AADLBA!Relation
		(
			firstExpression<-updateFirstExpression
		),
		updateFirstExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{updateFreshTerm}
		),
		updateFreshTerm: AADLBA!Term
		(
			factors <- Sequence{updateFreshFactor}
		),
		updateFreshFactor: AADLBA!Factor
		(
			firstValue <- updateFreshCDR
		),
		updateFreshCDR: AADLBA!DataComponentReference
		(
			data <- Sequence{dataSubcomponentHolder,dataFreshnessSubcomponentHolder}
		),
		dataSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(fi, 'localVariable')
		),
		dataFreshnessSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.resolveLazySingleIfExists(fi.feature.dataFeatureClassifier, 'createFreshnessDataStructure', 'struct_freshness_data_subcomponent')
		)
	do
	{
		updateFreshness;
	}
}


rule m_IfStatement
{
	from
		src_ifStatement: AADLBA!IfStatement,
		c: AADLI!ComponentInstance
		(
			not src_ifStatement.oclIsTypeOf(AADLBA!ElseStatement)
			and
			src_ifStatement.isThreadBehaviorElement()
			and
			src_ifStatement.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_ifStatement: AADLBA!IfStatement
		(
			logicalValueExpression <- src_ifStatement.logicalValueExpression.resolve(c),
			elif <- src_ifStatement.elif.resolve(c),
			behaviorActions <- ifStatementActionSequence,
			elseStatement <- src_ifStatement.elseStatement.resolve(c)
		),
		ifStatementActionSequence: AADLBA!BehaviorActionSequence
		(
			actions <- if(src_ifStatement.behaviorActions.oclIsKindOf(AADLBA!BehaviorActionCollection)) then
						src_ifStatement.behaviorActions.actions->collect( e| e.resolve(c))
					   else
					   	Sequence{src_ifStatement.behaviorActions.resolve(c)}
					   endif
		)
}

rule m_BehaviorActionBlock
{
	from
		src_actionBlock: AADLBA!BehaviorActionBlock,
		c: AADLI!ComponentInstance
	to
	    target_actionBlock: AADLBA!BehaviorActionBlock
		(
			content <- src_actionBlock.content.resolve(c)
		)
}

rule m_BehaviorActionSequence
{
	from
		src_behaviorActionSequence: AADLBA!BehaviorActionSequence,
		c: AADLI!ComponentInstance
		(
			src_behaviorActionSequence.isThreadBehaviorElement()
			and
			src_behaviorActionSequence.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_behaviorActionSequence: AADLBA!BehaviorActionSequence
		(
			actions <- src_behaviorActionSequence.actions->collect(e| e.resolve(c))
		)
}

rule m_EventPortHolder
{
	from
		src_Holder: AADLBA!EventPortHolder,
		c: AADLI!ComponentInstance
		(
			let f: AADLI!FeatureInstance = c.featureInstance->any(e|e.name=src_Holder.element.name) in 
			c.featureInstance->exists(fi| fi.feature = src_Holder.element)
		)
	to
		target_Holder: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveMatchedSingleIfExists(c.featureInstance->any(e|e.name=src_Holder.element.name), 'localVariable')	
		)
}

rule m_EventDataPortHolder
{
	from
		src_Holder:AADLBA!EventDataPortHolder,
		c: AADLI!ComponentInstance
		(
			let f: AADLI!FeatureInstance = c.featureInstance->any(e|e.name=src_Holder.element.name) in 
			c.featureInstance->exists(fi| fi.feature = src_Holder.element)
		)
	to
		target_Holder: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveMatchedSingleIfExists(c.featureInstance->any(e|e.name=src_Holder.element.name), 'localVariable')	
		)
}

rule m_DataSubcomponentHolder
{
	from
		src_Holder: AADLBA!DataSubcomponentHolder,
		c: AADLI!ComponentInstance
		(
			c.componentInstance->exists(e|e.subcomponent=src_Holder.element)
		)
	using
	{
		dataInstance: AADLI!ComponentInstance = c.componentInstance->any(e|e.subcomponent = src_Holder.element);
		impl: AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
	}
	to
		target_Holder: AADLBA!DataAccessHolder
		(
			element<-thisModule.resolveMatchedTupleIfExists(Sequence{c,impl.getBA(),dataInstance}, 'dataAccess')
		)
}

rule m_BehaviorVariableHolder
{
	from
		src_Holder: AADLBA!BehaviorVariableHolder,
		c: AADLI!ComponentInstance
	to
		target_Holder: AADLBA!BehaviorVariableHolder
		(
			element <- src_Holder.element
		)
}

rule m_SubprogramHolder
{
	from
		src_Holder: AADLBA!SubprogramHolder,
		c: AADLI!ComponentInstance
	to
		target_Holder: AADLBA!SubprogramHolder
		(
			element <- src_Holder.element
		)
	do
	{
		thisModule.addImportedUnitFromInputModel(thisModule.public(), src_Holder.element);
	}
}

rule m_DataPortHolder_withFresh
{
	from
		src_Holder:AADLBA!DataPortHolder,
		c: AADLI!ComponentInstance
		(
			let f: AADLI!FeatureInstance = c.featureInstance->any(e|e.feature.name=src_Holder.element.name) in 
			c.featureInstance->exists(fi| fi.feature = src_Holder.element)
			and
			f.isUsedInFresh()
		)
	to
		target_Holder: AADLBA!DataComponentReference
		(
			data <- Sequence{dataSubcomponentHolder,functionalPartHolder}
		),
		dataSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveMatchedSingleIfExists(c.featureInstance->any(e|e.name=src_Holder.element.name), 'localVariable')
		),
		functionalPartHolder: AADLBA!DataSubcomponentHolder
	do
	{
		functionalPartHolder.element<-thisModule.resolveLazySingleIfExists(c.featureInstance->any(e|e.name=src_Holder.element.name).feature.dataFeatureClassifier, 'createFreshnessDataStructure','struct_functional_data_subcomponent');
	}
}
		
-- @extends m_ElementHolder
rule m_DataPortHolder
{
	from
		src_Holder:AADLBA!DataPortHolder,
		c: AADLI!ComponentInstance
		(
			let f: AADLI!FeatureInstance = c.featureInstance->any(e|e.name=src_Holder.element.name) in 
			c.featureInstance->exists(fi| fi.feature = src_Holder.element)
			and
			not f.isUsedInFresh()
		)
	to
		target_Holder: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveMatchedSingleIfExists(c.featureInstance->any(e|e.name=src_Holder.element.name), 'localVariable')	
		)
}

-- @extends m_ElementHolder
rule m_PortCountValue
{
	from
		src_Holder:AADLBA!PortCountValue,
		c: AADLI!ComponentInstance
		(
			let f: AADLI!FeatureInstance = c.featureInstance->any(e|e.name=src_Holder.element.name) in 
			c.featureInstance->exists(fi| fi.feature = src_Holder.element)
		)
	using
	{
		fi: AADLI!FeatureInstance = c.featureInstance->any(e|e.name=src_Holder.element.name);
	}
	to
		target_Holder: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.createPortCountSubcomponent(fi)
		)
}

rule m_PropertyReference
{
	from
		src_propertyReference: AADLBA!PropertyReference,
		c: AADLI!ComponentInstance
		(
			src_propertyReference.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_propertyReference: AADLBA!PropertyReference
		(
			properties <- src_propertyReference.properties->collect(propertyname| propertyname.resolve(c))
		)
}

-- @extends m_PropertyReference
rule m_ClassifierPropertyReference
{
	from
		src_propertyReference: AADLBA!PropertyReference,
		c: AADLI!ComponentInstance
	to
		target_classifierPropertyReference: AADLBA!ClassifierPropertyReference
		(
			classifier <- src_propertyReference.classifier
		)
}

-- @extends m_PropertyReference
rule m_PropertySetPropertyReference
{
	from
		src_propertyReference: AADLBA!PropertyReference,
		c: AADLI!ComponentInstance
	to
		target_propertySetPropertyReference: AADLBA!PropertySetPropertyReference
		(
			propertyset <- src_propertyReference.propertyset
		)
}

rule m_PropertyNameHolder
{
	from
		src_propertyNameHolder: AADLBA!PropertyNameHolder,
		c: AADLI!ComponentInstance
		(
			src_propertyNameHolder.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_propertyNameHolder: AADLBA!PropertyNameHolder
		(
			property <- src_propertyNameHolder.property.resolve(c),
			
			field <- if src_propertyNameHolder.field.oclIsUndefined() then 
						OclUndefined
					else 
						src_propertyNameHolder.field.resolve(c)
					endif
		)
}

-- Indexes not supported yet.
rule m_PropertyElementHolder
{
	from
		src_propertyElementHolder: AADLBA!PropertyElementHolder,
		c: AADLI!ComponentInstance
		(
			src_propertyElementHolder.isPartOfBehaviorAnnexOf(c)	
		)
	to
		target_propertyElementHolder: AADLBA!PropertyElementHolder
		(
			element <- src_propertyElementHolder.element
		)
}

-- @extends m_PropertyElementHolder
rule m_PropertyExpressionHolder
{
	from
		src_propertyElementHolder: AADLBA!PropertyElementHolder,
		c: AADLI!ComponentInstance
	to
		target_propertyExpressionHolder: AADLBA!PropertyExpressionHolder
}

rule m_UpperBound
{
	from
		src_upperBound: AADLBA!UpperBound,
		c: AADLI!ComponentInstance
		(
			src_upperBound.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_upperBound: AADLBA!UpperBound
}

rule m_LowerBound
{
	from
		src_lowerBound: AADLBA!LowerBound,
		c: AADLI!ComponentInstance
		(
			src_lowerBound.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_LowerBound: AADLBA!LowerBound
}

-- @extends m_CommunicationAction
rule m_SubprogramCallAction
{
	from
		src_communicationAction: AADLBA!SubprogramCallAction,
		c: AADLI!ComponentInstance
		(
			src_communicationAction.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_communicationAction: AADLBA!SubprogramCallAction
		(
			subprogram <- src_communicationAction.subprogram.resolve(c),
			parameterLabels <- src_communicationAction.parameterLabels
								->collect(param | param.resolve(c)),
			dataAccess <- src_communicationAction.dataAccess.resolve(c)
		)
}

rule m_AssignmentAction
{
	from
		src_assignmentAction: AADLBA!AssignmentAction,
		c: AADLI!ComponentInstance
		(
			src_assignmentAction.isThreadBehaviorElement() and
			src_assignmentAction.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_assignmentAction: AADLBA!AssignmentAction
		(
			target <- src_assignmentAction.target.resolve(c),
			valueExpression <- src_assignmentAction.valueExpression.resolve(c)
		)
}

rule m_Term {
	from
		src_term: AADLBA!Term,
		c: AADLI!ComponentInstance
		(	
			src_term.isThreadBehaviorElement()
			and
			src_term.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_term: AADLBA!Term
		(
			factors <- src_term.factors->collect(factor| factor.resolve(c)),
			multiplyingOperators <- src_term.multiplyingOperators
		)
}


rule m_Factor {
	from
		src_factor: AADLBA!Factor,
		c: AADLI!ComponentInstance
		(
			src_factor.isThreadBehaviorElement()
			and
			src_factor.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_factor: AADLBA!Factor
		(
			firstValue <- src_factor.firstValue.resolve(c),
			secondValue <- src_factor.secondValue.resolve(c),
			binaryNumericOperator <- src_factor.binaryNumericOperator,
			unaryNumericOperator <- src_factor.unaryNumericOperator,
			unaryBooleanOperator <- src_factor.unaryBooleanOperator
		)
}

rule m_BehaviorIntegerLiteral
{
	from
		src_behaviorIntegerLiteral: AADLBA!BehaviorIntegerLiteral,
		c: AADLI!ComponentInstance
		(
			src_behaviorIntegerLiteral.isThreadBehaviorElement()
			and
			src_behaviorIntegerLiteral.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_behaviorIntegerLiteral: AADLBA!BehaviorIntegerLiteral
		(
			base <- src_behaviorIntegerLiteral.base,
			value <- src_behaviorIntegerLiteral.value
		)
}

rule m_ValueExpression
{
	from
		src_valueExpression: AADLBA!ValueExpression,
		c: AADLI!ComponentInstance
		(
			src_valueExpression.isThreadBehaviorElement()
			and
			src_valueExpression.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_valueExpression: AADLBA!ValueExpression
		(
			relations <- src_valueExpression.relations->collect(e|e.resolve(c)),
			logicalOperators <- src_valueExpression.logicalOperators
		)
}

rule m_Relation
{
	from
		src_relation: AADLBA!Relation,
		c: AADLI!ComponentInstance
		(
			src_relation.isThreadBehaviorElement()
			and
			src_relation.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_relation: AADLBA!Relation
		(
			firstExpression <- src_relation.firstExpression.resolve(c),
			relationalOperator <- src_relation.relationalOperator,
			secondExpression <- src_relation.secondExpression.resolve(c)
		)
}

rule m_SimpleExpression {
	from
		src_simpleExpression : AADLBA!SimpleExpression,
		c: AADLI!ComponentInstance
		(
			src_simpleExpression.isThreadBehaviorElement()
			and
			src_simpleExpression.isPartOfBehaviorAnnexOf(c)
		)
	to 
		target_simpleExpression : AADLBA!SimpleExpression
		(
			unaryAddingOperator <- src_simpleExpression.unaryAddingOperator,
			terms <- src_simpleExpression.terms->collect(e|e.resolve(c)),
			binaryAddingOperators <- src_simpleExpression.binaryAddingOperators
		)
}

rule m_DataAccessHolder
{
	from
		src_Holder:AADLBA!DataAccessHolder,
		c: AADLI!ComponentInstance
		(src_Holder.isPartOfBehaviorAnnexOf(c))
	to
		target_Holder: AADLBA!DataAccessHolder
		(
			element<-c.featureInstance->any(e|e.name=src_Holder.element.name)	
		)
}

rule m_ParameterHolder
{
	from
		src_Holder:AADLBA!ParameterHolder,
		c: AADLI!ComponentInstance
		(src_Holder.isPartOfBehaviorAnnexOf(c))
	to
		target_Holder: AADLBA!ParameterHolder
		(
			element<-c.featureInstance->any(e|e.name=src_Holder.element.name)	
		)
}

rule m_PortFreshValue
{
	from
		src_PortFreshValue: AADLBA!PortFreshValue,
		c: AADLI!ComponentInstance
		(c.featureInstance->exists(e| e.feature = src_PortFreshValue.element))
	using
	{
		portImgSubcomponent: AADLBA!DataSubcomponent = thisModule.resolveMatchedSingleIfExists(
							c.featureInstance->any(e|e.name = src_PortFreshValue.element.name), 'localVariable'
						);
	}
	to
		isFresh: AADLBA!ValueExpression
		(
			relations <- Sequence{comparisonRelation}
		),
		comparisonRelation: AADLBA!Relation
		(
			relationalOperator<-#NotEqual,
			firstExpression<-comparisonFirstExpression,
			secondExpression<-comparisonSecondExpression
		),
		comparisonFirstExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{currentFreshnessTerm}
		),
		comparisonSecondExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{previousFreshnessTerm}
		),
		currentFreshnessTerm: AADLBA!Term
		(
			factors <- Sequence{currentFreshnessFactor}
		),
		previousFreshnessTerm: AADLBA!Term
		(
			factors <- Sequence{previousFreshnessFactor}
		),
		currentFreshnessFactor: AADLBA!Factor
		(
			firstValue <- portImgFreshPrevComponentReference
		),
		portImgSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- portImgSubcomponent
		),
		previousFreshnessFactor: AADLBA!Factor
		(
			firstValue <- portImgFreshPrevAccessHolder
		),
		portImgFreshPrevComponentReference: AADLBA!DataComponentReference
		(
			data <- Sequence{portImgSubcomponentHolder, portImgFreshPrevSubcomponentHolder}
		),
		portImgFreshPrevAccessHolder: AADLBA!DataAccessHolder
		(
			element <- thisModule.createFreshnessIndicatorAccess(
							c.featureInstance->any(e|e.feature = src_PortFreshValue.element)
						)
		),
		portImgFreshPrevSubcomponentHolder: AADLBA!DataSubcomponentHolder
	do
	{
		portImgFreshPrevSubcomponentHolder.element <- thisModule.resolveLazySingleIfExists(
							c.featureInstance->any(e|e.feature = src_PortFreshValue.element).feature.dataFeatureClassifier, 'createFreshnessDataStructure', 'struct_freshness_data_subcomponent'
						);
	}
}

--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore
-- @atlcompiler emftvm

module BehaviorAnnexCommonRefinementSteps;
create OUT : AADLBA 	from 		IN : AADLI,
									AADL_RUNTIME: AADLBA,
									DATA_MODEL: AADLBA,
									PROGRAMMING_PROPERTIES: AADLBA,
									HOOKS: ATLHOOKS,
									ARINC653_RUNTIME: AADLBA;


abstract rule m_Port_BehaviorAnnex
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!AnnexSubclause
		(
			behavior.oclIsTypeOf(AADLBA!BehaviorAnnex)
			and
			fi.isThreadPort()
			and
			fi.eContainer().subcomponent.subcomponentType.ownedAnnexSubclause->exists(e| e=behavior)
		)
}

-- @extends m_Port_BehaviorAnnex
rule m_Input_Port_BehaviorAnnex
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!AnnexSubclause
		(
			fi.isInputFeature()
		)
	to
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- fi.name+'_accessCnx_'+fi.eContainer().subcomponent.subcomponentType.ownedAnnexSubclause->indexOf(behavior).toString(),
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveTemp(fi, 'f')
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveTemp(fi, 'f_entrypoint')
		)
	do
	{
		destinationCE.setContext(thisModule.resolveTemp(Sequence{fi.eContainer(),behavior}, 'callEntryPoint'));
	}
}

-- @extends m_Port_BehaviorAnnex
rule m_Output_Port_BehaviorAnnex
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!AnnexSubclause,
		cnxRef: AADLI!PortConnection
		(
			fi.isOutputFeature()
			and
			fi.srcConnectionInstance->exists(e|e.connectionReference->exists(cnx| cnx.connection = cnxRef))
		)
	to
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- cnxRef.name+'_'+fi.name+'_accessCnx_'+fi.eContainer().subcomponent.subcomponentType.ownedAnnexSubclause->indexOf(behavior).toString(),
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature(cnxRef)
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveTemp(Sequence{fi,cnxRef}, 'f_entrypoint')
		)
	do
	{
		destinationCE.setContext(thisModule.resolveTemp(Sequence{fi.eContainer(),behavior}, 'callEntryPoint'));
	}
}


-- @extends m_ThreadEntrypoint,m_ThreadBehavior
rule m_Compute_EntryPoint_from_BA {
 from 
    c : AADLI!ComponentInstance,
	behavior: AADLI!AnnexSubclause
	( 	
		c.category = #thread 
		and
		behavior.name.toLower() = 'behavior_specification'
	  	and
	  	behavior.oclIsTypeOf(AADLBA!BehaviorAnnex)
	  	and
	  	c.subcomponent.classifier.ownedAnnexSubclause->exists(e| e=behavior)
	  	and
		c.subcomponent.subcomponentType.oclIsKindOf(AADLI!ComponentImplementation)
		and
		c.subcomponent.subcomponentType.needsToMapBehaviorAnnex()
	)
 using
 {
    impl: AADLI!Thread = c.subcomponent.subcomponentType;
 	implBA: AADLBA!BehaviorAnnex = c.subcomponent.subcomponentType.ownedAnnexSubclause->any(e| e.oclIsTypeOf(AADLBA!BehaviorAnnex));
	stateTypeID: String = c.uniqueName().concat('_currentState');
 }
 to 
	entryPointImg: AADLBA!SubprogramType
	(name <- c.uniqueName()+'_entrypoint_'+impl.ownedAnnexSubclause->indexOf(behavior).toString()),
	entryPointImplImg: AADLBA!SubprogramImplementation
	(name <- c.uniqueName()+'_entrypoint_'+impl.ownedAnnexSubclause->indexOf(behavior).toString()+'.impl'),
	callEntryPoint: AADLBA!SubprogramCall,
	callSequenceImg: AADLBA!SubprogramCallSequence,
	stateType: AADLBA!DataType
	(
		name <- stateTypeID,
		ownedPropertyAssociation <- Sequence {
												
												thisModule.CreatePropertyAssociation
												(
												 	'Data_Representation',
													'DATA_MODEL',
													'Enum'.asEnumeration('DATA_MODEL').asNamedValue()
												),
												thisModule.CreatePropertyAssociation
												(
												 	'Enumerators',
													'DATA_MODEL',
													 thisModule.CreateListValueFromListOfString(implBA.states->collect(e|e.name))
												),
												thisModule.CreatePropertyAssociation
												(
												 	'Initial_Value',
													'DATA_MODEL',
													 thisModule.CreateListValueFromString(stateTypeID.getProgrammationLanguageIdentifier().concat('_')+thisModule.getBAInitialStateIdentifier(implBA))
												)
									}
	),
	currentState: AADLBA!DataSubcomponent
	(
		name <- 'Parent_BA_currentState',
		dataSubcomponentType <- stateType
	),
	currentStateAccess: AADLBA!DataAccess
	(
		name <- 'Parent_BA_currentState_Access',
		dataFeatureClassifier <- stateType,
		kind <- #requires
	),
	
	
	-- connect currentState feature of entryPointImg to the data subcomponent of the implImg that
	-- represents the state of implImg
	connectedAccess_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentStateAccess,
		context<-callEntryPoint
	),
	connectedSubcomponent_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentState
	),
	accessConnection_CURRENT_STATE: AADLBA!AccessConnection
	(
		name<-'CNX_CURRENT_STATE_BA',
		source<-connectedAccess_CURRENT_STATE,
		destination<-connectedSubcomponent_CURRENT_STATE,
		accessCategory <- #data
	),
	loop_target_actions: AADLBA!BehaviorActionSequence
	(
		-- FIXME: to be sorted by priority
		actions <- behavior.transitions->collect(e | thisModule.resolveTemp(Sequence{c, e}, 'ifStatement'))
	)
 do
 {
 	thisModule.addImportedUnit(thisModule.public(), thisModule.getLoadedAADLRuntime, thisModule.getRuntimeName);
 }
}


rule m_BehaviorActionsFromThread
{
  from
	c: AADLI!ComponentInstance,
	src_transition: AADLBA!BehaviorTransition
	(
		c.category = #thread
		and
		c.subcomponent.subcomponentType.ownedAnnexSubclause->exists(e| e = src_transition.eContainer())
	)
  using
  {
	ba: AADLBA!BehaviorAnnex = src_transition.eContainer();
	currentStateAccess: AADLBA!DataAccess = thisModule.resolveTemp(Sequence{c,ba},'currentStateAccess');
	stateType: AADLBA!DataAccess = thisModule.resolveTemp(Sequence{c,ba},'stateType');
	-- FIXME: to be sorted according to priority.
	sortedTransitions: Sequence(AADLBA!BehaviorTransition) = ba.transitions;
  }
  to
	ifStatement: AADLBA!IfStatement
	(
		logicalValueExpression <- isStateSource,
		elif <- if(sortedTransitions->first() = src_transition) then false else true endif,
		behaviorActions <- ifStatementActionSequence
	),
	ifStatementActionSequence: AADLBA!BehaviorActionSequence
	(
		actions <- 	if(src_transition.sourceState.complete=true)
					then
					c.featureInstance->select(f | (f.isInputFeature() or f.isInputOutputFeature()) and f.oclIsTypeOf(AADLI!DataPort))
					->collect(port | thisModule.resolveTemp(Sequence{port, src_transition.eContainer()}, 'call'))
					else
					Sequence{}
					endif
					->union
					(
						if(src_transition.actionBlock.content.oclIsKindOf(AADLBA!BehaviorActionCollection)) then
							src_transition.actionBlock.content.actions.resolve().debug(' NNNNN ')
						else
							Sequence{src_transition.actionBlock}
						endif
					)
					->append
					(updateState)
	),
	isStateSource: AADLBA!ValueExpression
	(
		relations <- Sequence{comparisonRelation}	
	),
	comparisonRelation: AADLBA!Relation
	(
		relationalOperator<-#Equal,
		firstExpression<-comparisonFirstExpression,
		secondExpression<-comparisonSecondExpression
	),
	comparisonFirstExpression: AADLBA!SimpleExpression
	(
		terms <- Sequence{currentStateAccessTerm}
	),
	comparisonSecondExpression: AADLBA!SimpleExpression
	(
		terms <- Sequence{enumValueSourceStateTerm}
	),
	currentStateAccessTerm: AADLBA!Term
	(
		factors <- Sequence{currentStateAccessFactor}
	),
	enumValueSourceStateTerm: AADLBA!Term
	(
		factors <- Sequence{enumValueSourceStateFactor}
	),
	currentStateAccessFactor: AADLBA!Factor
	(
		firstValue <- currentStateAccessHolder
	),
	currentStateAccessHolder:AADLBA!DataAccessHolder
	(
		element <- currentStateAccess
	),
	enumValueSourceStateFactor: AADLBA!Factor
	(
		firstValue <- sourceStateID
	),
	sourceStateID: AADLBA!BehaviorEnumerationLiteral
	(
		enumLiteral<-enumSourceStringLiteral,
		component<-stateType
	),
	enumSourceStringLiteral: AADLBA!StringLiteral
	(
		value <- src_transition.sourceState.name
	),
	updateState: AADLBA!AssignmentAction
	(
		target <- updateStateAccessHolder,
		valueExpression <- updateValueExpression
	),
	updateStateAccessHolder:AADLBA!DataAccessHolder
	(
		element <- currentStateAccess
	),
	updateValueExpression: AADLBA!ValueExpression
	(
		relations <- Sequence{updateRelation}	
	),
	updateRelation: AADLBA!Relation
	(
		firstExpression<-updateFirstExpression
	),
	updateFirstExpression: AADLBA!SimpleExpression
	(
		terms <- Sequence{enumValueTargetStateTerm}
	),
	enumValueTargetStateTerm: AADLBA!Term
	(
		factors <- Sequence{enumValueTargetStateFactor}
	),
	enumValueTargetStateFactor: AADLBA!Factor
	(
		firstValue <- targetStateID
	),
	targetStateID: AADLBA!BehaviorEnumerationLiteral
	(
		enumLiteral<-enumTargetStringLiteral,
		component<-stateType
	),
	enumTargetStringLiteral: AADLBA!StringLiteral
	(
		value <- src_transition.sourceState.name
	)
--  do
--  {
--  	thisModule.bab_content <- thisModule.copyBehaviorActionBlock(src_transition.actionBlock,c).content;
--  	if(thisModule.bab_content.oclIsKindOf(AADLBA!BehaviorActionCollection))
--	  	ifStatementActionSequence.actions.addAll(thisModule.bab_content.actions);
--  	else if (not thisModule.bab_content.oclIsUndefined())
--  		ifStatementActionSequence.actions.add(thisModule.bab_content.debug(thisModule.bab_content.getClass().toString()));
--  	ifStatementActionSequence.actions.add(updateState);
--  	
--  	for(fi in c.featureInstance)
--  	{
--  		if(fi.category=#dataPort or fi.category=#eventDataPort or fi.category=#eventPort)
--  		{
--  			if(ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().isUsedInFreshClause(ba, fi.feature))
--			{
--				for(trans in ba.transitions)
--				{
--					ifStatementActionSequence.actions.add(thisModule.resolveTemp(fi, 'updateFreshness'));
--				}
--			}
--  			else if(fi.isUsedInFresh())
--  			{
--  				for(trans in ba.transitions)
--				{
--					ifStatementActionSequence.actions.add(thisModule.resolveTemp(fi, 'updateFreshnessOutput'));
--					ifStatementActionSequence.actions.add(thisModule.resolveTemp(fi, 'sendFreshnessOutput'));
--				}
--  			}
--  		}
--  	}
--  	
--	if(src_transition.destinationState.complete=true)
--	{
--		for(fi in c.featureInstance)
--  		{
--  			if(fi.category=#dataPort and (fi.direction.getName()='out' or fi.direction.getName()='inout'))
--  			{
--  				thisModule.addPutValueSubprogramCallAction(ifStatementActionSequence.actions, fi);
--  			}
--  		}
--		thisModule.expandThreadDispatchProtocolInBA(c, ifStatementActionSequence);
--	}
--	ifStatement;
--  }
}


-- To be checked
--
--rule m_EventPortHolder
--{
--	from
--		src_EventPortHolder: AADLBA!EventPortHolder,
--		c: AADLI!ComponentInstance
--	to
--		target_EventPortHolder: AADLBA!DataSubcomponentHolder
--		(
--			element<-thisModule.resolveTemp(c.featureInstance->any(e|e.name=src_EventPortHolder.element.name), 'dataSubcomponent')	
--		)
--	do
--	{
--		target_EventPortHolder;
--	}
--}
--
--rule m_EventDataPortHolder
--{
--	from
--		src_EventDataPortHolder:AADLBA!EventDataPortHolder,
--		c: AADLI!ComponentInstance
--	to
--		target_EventDataPortHolder: AADLBA!DataSubcomponentHolder
--		(
--			element<-thisModule.resolveTemp(c.featureInstance->any(e|e.name=src_EventDataPortHolder.element.name), 'dataSubcomponent')	
--		)
--	do
--	{
--		target_EventDataPortHolder;
--	}
--}
--
--helper def: copyDataPortHolder(src_DataPortHolder:AADLBA!DataPortHolder, c: AADLI!ComponentInstance) : AADLBA!ValueVariable =
--	let f: AADLI!FeatureInstance = c.featureInstance->any(e|e.name=src_DataPortHolder.element.name) in 
--	if (f.isUsedInFresh()) then
--		thisModule.copyDataPortHolder_withFresh(src_DataPortHolder, c)
--	else
--		thisModule.copyDataPortHolder_withoutFresh(src_DataPortHolder, c)
--	endif
--;
--
--rule m_DataPortHolder_withFresh
--{
--	from
--		src_DataPortHolder:AADLBA!DataPortHolder,
--		c: AADLI!ComponentInstance
--	to
--		target_DataPortHolder: AADLBA!DataComponentReference
--		(
--			data <- Sequence{dataSubcomponentHolder,functionalPartHolder}
--			
--				
--		),
--		dataSubcomponentHolder: AADLBA!DataSubcomponentHolder
--		(
--			element<-thisModule.resolveTemp(c.featureInstance->any(e|e.name=src_DataPortHolder.element.name), 'dataSubcomponent')
--		),
--		functionalPartHolder: AADLBA!DataSubcomponentHolder
--		(
--			element<-thisModule.resolveTemp(c.featureInstance->any(e|e.name=src_DataPortHolder.element.name), 'struct_functional_data_subcomponent')
--		)
--	do
--	{
--		target_DataPortHolder;
--	}
--}
--
--rule m_DataPortHolder_withoutFresh
--{
--	from
--		src_DataPortHolder:AADLBA!DataPortHolder,
--		c: AADLI!ComponentInstance
--	to
--		target_DataPortHolder: AADLBA!DataSubcomponentHolder
--		(
--			element<-thisModule.resolveTemp(c.featureInstance->any(e|e.name=src_DataPortHolder.element.name), 'dataSubcomponent')	
--		)
--	do
--	{
--		target_DataPortHolder;
--	}
--}
--
--rule m_DataAccessHolder
--{
--	from
--		src_DataAccessHolder:AADLBA!DataAccessHolder,
--		c: AADLI!ComponentInstance
--	to
--		target_DataAccessHolder: AADLBA!DataAccessHolder
--		(
--			element<-thisModule.resolveTemp(c.featureInstance->any(e|e.name=src_DataAccessHolder.element.name), 'f_entrypoint')	
--		)
--	do
--	{
--		target_DataAccessHolder;
--	}
--}
--
--rule m_PortFreshValue
--{
--	from
--		src_PortFreshValue: AADLBA!PortFreshValue,
--		c: AADLI!ComponentInstance
--	using
--	{
--		portImgSubcomponent: AADLBA!DataSubcomponent = thisModule.resolveTemp(
--							c.featureInstance->any(e|e.name = src_PortFreshValue.element.name), 'dataSubcomponent'
--						);
--		portImgFresh_prev: AADLBA!DataAccess = thisModule.resolveTemp(
--							c.featureInstance->any(e|e.name = src_PortFreshValue.element.name), 'fresh_previous_access'
--						);
--		struct_freshness_data_subcomponent: AADLBA!DataSubcomponent = thisModule.resolveTemp(
--							c.featureInstance->any(e|e.name = src_PortFreshValue.element.name), 'struct_freshness_data_subcomponent'
--						);
--	}
--	to
--		isFresh: AADLBA!ValueExpression
--		(
--			relations <- Sequence{comparisonRelation}
--		),
--		comparisonRelation: AADLBA!Relation
--		(
--			relationalOperator<-#NotEqual,
--			firstExpression<-comparisonFirstExpression,
--			secondExpression<-comparisonSecondExpression
--		),
--		comparisonFirstExpression: AADLBA!SimpleExpression
--		(
--			terms <- Sequence{currentFreshnessTerm}
--		),
--		comparisonSecondExpression: AADLBA!SimpleExpression
--		(
--			terms <- Sequence{previousFreshnessTerm}
--		),
--		currentFreshnessTerm: AADLBA!Term
--		(
--			factors <- Sequence{currentFreshnessFactor}
--		),
--		previousFreshnessTerm: AADLBA!Term
--		(
--			factors <- Sequence{previousFreshnessFactor}
--		),
--		currentFreshnessFactor: AADLBA!Factor
--		(
--			firstValue <- Sequence{portImgFreshPrevComponentReference}
--		),
--		portImgSubcomponentHolder: AADLBA!DataSubcomponentHolder
--		(
--			element <- portImgSubcomponent
--		),
--		previousFreshnessFactor: AADLBA!Factor
--		(
--			firstValue <- Sequence{portImgFreshPrevAccessHolder}
--		),
--		portImgFreshPrevComponentReference: AADLBA!DataComponentReference
--		(
--			data <- Sequence{portImgSubcomponentHolder, portImgFreshPrevSubcomponentHolder}
--		),
--		portImgFreshPrevAccessHolder: AADLBA!DataAccessHolder
--		(
--			element <- portImgFresh_prev
--		),
--		portImgFreshPrevSubcomponentHolder: AADLBA!DataSubcomponentHolder
--		(
--			element <- struct_freshness_data_subcomponent
--		)
--	do
--	{
--		isFresh;
--	}
--}

--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore
-- @atlcompiler emftvm

module BehaviorAnnexCommonRefinementSteps;
create OUT : AADLBA 	from 		IN : AADLI,
									AADL_RUNTIME: AADLBA,
									DATA_MODEL: AADLBA,
									PROGRAMMING_PROPERTIES: AADLBA,
									HOOKS: ATLHOOKS,
									ARINC653_RUNTIME: AADLBA;

-- List


-- @extends m_ThreadPort_Filter,m_BA_Filter
abstract rule m_Port_BehaviorAnnex
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!AnnexSubclause
		(
			(fi.getComponentInstance().subcomponent.subcomponentType.getBA()=behavior)
			and not fi.isPeriodicDelayedPort()
		)
}

unique lazy rule createUpdateFreshnessToSend
{
	from
		fi: AADLI!FeatureInstance,
		cnx: AADLI!PortConnection
	to		
		-------- Emitter freshness update
		sendFreshnessOutput: AADLBA!AssignmentAction
		(
			target <- sendFreshDataComponentReference,
			valueExpression <- sendValueExpressionOutput
		),
		sendFreshDataComponentReference: AADLBA!DataComponentReference
		(
			data<-Sequence{dataSubcomponentSend,dataSubcomponentStructSend}
		),
		dataSubcomponentSend: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveMatchedSingleIfExists(fi, 'localVariable')
		),
		dataSubcomponentStructSend: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveLazySingleIfExists(fi.feature.dataFeatureClassifier, 'createFreshnessDataStructure', 'struct_freshness_data_subcomponent')
		),
		sendValueExpressionOutput: AADLBA!ValueExpression
		(
			relations <- Sequence{sendRelationOutput}	
		),
		sendRelationOutput: AADLBA!Relation
		(
			firstExpression<-sendFirstExpressionOutput
		),
		sendFirstExpressionOutput: AADLBA!SimpleExpression
		(
			terms <- Sequence{sendFreshTermOutput}
		),
		sendFreshTermOutput: AADLBA!Term
		(
			factors <- Sequence{sendFreshFactorOutput}
		),
		sendFreshFactorOutput: AADLBA!Factor
		(
			firstValue <- dataAccessHolderSend
		),
		dataAccessHolderSend: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.createFreshnessIndicatorAccess(fi)
		),
		
		
		-- to be put before a the previous action
		updateFreshnessOutput: AADLBA!AssignmentAction
		(
			target <- updatePreviousFreshAccessHolderOutput,
			valueExpression <- updateValueExpressionOutput
		),
		updatePreviousFreshAccessHolderOutput:AADLBA!DataAccessHolder
		(
			element <- thisModule.createFreshnessIndicatorAccess(fi)
		),
		updateValueExpressionOutput: AADLBA!ValueExpression
		(
			relations <- Sequence{updateRelationOutput}	
		),
		updateRelationOutput: AADLBA!Relation
		(
			firstExpression<-updateFirstExpressionOutput
		),
		updateFirstExpressionOutput: AADLBA!SimpleExpression
		(
			terms <- Sequence{updateFreshTermOutput, updateConstantTermOutput},
			binaryAddingOperators <- Sequence{#Plus}
		),
		updateFreshTermOutput: AADLBA!Term
		(
			factors <- Sequence{updateFreshFactorOutput}
		),
		updateFreshFactorOutput: AADLBA!Factor
		(
			firstValue <- dataAccessHolderOutput
		),
		dataAccessHolderOutput: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.createFreshnessIndicatorAccess(fi)
		),
		updateConstantTermOutput: AADLBA!Term
		(
			factors <- Sequence{updateConstantFactorOutput}
		),
		updateConstantFactorOutput: AADLBA!Factor
		(
			firstValue <- valueConstantOutput
		),
		valueConstantOutput: AADLBA!BehaviorIntegerLiteral
		(
			value <- 1.longValue()
		)
	do
	{
		Sequence{updateFreshnessOutput,sendFreshnessOutput};
	}
}


-- @extends m_Port_BehaviorAnnex
rule m_Input_Port_BehaviorAnnex
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!AnnexSubclause
		(
			fi.isInputFeature()
		)
	using
	{
		annexSubclause: AADLBA!AnnexSubclause = fi.getComponentInstance().subcomponent.classifier.ownedAnnexSubclause->any(e|e.name = 'behavior_specification');
	}
	to
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- fi.name+'_accessCnx_'+fi.getComponentInstance().subcomponent.subcomponentType.ownedAnnexSubclause->indexOf(annexSubclause).toString(),
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- thisModule.resolveMatchedSingleIfExists(fi, 'f')
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature()
		)
	do
	{
		destinationCE.setContext(thisModule.resolveMatchedSingleIfExists(fi.getComponentInstance(), 'callEntryPoint'));
	}
}

-- @extends m_Port_BehaviorAnnex,m_OutputFeature_Filter
rule m_Output_Port_BehaviorAnnex
{
	from
		fi: AADLI!FeatureInstance,
		behavior: AADLI!AnnexSubclause,
		cnxRef: AADLI!PortConnection
		(
			fi.srcConnectionInstance->exists(e|e.connectionReference->exists(cnx| cnx.connection = cnxRef))
		)
	using
	{
		annexSubclause: AADLBA!AnnexSubclause = fi.getComponentInstance().subcomponent.classifier.ownedAnnexSubclause->any(e|e.name = 'behavior_specification');
	}
	to
		f_connection: AADLBA!AccessConnection
		(
			source <- sourceCE,
			destination <- destinationCE,
			name <- cnxRef.uniqueName()+'_'+fi.name+'_accessCnx_'+fi.getComponentInstance().subcomponent.subcomponentType.ownedAnnexSubclause->indexOf(annexSubclause).toString(),
			accessCategory <- #data
		),
		sourceCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature(cnxRef)
		),
		destinationCE: AADLBA!ConnectedElement
		(
			connectionEnd <- fi.retreiveEntrypointFeature(cnxRef)
		)
	do
	{
		destinationCE.setContext(thisModule.resolveMatchedSingleIfExists(fi.getComponentInstance(), 'callEntryPoint'));
	}
}

-- @extends m_Thread_Instance_Filter, m_BehavioredInstance
rule m_Compute_EntryPoint_from_BA_dataAccess {
 from 
    c : AADLI!ComponentInstance,
	data: AADLI!ComponentInstance
	(
	  	not c.subcomponent.classifier.getBA().oclIsUndefined()
		and
		data.eContainer()=c
		and
		AADLBA!ElementHolder.allInstances(c.subcomponent.classifier.getBA())->exists(f|f.element = data.subcomponent)
	)
  to
  	dataAccess: AADLBA!DataAccess
	(
		name <- data.name+'_accessForBA',
		dataFeatureClassifier <- data.subcomponent.dataSubcomponentType,
		kind <- #requires
	)
  do
  {
  	thisModule.addImportedUnitFromInputModel(thisModule.public(), data.subcomponent.dataSubcomponentType);
  }
}

-- @extends m_ThreadBehavior, m_BehavioredInstance
rule m_Compute_EntryPoint_from_BA {
 from 
    c : AADLI!ComponentInstance,
	behavior: AADLI!AnnexSubclause
	(
        c.category = #thread 
        and
		behavior.oclIsTypeOf(AADLBA!BehaviorAnnex)
	  	and
	  	c.subcomponent.classifier.getBA() = behavior
	  	and
		c.subcomponent.subcomponentType.oclIsKindOf(AADLI!ComponentImplementation)
		and
		c.subcomponent.subcomponentType.needsToMapBehaviorAnnex()
	)
 using
 {
    impl: AADLI!Thread = c.subcomponent.subcomponentType;
 	implBA: AADLBA!BehaviorAnnex = c.subcomponent.subcomponentType.getBA();
	annexSubclause: AADLBA!AnnexSubclause = c.subcomponent.classifier.ownedAnnexSubclause->any(e|e.name = 'behavior_specification');
	stateTypeID: String = c.uniqueName().concat('_currentState');
 }
 to 

	stateType: AADLBA!DataType
	(
		name <- stateTypeID,
		ownedPropertyAssociation <- Sequence {
												
												thisModule.CreatePropertyAssociation
												(
												 	'Data_Representation',
													'DATA_MODEL',
													'Enum'.asEnumeration('DATA_MODEL').asNamedValue()
												),
												thisModule.CreatePropertyAssociation
												(
												 	'Enumerators',
													'DATA_MODEL',
													 thisModule.CreateListValueFromListOfString(implBA.states->collect(e|e.name))
												),
												thisModule.CreatePropertyAssociation
												(
												 	'Initial_Value',
													'DATA_MODEL',
													 thisModule.CreateListValueFromString(c.targetPackagePrefix()+stateTypeID.getProgrammationLanguageIdentifier().concat('_')+thisModule.getBAInitialStateIdentifier(implBA))
												)
									}
	),
	-- To be added in entryPointImg
	currentState: AADLBA!DataSubcomponent
	(
		name <- c.name+'Parent_BA_currentState',
		dataSubcomponentType <- stateType
	),
	-- to be added in implImg
	currentStateAccess: AADLBA!DataAccess
	(
		name <- 'Parent_BA_currentState_Access',
		dataFeatureClassifier <- stateType,
		kind <- #requires
	),
	currentStateAccessThread: AADLBA!DataAccess
	(
		name <- 'Parent_BA_currentState_Access',
		dataFeatureClassifier <- stateType,
		kind <- #requires
	),
	
	-- connect currentState feature of entryPointImg to the data subcomponent of the implImg that
	-- represents the state of implImg
	connectedAccess_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentStateAccess,
		context<-thisModule.resolveMatchedSingleIfExists(c, 'callEntryPoint')
	),
	connectedSubcomponent_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentStateAccessThread
	),
	accessConnection_CURRENT_STATE: AADLBA!AccessConnection
	(
		name<-'CNX_CURRENT_STATE_BA',
		source<-connectedAccess_CURRENT_STATE,
		destination<-connectedSubcomponent_CURRENT_STATE,
		accessCategory <- #data
	),
	
	connectedAccessThread_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentStateAccessThread,
		context<-c
	),
	connectedSubcomponentThread_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentState
	),
	accessConnection_CURRENT_STATE_THREAD: AADLBA!AccessConnection
	(
		name<-c.name+'_CNX_CURRENT_STATE_BA',
		source<-connectedAccessThread_CURRENT_STATE,
		destination<-connectedSubcomponentThread_CURRENT_STATE,
		accessCategory <- #data
	),
	
	computeEntryPointTransition: AADLBA!BehaviorTransition
	(
		name <- behavior.name+'_'+c.subcomponent.subcomponentType.ownedAnnexSubclause->indexOf(annexSubclause).toString()
	),
	computeEntryPointActions: AADLBA!BehaviorActionSequence
	(
		actions <- if c.needsModeVariable() then
					Sequence{thisModule.createModeVariableUpdate(c)}
					else 
					Sequence{} 
					endif
				->union
				(
					c.featureInstance->select(fi| 
						fi.isInputFeature() and
						(fi.isEventPort() or fi.isEventDataPort())
					)
					->collect(fi|thisModule.createReceiveInputCall(fi))
				)
				->union
				(
					behavior.transitions->collect(trans|trans.usedPortCount()->collect(e| thisModule.createPortCountValueUpdate(c.featureInstance->any(p|p.feature = e))))
					->flatten()
					->append(
						thisModule.resolveMatchedTupleIfExists(Sequence{c,
							behavior.transitions
								->sortedBy(e| 0.longValue().minus(e.priority))
								->first()},'target_BehaviorElement')
						)
				)
	)
 do
 {
 	thisModule.addImportedUnit(thisModule.public(), thisModule.getLoadedAADLRuntime, thisModule.getRuntimeName);
 	for(fi in c.featureInstance->select(fi | fi.feature.oclIsKindOf(AADLBA!Port) and fi.isUsedInFresh()))
 	{
 		thisModule.resolveLazySingleIfExists(fi, 'createFreshnessIndicator', 'freshnessIndicator_CnxDestination').setContext(thisModule.resolveMatchedSingleIfExists(c, 'callEntryPoint'));
 	}
 }
}

-- Next rule should be overriden as it is target specific
unique lazy rule createModeVariableUpdate
{
	from
		c: AADLI!ComponentInstance
	to
		
}

helper context OclAny def: resolve(c: AADLI!ComponentInstance): OclAny =
	if(self.oclIsUndefined()) then
		OclUndefined
	else
		self.debug(' WARNING, untreatead type')
	endif
;

helper context  AADLBA!BehaviorVariable def: resolve(c: AADLI!ComponentInstance): AADLBA!BehaviorVariable =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!BehaviorActionBlock  def: resolve(c: AADLI!ComponentInstance): AADLBA!BehaviorActionBlock =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!BehaviorActionSequence def: resolve(c: AADLI!ComponentInstance): AADLBA!BehaviorActionSequence =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!AssignmentAction def: resolve(c: AADLI!ComponentInstance): AADLBA!SubprogramCallAction =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!SubprogramCallAction def: resolve(c: AADLI!ComponentInstance): AADLBA!SubprogramCallAction =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!IfStatement def: resolve(c: AADLI!ComponentInstance): AADLBA!IfStatement =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!ElseStatement def: resolve(c: AADLI!ComponentInstance): AADLBA!IfStatement =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!ElementHolder def: resolve(c: AADLI!ComponentInstance): AADLBA!ElementHolder =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!PropertyElementHolder def: resolve(c: AADLI!ComponentInstance): AADLBA!ElementHolder =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

lazy rule getValueComponentReference
{
	from
		fi:AADLI!FeatureInstance
	using
	{
		inderectlyUsed: AADLBA!DataImplementation = thisModule.createFreshnessDataStructure(fi.feature.dataFeatureClassifier);
		portImgSubcomponent: AADLBA!DataSubcomponent = thisModule.resolveMatchedSingleIfExists(fi, 'localVariable');
	}
	to
		valueDCR: AADLBA!DataComponentReference
		(
			data <- Sequence{portImgSubcomponentHolder, portImgFreshPrevSubcomponentHolder}
		),
		portImgSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- portImgSubcomponent
		),
		portImgFreshPrevSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.resolveLazySingleIfExists(
							fi.feature.dataFeatureClassifier, 'createFreshnessDataStructure', 'struct_functional_data_subcomponent'
						)
		)
	do
	{
		valueDCR;
	}
}

helper context AADLBA!PortHolder def: resolve(c: AADLI!ComponentInstance): AADLBA!ElementHolder =
	let fi:AADLI!FeatureInstance = c.featureInstance->any(e| e.feature = self.element) in
	if(fi.isUsedInFresh()) then 
		thisModule.getValueComponentReference(fi)
	else
		thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
	endif
;

helper context AADLBA!ClassifierPropertyReference def: resolve(c: AADLI!ComponentInstance): AADLBA!ClassifierPropertyReference =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!PropertySetPropertyReference def: resolve(c: AADLI!ComponentInstance): AADLBA!PropertySetPropertyReference =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!PropertyNameHolder def: resolve(c: AADLI!ComponentInstance): AADLBA!PropertyNameHolder =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!UpperBound def: resolve(c: AADLI!ComponentInstance): AADLBA!UpperBound =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!LowerBound def: resolve(c: AADLI!ComponentInstance): AADLBA!LowerBound =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!PortFreshValue def: resolve(c: AADLI!ComponentInstance): AADLBA!ElementHolder =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!Factor def: resolve(c: AADLI!ComponentInstance): AADLBA!ElementHolder =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!Term def: resolve(c: AADLI!ComponentInstance): AADLBA!ElementHolder =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!BehaviorIntegerLiteral def: resolve(c: AADLI!ComponentInstance): AADLBA!BehaviorIntegerLiteral =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!ValueExpression def: resolve(c: AADLI!ComponentInstance): AADLBA!ValueExpression =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!Relation def: resolve(c: AADLI!ComponentInstance): AADLBA!Relation =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!SimpleExpression def: resolve(c: AADLI!ComponentInstance): AADLBA!SimpleExpression =
	thisModule.resolveMatchedTupleIfExists(Sequence{self,c}, 'target_BehaviorElement')
;

helper context AADLBA!BehaviorTransition def: usedPortCount() : Sequence(AADLBA!Port) =
	thisModule.theHOOK.allPortCount(self)
;

-- next rule needs a target specific implementation
lazy rule createPortCountValueUpdate
{
	from
		fi: AADLI!FeatureInstance
}

-- @extends m_BehavioredInstance
rule m_BehaviorActionsFromThread
{
  from
	c: AADLI!ComponentInstance,
	src_transition: AADLBA!BehaviorTransition
	(
		c.category = #thread 
		and 
		c.subcomponent.subcomponentType.oclIsKindOf(AADLI!ComponentImplementation)
		and
		c.subcomponent.subcomponentType.getBA() = src_transition.eContainer()
	)
  using
  {
	ba: AADLBA!BehaviorAnnex = src_transition.eContainer();
	currentStateAccess: AADLBA!DataAccess = thisModule.resolveMatchedTupleIfExists(Sequence{c,ba},'currentStateAccess');
	stateType: AADLBA!DataClassifier = thisModule.resolveMatchedTupleIfExists(Sequence{c,ba},'stateType');
	-- FIXME: to be sorted according to priority.
	sortedTransitions: Sequence(AADLBA!BehaviorTransition) = ba.transitions->sortedBy(e| 0.longValue().minus(e.priority));
  }
  to
	target_BehaviorElement: AADLBA!IfStatement
	(
		logicalValueExpression <- isStateSource,
		elif <- if(sortedTransitions->first() = src_transition) then false else true endif,
		behaviorActions <- ifStatementActionSequence,
		elseStatement <- let index: Integer = sortedTransitions->indexOf(src_transition) in 
						if(index>0 and sortedTransitions->size() > index) then
							thisModule.resolveMatchedTupleIfExists(Sequence{c,
								sortedTransitions->at(index+1)}, 'target_BehaviorElement')
						else
							OclUndefined
						endif
	),
	ifStatementActionSequence: AADLBA!BehaviorActionSequence
	(
		actions <- 	if(src_transition.sourceState.complete=true)
					then
						c.featureInstance->select(f | (f.isInputFeature() or f.isInputOutputFeature()) and f.feature.oclIsTypeOf(AADLI!DataPort))
						->collect
							(port | 
								thisModule.resolveMatchedTupleIfExists(Sequence{port, src_transition.eContainer()}, 'call')
							)
					else
						Sequence{}
					endif
					->union
					(
						if(src_transition.actionBlock.oclIsUndefined()) then
							Sequence{}
						else
							if(src_transition.actionBlock.content.oclIsKindOf(AADLBA!BehaviorActionCollection)) then
								src_transition.actionBlock.content.actions->collect( e| e.resolve(c))
					   		else
					   			Sequence{src_transition.actionBlock.content.resolve(c)}
					   		endif
						endif
					)
					->flatten()
					->union(
						c.featureInstance->select(f| (f.isInputFeature() or f.isInputOutputFeature()) and f.feature.oclIsTypeOf(AADLI!DataPort) and f.isUsedInFresh())
						->collect( e | 
							thisModule.createFreshnessIndicatorUpdateAction(e)
						)
					)
					->union(
						c.featureInstance->select(f| (f.isOutputFeature() or f.isInputOutputFeature()) and f.feature.oclIsTypeOf(AADLI!DataPort) and f.isUsedInFresh())
						->collect( e | 
							e.srcConnectionInstance->collect(
								cnx| thisModule.createUpdateFreshnessToSend(e, cnx.connectionReference->first().connection)
							)
						)
					)
					->append(updateState)
					->union
					(
						if(src_transition.destinationState.complete=true)
						then
						c.featureInstance->select(f | (f.isOutputFeature() or f.isInputOutputFeature()) and f.feature.oclIsTypeOf(AADLI!DataPort))
						->collect(port | 
							port.srcConnectionInstance->collect
							(
								cnxInst | thisModule.resolveMatchedTupleIfExists(Sequence{port, src_transition.eContainer(), cnxInst.connectionReference->first().connection}, 'call')
							)
						)
						else
						Sequence{}
						endif
					)
					->flatten()
					->excluding(OclUndefined)
	),
	isStateSource: AADLBA!ValueExpression
	(
		relations <- Sequence{comparisonRelation}
						->union(if src_transition.condition.oclIsTypeOf(AADLBA!ValueExpression)
								then
									src_transition.condition.relations
									->collect(e|e.resolve(c))
								else
									Sequence{}
								endif	
								)
						->excluding(OclUndefined),
		logicalOperators <- if src_transition.condition.oclIsKindOf(AADLBA!ValueExpression) 
							then
								Sequence{#And}
								-> union(
									src_transition.condition.logicalOperators
								)
							else
								Sequence{}
							endif
	),
	comparisonRelation: AADLBA!Relation
	(
		relationalOperator<-#Equal,
		firstExpression<-comparisonFirstExpression,
		secondExpression<-comparisonSecondExpression
	),
	comparisonFirstExpression: AADLBA!SimpleExpression
	(
		terms <- Sequence{currentStateAccessTerm}
	),
	comparisonSecondExpression: AADLBA!SimpleExpression
	(
		terms <- Sequence{enumValueSourceStateTerm}
	),
	currentStateAccessTerm: AADLBA!Term
	(
		factors <- Sequence{currentStateAccessFactor}
	),
	enumValueSourceStateTerm: AADLBA!Term
	(
		factors <- Sequence{enumValueSourceStateFactor}
	),
	currentStateAccessFactor: AADLBA!Factor
	(
		firstValue <- currentStateAccessHolder
	),
	currentStateAccessHolder:AADLBA!DataAccessHolder
	(
		element <- currentStateAccess
	),
	enumValueSourceStateFactor: AADLBA!Factor,
	updateState: AADLBA!AssignmentAction
	(
		target <- updateStateAccessHolder,
		valueExpression <- updateValueExpression
	),
	updateStateAccessHolder:AADLBA!DataAccessHolder
	(
		element <- currentStateAccess
	),
	updateValueExpression: AADLBA!ValueExpression
	(
		relations <- Sequence{updateRelation}	
	),
	updateRelation: AADLBA!Relation
	(
		firstExpression<-updateFirstExpression
	),
	updateFirstExpression: AADLBA!SimpleExpression
	(
		terms <- Sequence{enumValueTargetStateTerm}
	),
	enumValueTargetStateTerm: AADLBA!Term
	(
		factors <- Sequence{enumValueTargetStateFactor}
	),
	enumValueTargetStateFactor: AADLBA!Factor
  do
  {
  	enumValueSourceStateFactor.firstValue
					<- thisModule.bindDatatypeEnumStringliteral
					  (
					    stateType,
						src_transition.sourceState.name
					  );
    enumValueTargetStateFactor.firstValue 
					<- thisModule.bindDatatypeEnumStringliteral
					  (
					    stateType,
						src_transition.destinationState.name
					  );
  }
}

---- @extends m_BehaviorActionsFromThread
--rule m_BehaviorActionsFromThread_Periodic
--{
--	from
--		c: AADLI!ComponentInstance,
--		src_transition: AADLBA!BehaviorTransition
--		(
--			c.isPeriodicThread()
--			and
--			c.subcomponent.subcomponentType.getBA() = src_transition.eContainer()
--			and
--			src_transition.destinationState.complete=true
--		)
--	using
--	{
--		ba: AADLBA!BehaviorAnnex = src_transition.eContainer();
--		spg : AADLBA!SubprogramType = thisModule.getWaitPeriodSubprogram;
--	}
--	to
--		callSequenceImg: AADLBA!SubprogramCallSequence,
--		returnData: AADLBA!DataSubcomponent,
--		waitDispatchCall: AADLBA!SubprogramCallAction
--		(
--			subprogram<-dispatchHolder,
--			parameterLabels <- Sequence{RETURN_DATA_Holder}
--		),
--		dispatchHolder: AADLBA!CalledSubprogramHolder
--		(
--			element <- spg
--		),
--		RETURN_DATA_Holder: AADLBA!DataSubcomponentHolder
--		(
--			element<-thisModule.resolveMatchedSingleIfExists(c, 'returnData')
--		)
--	do
--	{
--		thisModule.addImportedUnit(thisModule.public(), thisModule.getLoadedAADLRuntime, thisModule.getRuntimeName);
--	}
--}

unique lazy rule createFreshnessIndicatorUpdateAction
{
	from
		fi: AADLI!FeatureInstance
	to
		updateFreshness: AADLBA!AssignmentAction
		(
			target <- updatePreviousFreshAccessHolder,
			valueExpression <- updateValueExpression
		),
		updatePreviousFreshAccessHolder:AADLBA!DataAccessHolder
		(
			element <- thisModule.createFreshnessIndicatorAccess(fi)
		),
		updateValueExpression: AADLBA!ValueExpression
		(
			relations <- Sequence{updateRelation}	
		),
		updateRelation: AADLBA!Relation
		(
			firstExpression<-updateFirstExpression
		),
		updateFirstExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{updateFreshTerm}
		),
		updateFreshTerm: AADLBA!Term
		(
			factors <- Sequence{updateFreshFactor}
		),
		updateFreshFactor: AADLBA!Factor
		(
			firstValue <- updateFreshCDR
		),
		updateFreshCDR: AADLBA!DataComponentReference
		(
			data <- Sequence{dataSubcomponentHolder,dataFreshnessSubcomponentHolder}
		),
		dataSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.resolveMatchedSingleIfExists(fi, 'localVariable')
		),
		dataFreshnessSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.resolveLazySingleIfExists(fi.feature.dataFeatureClassifier, 'createFreshnessDataStructure', 'struct_freshness_data_subcomponent')
		)
	do
	{
		updateFreshness;
	}
}



abstract rule m_BehavioredInstance
{
	from
		c: AADLI!ComponentInstance
		(
			(c.oclIsKindOf(AADLI!SystemInstance)
			and
			not c.componentImplementation.getBA().oclIsUndefined())
			or
			(
				not c.subcomponent.oclIsUndefined()
				and
				not c.subcomponent.subcomponentType.getBA().oclIsUndefined()
			)
		)
}

abstract rule m_BehaviorElement 
{
	from
		src_BehaviorElement: AADLBA!BehaviorElement,
		c: AADLI!ComponentInstance
		(
			src_BehaviorElement.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_BehaviorElement: AADLBA!BehaviorElement
}

-- @extends m_BehaviorElement,m_BehavioredInstance
rule m_ElseStatement
{
	from
		src_BehaviorElement: AADLBA!ElseStatement,
		c: AADLI!ComponentInstance
		(
			not src_BehaviorElement.oclIsTypeOf(AADLBA!IfStatement)
			and
			src_BehaviorElement.isThreadBehaviorElement()
		)
	to
		target_BehaviorElement: AADLBA!ElseStatement
		(
			behaviorActions <- elseStatementActionSequence
		),
		elseStatementActionSequence: AADLBA!BehaviorActionSequence
		(
			actions <- if(src_BehaviorElement.behaviorActions.oclIsKindOf(AADLBA!BehaviorActionCollection)) then
						src_BehaviorElement.behaviorActions.actions->collect( e| e.resolve(c))
					   else
					   	Sequence{src_BehaviorElement.behaviorActions.resolve(c)}
					   endif
		)
}

-- @extends m_BehaviorElement,m_BehavioredInstance
rule m_IfStatement
{
	from
		src_BehaviorElement: AADLBA!IfStatement,
		c: AADLI!ComponentInstance
		(
			not src_BehaviorElement.oclIsTypeOf(AADLBA!ElseStatement)
			and
			src_BehaviorElement.isThreadBehaviorElement()
		)
	to
		target_BehaviorElement: AADLBA!IfStatement
		(
			logicalValueExpression <- src_BehaviorElement.logicalValueExpression.resolve(c),
			elif <- src_BehaviorElement.elif.resolve(c),
			behaviorActions <- ifStatementActionSequence,
			elseStatement <- src_BehaviorElement.elseStatement.resolve(c)
		),
		ifStatementActionSequence: AADLBA!BehaviorActionSequence
		(
			actions <- if(src_BehaviorElement.behaviorActions.oclIsKindOf(AADLBA!BehaviorActionCollection)) then
						src_BehaviorElement.behaviorActions.actions->collect( e| e.resolve(c))
					   else
					   	Sequence{src_BehaviorElement.behaviorActions.resolve(c)}
					   endif
		)
}

-- @extends m_BehaviorElement,m_BehavioredInstance
rule m_BehaviorActionBlock
{
	from
		src_BehaviorElement: AADLBA!BehaviorActionBlock,
		c: AADLI!ComponentInstance
	to
	    target_BehaviorElement: AADLBA!BehaviorActionBlock
		(
			content <- src_BehaviorElement.content.resolve(c)
		)
}

-- @extends m_BehaviorElement,m_BehavioredInstance
rule m_BehaviorActionSequence
{
	from
		src_BehaviorElement: AADLBA!BehaviorActionSequence,
		c: AADLI!ComponentInstance
		(
			src_BehaviorElement.isThreadBehaviorElement()
		)
	to
		target_BehaviorElement: AADLBA!BehaviorActionSequence
		(
			actions <- src_BehaviorElement.actions->collect(e| e.resolve(c))
		)
}

-- @extends m_BehaviorElement,m_BehavioredInstance
rule m_EventPortHolder
{
	from
		src_BehaviorElement: AADLBA!EventPortHolder,
		c: AADLI!ComponentInstance
		(
			let f: AADLI!FeatureInstance = c.featureInstance->any(e|e.name=src_BehaviorElement.element.name) in 
			c.featureInstance->exists(fi| fi.feature = src_BehaviorElement.element)
		)
	to
		target_BehaviorElement: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveMatchedSingleIfExists(c.featureInstance->any(e|e.name=src_BehaviorElement.element.name), 'localVariable')	
		)
}

-- @extends m_BehaviorElement,m_BehavioredInstance
rule m_EventDataPortHolder
{
	from
		src_BehaviorElement:AADLBA!EventDataPortHolder,
		c: AADLI!ComponentInstance
		(
			let f: AADLI!FeatureInstance = c.featureInstance->any(e|e.name=src_BehaviorElement.element.name) in 
			c.featureInstance->exists(fi| fi.feature = src_BehaviorElement.element)
		)
	to
		target_BehaviorElement: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveMatchedSingleIfExists(c.featureInstance->any(e|e.name=src_BehaviorElement.element.name), 'localVariable')	
		)
}

-- @extends m_BehaviorElement,m_BehavioredInstance
rule m_DataSubcomponentHolder
{
	from
		src_BehaviorElement: AADLBA!DataSubcomponentHolder,
		c: AADLI!ComponentInstance
		(
			c.componentInstance->exists(e|e.subcomponent=src_BehaviorElement.element)
		)
	using
	{
		dataInstance: AADLI!ComponentInstance = c.componentInstance->any(e|e.subcomponent = src_BehaviorElement.element);
		impl: AADLI!ThreadImplementation = c.subcomponent.subcomponentType;
	}
	to
		target_BehaviorElement: AADLBA!DataAccessHolder
		(
			element<-thisModule.resolveMatchedTupleIfExists(Sequence{c,dataInstance}, 'dataAccess')
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_BehaviorVariable
{
	from
		src_BehaviorElement: AADLBA!BehaviorVariable,
		c: AADLI!ComponentInstance
		(src_BehaviorElement.isThreadBehaviorElement())
	to
		target_BehaviorElement: AADLBA!BehaviorVariable
		(
			name           <- src_BehaviorElement.name,
			dataClassifier <- src_BehaviorElement.dataClassifier
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_BehaviorVariableHolder
{
	from
		src_BehaviorElement: AADLBA!BehaviorVariableHolder,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!BehaviorVariableHolder
		(
			element <- src_BehaviorElement.element.resolve(c)
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_SubprogramHolder
{
	from
		src_BehaviorElement: AADLBA!SubprogramHolder,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!SubprogramHolder
		(
			element <- src_BehaviorElement.element
		)
	do
	{
		thisModule.addImportedUnitFromInputModel(thisModule.public(), src_BehaviorElement.element);
	}
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_DataPortHolder_withFresh
{
	from
		src_BehaviorElement:AADLBA!DataPortHolder,
		c: AADLI!ComponentInstance
		(
			let f: AADLI!FeatureInstance = c.featureInstance->any(e|e.feature.name=src_BehaviorElement.element.name) in 
			c.featureInstance->exists(fi| fi.feature = src_BehaviorElement.element)
			and
			f.isUsedInFresh()
		)
	to
		target_BehaviorElement: AADLBA!DataComponentReference
		(
			data <- Sequence{dataSubcomponentHolder,functionalPartHolder}
		),
		dataSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveMatchedSingleIfExists(c.featureInstance->any(e|e.name=src_BehaviorElement.element.name), 'localVariable')
		),
		functionalPartHolder: AADLBA!DataSubcomponentHolder
	do
	{
		functionalPartHolder.element<-thisModule.resolveLazySingleIfExists(c.featureInstance->any(e|e.name=src_BehaviorElement.element.name).feature.dataFeatureClassifier, 'createFreshnessDataStructure','struct_functional_data_subcomponent');
	}
}
		
-- @extends m_ElementHolder
rule m_DataPortHolder
{
	from
		src_BehaviorElement:AADLBA!DataPortHolder,
		c: AADLI!ComponentInstance
		(
			let f: AADLI!FeatureInstance = c.featureInstance->any(e|e.name=src_BehaviorElement.element.name) in 
			c.featureInstance->exists(fi| fi.feature = src_BehaviorElement.element)
			and
			not f.isUsedInFresh()
		)
	to
		target_BehaviorElement: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveMatchedSingleIfExists(c.featureInstance->any(e|e.name=src_BehaviorElement.element.name), 'localVariable')	
		)
}

-- @extends m_ElementHolder
rule m_PortCountValue
{
	from
		src_BehaviorElement:AADLBA!PortCountValue,
		c: AADLI!ComponentInstance
		(
			let f: AADLI!FeatureInstance = c.featureInstance->any(e|e.name=src_BehaviorElement.element.name) in 
			c.featureInstance->exists(fi| fi.feature = src_BehaviorElement.element)
		)
	using
	{
		fi: AADLI!FeatureInstance = c.featureInstance->any(e|e.name=src_BehaviorElement.element.name);
	}
	to
		target_BehaviorElement: AADLBA!DataSubcomponentHolder
		(
			element <- thisModule.createPortCountSubcomponent(fi)
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
abstract rule m_PropertyReference
{
	from
		src_BehaviorElement: AADLBA!PropertyReference,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!PropertyReference
		(
			properties <- src_BehaviorElement.properties->collect(propertyname| propertyname.resolve(c))
		)
}

-- @extends m_PropertyReference
rule m_ClassifierPropertyReference
{
	from
		src_BehaviorElement: AADLBA!ClassifierPropertyReference,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!ClassifierPropertyReference
		(
			classifier <- src_BehaviorElement.classifier
		)
}

-- @extends m_PropertyReference
rule m_PropertySetPropertyReference
{
	from
		src_BehaviorElement: AADLBA!PropertySetPropertyReference,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!PropertySetPropertyReference
		(
			propertyset <- src_BehaviorElement.propertyset
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_PropertyNameHolder
{
	from
		src_BehaviorElement: AADLBA!PropertyNameHolder,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!PropertyNameHolder
		(
			property <- src_BehaviorElement.property.resolve(c),
			
			field <- if src_BehaviorElement.field.oclIsUndefined() then 
						OclUndefined
					else 
						src_BehaviorElement.field.resolve(c)
					endif
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
abstract rule m_PropertyElementHolder
{
	from
		src_BehaviorElement: AADLBA!PropertyElementHolder,
		c: AADLI!ComponentInstance
		(
			src_BehaviorElement.isPartOfBehaviorAnnexOf(c) 
		)
	to
		target_BehaviorElement: AADLBA!PropertyElementHolder
		(
			element <- src_BehaviorElement.element
		)
}

-- @extends m_PropertyElementHolder
rule m_EnumLiteralHolder
{
	from
		src_BehaviorElement: AADLBA!EnumLiteralHolder,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!EnumLiteralHolder
}

-- @extends m_PropertyElementHolder
rule m_PropertyExpressionHolder
{
	from
		src_BehaviorElement: AADLBA!PropertyExpressionHolder,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!PropertyExpressionHolder
}

-- @extends m_PropertyElementHolder
rule m_PropertyAssociationHolder
{
	from
		src_BehaviorElement: AADLBA!PropertyAssociationHolder,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!PropertyAssociationHolder
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_UpperBound
{
	from
		src_BehaviorElement: AADLBA!UpperBound,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!UpperBound
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_LowerBound
{
	from
		src_BehaviorElement: AADLBA!LowerBound,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!LowerBound
}

-- @extends m_CommunicationAction, m_BehavioredInstance
rule m_SubprogramCallAction
{
	from
		src_BehaviorElement: AADLBA!SubprogramCallAction,
		c: AADLI!ComponentInstance
		(
			src_BehaviorElement.isPartOfBehaviorAnnexOf(c)
		)
	to
		target_BehaviorElement: AADLBA!SubprogramCallAction
		(
			subprogram <- src_BehaviorElement.subprogram.resolve(c),
			parameterLabels <- src_BehaviorElement.parameterLabels
								->collect(param | param.resolve(c)),
			proxy <- src_BehaviorElement.proxy.resolve(c)
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_AssignmentAction
{
	from
		src_BehaviorElement: AADLBA!AssignmentAction,
		c: AADLI!ComponentInstance
		(
			src_BehaviorElement.isThreadBehaviorElement()
		)
	to
		target_BehaviorElement: AADLBA!AssignmentAction
		(
			target <- src_BehaviorElement.target.resolve(c),
			valueExpression <- src_BehaviorElement.valueExpression.resolve(c)
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_Term {
	from
		src_BehaviorElement: AADLBA!Term,
		c: AADLI!ComponentInstance
		(	
			src_BehaviorElement.isThreadBehaviorElement()
		)
	to
		target_BehaviorElement: AADLBA!Term
		(
			factors <- src_BehaviorElement.factors->collect(factor| factor.resolve(c)),
			multiplyingOperators <- src_BehaviorElement.multiplyingOperators
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_Factor {
	from
		src_BehaviorElement: AADLBA!Factor,
		c: AADLI!ComponentInstance
		(
			src_BehaviorElement.isThreadBehaviorElement()
		)
	to
		target_BehaviorElement: AADLBA!Factor
		(
			firstValue <- src_BehaviorElement.firstValue.resolve(c),
			secondValue <- src_BehaviorElement.secondValue.resolve(c),
			binaryNumericOperator <- src_BehaviorElement.binaryNumericOperator,
			unaryNumericOperator <- src_BehaviorElement.unaryNumericOperator,
			unaryBooleanOperator <- src_BehaviorElement.unaryBooleanOperator
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_BehaviorIntegerLiteral
{
	from
		src_BehaviorElement: AADLBA!BehaviorIntegerLiteral,
		c: AADLI!ComponentInstance
		(
			src_BehaviorElement.isThreadBehaviorElement()
		)
	to
		target_BehaviorElement: AADLBA!BehaviorIntegerLiteral
		(
			base <- src_BehaviorElement.base,
			value <- src_BehaviorElement.value
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_ValueExpression
{
	from
		src_BehaviorElement: AADLBA!ValueExpression,
		c: AADLI!ComponentInstance
		(
			src_BehaviorElement.isThreadBehaviorElement()
		)
	to
		target_BehaviorElement: AADLBA!ValueExpression
		(
			relations <- src_BehaviorElement.relations->collect(e|e.resolve(c)),
			logicalOperators <- src_BehaviorElement.logicalOperators
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_Relation
{
	from
		src_BehaviorElement: AADLBA!Relation,
		c: AADLI!ComponentInstance
		(
			src_BehaviorElement.isThreadBehaviorElement()
		)
	to
		target_BehaviorElement: AADLBA!Relation
		(
			firstExpression <- src_BehaviorElement.firstExpression.resolve(c),
			relationalOperator <- src_BehaviorElement.relationalOperator,
			secondExpression <- src_BehaviorElement.secondExpression.resolve(c)
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_SimpleExpression {
	from
		src_BehaviorElement : AADLBA!SimpleExpression,
		c: AADLI!ComponentInstance
		(
			src_BehaviorElement.isThreadBehaviorElement()
		)
	to 
		target_BehaviorElement : AADLBA!SimpleExpression
		(
			unaryAddingOperator <- src_BehaviorElement.unaryAddingOperator,
			terms <- src_BehaviorElement.terms->collect(e|e.resolve(c)),
			binaryAddingOperators <- src_BehaviorElement.binaryAddingOperators
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_DataAccessHolder
{
	from
		src_BehaviorElement:AADLBA!DataAccessHolder,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!DataAccessHolder
		(
			element<-c.featureInstance->any(e|e.name=src_BehaviorElement.element.name)	
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_ParameterHolder
{
	from
		src_BehaviorElement:AADLBA!ParameterHolder,
		c: AADLI!ComponentInstance
	to
		target_BehaviorElement: AADLBA!ParameterHolder
		(
			element<-c.featureInstance->any(e|e.name=src_BehaviorElement.element.name)	
		)
}

-- @extends m_BehaviorElement, m_BehavioredInstance
rule m_PortFreshValue
{
	from
		src_BehaviorElement: AADLBA!PortFreshValue,
		c: AADLI!ComponentInstance
		(c.featureInstance->exists(e| e.feature = src_BehaviorElement.element))
	using
	{
		portImgSubcomponent: AADLBA!DataSubcomponent = thisModule.resolveMatchedSingleIfExists(
							c.featureInstance->any(e|e.name = src_BehaviorElement.element.name), 'localVariable'
						);
	}
	to
		target_BehaviorElement: AADLBA!ValueExpression
		(
			relations <- Sequence{comparisonRelation}
		),
		comparisonRelation: AADLBA!Relation
		(
			relationalOperator<-#NotEqual,
			firstExpression<-comparisonFirstExpression,
			secondExpression<-comparisonSecondExpression
		),
		comparisonFirstExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{currentFreshnessTerm}
		),
		comparisonSecondExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{previousFreshnessTerm}
		),
		currentFreshnessTerm: AADLBA!Term
		(
			factors <- Sequence{currentFreshnessFactor}
		),
		previousFreshnessTerm: AADLBA!Term
		(
			factors <- Sequence{previousFreshnessFactor}
		),
		currentFreshnessFactor: AADLBA!Factor
		(
			firstValue <- portImgFreshPrevComponentReference
		),
		portImgSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- portImgSubcomponent
		),
		previousFreshnessFactor: AADLBA!Factor
		(
			firstValue <- portImgFreshPrevAccessHolder
		),
		portImgFreshPrevComponentReference: AADLBA!DataComponentReference
		(
			data <- Sequence{portImgSubcomponentHolder, portImgFreshPrevSubcomponentHolder}
		),
		portImgFreshPrevAccessHolder: AADLBA!DataAccessHolder
		(
			element <- thisModule.createFreshnessIndicatorAccess(
							c.featureInstance->any(e|e.feature = src_BehaviorElement.element)
						)
		),
		portImgFreshPrevSubcomponentHolder: AADLBA!DataSubcomponentHolder
	do
	{
		portImgFreshPrevSubcomponentHolder.element <- thisModule.resolveLazySingleIfExists(
							c.featureInstance->any(e|e.feature = src_BehaviorElement.element).feature.dataFeatureClassifier, 'createFreshnessDataStructure', 'struct_freshness_data_subcomponent'
						);
	}
}
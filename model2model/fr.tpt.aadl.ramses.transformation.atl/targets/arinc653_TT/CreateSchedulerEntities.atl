--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI 
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore

module CreateSchedulerEntities;
create OUT : AADLBA 	from 		IN : AADLI,
									AADL_RUNTIME: AADLBA,
									DATA_MODEL: AADLBA,
									PROGRAMMING_PROPERTIES: AADLBA,
									HOOKS: ATLHOOKS,

									POK_RUNTIME: AADLBA;


uses Services;
uses AADLCopyHelpers;
uses AADLICopyHelpers;
uses Uninstanciate;
uses PropertiesTools;

-------------------------------------------------------------------------------------------
----		NEW RULES
-------------------------------------------------------------------------------------------
helper context AADLBA!ThreadSubcomponent def : getType() : AADLBA!ThreadType =
	self.threadSubcomponentType.ownedRealization.implemented
;

helper context Integer def : value : Integer = self;
helper context Integer def : unit  : AADLI!UnitLiteral = OclUndefined;

helper context AADLI!ComponentInstance def : getOffset() : AADLI!PropertyExpression =
	if (self.ownedPropertyAssociation->any(pa|pa.property.name='Dispatch_Offset').oclIsUndefined()) then
		0
	else
		self.ownedPropertyAssociation->any(pa|pa.property.name='Dispatch_Offset')
			.ownedValue->first().ownedValue
	endif
;

helper context AADLI!ComponentInstance def : getPeriod() : AADLI!PropertyExpression =
	self.ownedPropertyAssociation->any(pa|pa.property.name='Period')
		.ownedValue->first().ownedValue
;

helper context AADLI!ComponentInstance def : getDeadline() : AADLI!PropertyExpression =
	if (self.ownedPropertyAssociation->any(pa|pa.property.name='Deadline').oclIsUndefined()) then
		self.getPeriod()
	else
		self.ownedPropertyAssociation->any(pa|pa.property.name='Deadline')
		.ownedValue->first().ownedValue
	endif
;

helper def : InternalThread_RuleWrapper (period : Integer, deadline: Integer, 
		offset: Integer, t: AADLI!ComponentInstance) : AADLBA!ThreadSubcomponent =
	thisModule.InternalThread (thisModule.getUniqueIdentifier(period, deadline, offset),
							   period, deadline, offset, t)					
;


helper def : getUniqueIdentifier(period: Integer, deadline: Integer, offset: Integer) : String =
	period.toString().concat('_').concat(deadline.toString()).concat('_').concat(offset.toString())
;




helper context AADLI!FeatureInstance def : nameForProcessPort() : String =
	self.eContainer().name.concat('_').concat(self.name)
;

helper context AADLI!ComponentInstance def : processorBinding() : AADLBA!ProcessorSubcomponent =
	if ((self.category=#processor) or (self.category.toString()='virtual processor')) then
		self
	else
		self.ownedPropertyAssociation->any(pa|pa.property.name='Actual_Processor_Binding')
			.ownedValue->first().ownedValue.ownedListElement->first().referencedInstanceObject
	endif
;

helper context AADLI!FeatureInstance def : getNameOnInternalThread() : String =
	self.eContainer().name.concat('_').concat(self.name)
;

unique lazy rule InternalProcess
{
	from
		process : AADLI!ComponentInstance
	using
	{
		vpInst    : AADLI!ComponentInstance = process.processorBinding();
		vp        : AADLBA!VirtualProcessorSubcomponent = thisModule.resolveTemp(vpInst,'sub');
		cpuName   : String = process.processorBinding().eContainer().name.concat('_').concat(process.processorBinding().name);
	}
	to
		internalProcessImplementation : AADLBA!ProcessImplementation (
			name <- cpuName.concat('_InternalActivities.impl'),
			ownedRealization 				<- thisModule.Realization(internalProcessType, internalProcessImplementation)
		),
	
		internalProcessType : AADLBA!ProcessType (
			name <- cpuName.concat('_InternalActivities')
		),
		
	
		implementedAs : AADLBA!PropertyAssociation (
			property						<- thisModule.getProperty('Implemented_As'),
			ownedValue						<- Sequence {implementedAsMPV}
		),
		implementedAsMPV  : AADLBA!ModalPropertyValue (
			ownedValue						<- implementedAsCV
		),
		
		implementedAsCV  : AADLBA!ClassifierValue (
			classifier						<- internalProcessImplementation
		)
	do
	{
		vp.ownedPropertyAssociation.add(implementedAs);
		
		internalProcessImplementation.ownedRealization <- thisModule.Realization(internalProcessType, internalProcessImplementation);
		
		thisModule.public().getOwnedClassifiers().add(internalProcessType);
		thisModule.public().getOwnedClassifiers().add(internalProcessImplementation);
		
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(internalProcessType, process);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(internalProcessImplementation, process);
	}
}

helper def : InternalThread_Deadline (t : AADLI!ComponentInstance) : AADLBA!ThreadSubcomponent =
	thisModule.InternalThread_RuleWrapper (t.getPeriod().value,    -- period
		                       t.getDeadline().value,  -- deadline
							   t.getDeadline().value,  -- offset
							   t) 
;

helper def : InternalThread_Period (t : AADLI!ComponentInstance) : AADLBA!ThreadSubcomponent =
	thisModule.InternalThread_RuleWrapper (t.getPeriod().value,    -- period
		                       t.getDeadline().value,  -- deadline
							   0.longValue(),                      -- offset
							   t)
;


unique lazy rule InternalThread
{
	from
		id : String,  -- only the first parameter is taken into account for
		              -- unique (must have a unique identifier for all parameters)
		period : Integer,
		deadline : Integer,
		offset : Integer,
		thread : AADLI!ComponentInstance
	using
	{
		internalProcess   : AADLBA!ProcessImplementation = thisModule.InternalProcess (thread.eContainer());
        
		nInternals        : Integer = internalProcess.getOwnedThreadSubcomponents()->size() + 1;
		vpInst    : AADLI!ComponentInstance = thread.processorBinding();
        processor : AADLBA!ProcessorSubcomponent = thisModule.resolveTemp(vpInst.eContainer(),'sub');
	}
	to
		ThreadSub : AADLBA!ThreadSubcomponent (
			name <- 'InternalJob_'.concat(nInternals),
			threadSubcomponentType <- ThreadImpl
		),
		
		Thread : AADLBA!ThreadType (
			name <- processor.name.concat('_').concat(vpInst.name).concat('_').concat(ThreadSub.name),
			ownedPropertyAssociation <- Sequence {dispatchProtocol,periodPA, deadlinePA, executionTime,dispatchOffset}
		),
		
		ThreadImpl : AADLBA!ThreadImplementation (
			name <- Thread.name.concat('.impl'),
			ownedRealization 				<- thisModule.Realization(Thread, ThreadImpl)
		),
		
		dispatchProtocol : AADLBA!PropertyAssociation (
			property						<- thisModule.getProperty('Dispatch_Protocol'),
			ownedValue						<- Sequence {dispatchProtocolMPV}
		),
		dispatchProtocolMPV  : AADLBA!ModalPropertyValue (
			ownedValue						<- dispatchProtocolNV
		),
		
		dispatchProtocolNV  : AADLBA!NamedValue (
			namedValue						<- AADLI!EnumerationLiteral->allInstances()->any(e|e.name='Periodic')
		),
		
		periodPA : AADLBA!PropertyAssociation (
			property						<- thisModule.getProperty('Period'),
			ownedValue						<- Sequence {periodMPV}
		),
		periodMPV  : AADLBA!ModalPropertyValue (
			ownedValue						<- periodL
		),
		
		periodL  : AADLBA!IntegerLiteral (
			value						<- period,
			unit						<- AADLI!UnitLiteral->allInstances()->any(l|l.name='ms')
		),
		
		deadlinePA : AADLBA!PropertyAssociation (
			property						<- thisModule.getProperty('Deadline'),
			ownedValue						<- Sequence {deadlineMPV}
		),
		deadlineMPV  : AADLBA!ModalPropertyValue (
			ownedValue						<- deadlineL
		),
		
		deadlineL  : AADLBA!IntegerLiteral (
			value						<- deadline,
			unit						<- AADLI!UnitLiteral->allInstances()->any(l|l.name='ms')
		),
		
		executionTime : AADLBA!PropertyAssociation (
			property						<- thisModule.getProperty('Compute_Execution_Time'),
			ownedValue						<- Sequence {executionTimeMPV}
		),
		
		executionTimeMPV : AADLBA!ModalPropertyValue (
			ownedValue						<- executionTimeRange
		),
		
		executionTimeRange : AADLBA!RangeValue (
			minimum							<- executionTimeMin,
			maximum							<- executionTimeMax
		),
		
		executionTimeMin   : AADLBA!RealLiteral (
			value						<- 0.doubleValue(),
			unit						<- AADLBA!UnitLiteral->allInstances()->any(u|u.name='ms')
		),
		
		executionTimeMax   : AADLBA!RealLiteral (
			value						<- 0.doubleValue(),
			unit						<- AADLBA!UnitLiteral->allInstances()->any(u|u.name='ms')
		),
		
		dispatchOffset : AADLBA!PropertyAssociation (
			property						<- thisModule.getProperty('Dispatch_Offset'),
			ownedValue						<- Sequence {dispatchOffsetMPV}
		),
		dispatchOffsetMPV  : AADLBA!ModalPropertyValue (
			ownedValue						<- dispatchOffsetL
		),
		
		dispatchOffsetL  : AADLBA!IntegerLiteral (
			--value						<- t.getDeadline().value + t.getOffset().value,
			value						<- offset,
			unit						<- AADLI!UnitLiteral->allInstances()->any(l|l.name='ms')
		)
	do
	{
		thisModule.public().getOwnedClassifiers().add(Thread);
		thisModule.public().getOwnedClassifiers().add(ThreadImpl);
		
		internalProcess.getOwnedThreadSubcomponents().add(ThreadSub);
		
		--ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(DeadlineThreadSub, t);
		--ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(DeadlineThread, t);
		--ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(DeadlineThreadImpl, t);

		ThreadSub;
	}
}

unique lazy rule InternalThread_PartitionWindow
{
	from
		windowIndex : Integer,
		offsetEnd   : Integer,
		processor : AADLI!ComponentInstance
	using
	{
		maf : AADLI!IntegerLiteral = processor.ownedPropertyAssociation
				->any(pa|pa.property.name='Module_Major_Frame').ownedValue->first().ownedValue;

		pswitchTime : AADLI!RealLiteral = processor.getPartitionSwitchTime();
	}
	to
		WindowThreadSub : AADLBA!ThreadSubcomponent (
			name <- 'PWS_'.concat(windowIndex.toString()),
			threadSubcomponentType <- WindowThreadImpl
		),
		
		WindowThread : AADLBA!ThreadType (
			name <- processor.name.concat('_PartitionWindowSwitch_'.concat(windowIndex.toString())),
			ownedPropertyAssociation <- Sequence {dispatchProtocol,periodPA,executionTime, dispatchOffset}
		),
		
		WindowThreadImpl : AADLBA!ThreadImplementation (
			name <- WindowThread.name.concat('.impl'),
			ownedRealization 				<- thisModule.Realization(WindowThread, WindowThreadImpl)
		),
		
		dispatchProtocol : AADLBA!PropertyAssociation (
			property						<- thisModule.getProperty('Dispatch_Protocol'),
			ownedValue						<- Sequence {dispatchProtocolMPV}
		),
		dispatchProtocolMPV  : AADLBA!ModalPropertyValue (
			ownedValue						<- dispatchProtocolNV
		),
		
		dispatchProtocolNV  : AADLBA!NamedValue (
			namedValue						<- AADLI!EnumerationLiteral->allInstances()->any(e|e.name='Periodic')
		),
		
		periodPA : AADLBA!PropertyAssociation (
			property						<- thisModule.getProperty('Period'),
			ownedValue						<- Sequence {periodMPV}
		),
		periodMPV  : AADLBA!ModalPropertyValue (
			ownedValue						<- periodL
		),
		
		periodL  : AADLBA!IntegerLiteral (
			value						<- maf.value,
			unit						<- maf.unit
		),
		
		dispatchOffset : AADLBA!PropertyAssociation (
			property						<- thisModule.getProperty('Dispatch_Offset'),
			ownedValue						<- Sequence {dispatchOffsetMPV}
		),
		dispatchOffsetMPV  : AADLBA!ModalPropertyValue (
			ownedValue						<- dispatchOffsetL
		),
		
		dispatchOffsetL  : AADLBA!RealLiteral (
			value						<- offsetEnd.doubleValue() - pswitchTime.value,
			unit						<- AADLBA!UnitLiteral->allInstances()->any(u|u.name='ms')
		),
		
		executionTime : AADLBA!PropertyAssociation (
			property						<- thisModule.getProperty('Compute_Execution_Time'),
			ownedValue						<- Sequence {executionTimeMPV}
		),
		
		executionTimeMPV : AADLBA!ModalPropertyValue (
			ownedValue						<- executionTimeRange
		),
		
		executionTimeRange : AADLBA!RangeValue (
			minimum							<- executionTimeMin,
			maximum							<- executionTimeMax
		),
		
		executionTimeMin   : AADLBA!RealLiteral (
			value						<- pswitchTime.value,
			unit						<- pswitchTime.unit
		),
		
		executionTimeMax   : AADLBA!RealLiteral (
			value						<- pswitchTime.value,
			unit						<- pswitchTime.unit
		)
	do
	{
		thisModule.public().getOwnedClassifiers().add(WindowThread);
		thisModule.public().getOwnedClassifiers().add(WindowThreadImpl);
	}
}
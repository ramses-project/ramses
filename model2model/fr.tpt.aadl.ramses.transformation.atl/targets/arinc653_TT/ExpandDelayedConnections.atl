--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore

module ExpandDelayedConnections;
create 
	OUT : AADLBA
from
	IN : AADLI,
	AADL_RUNTIME: AADLBA,
	DATA_MODEL: AADLBA,
	PROGRAMMING_PROPERTIES: AADLBA,
	HOOKS: ATLHOOKS,

	POK_RUNTIME: AADLBA;

uses Services;
uses MappingHelpers;
uses Uninstanciate;
uses PropertiesTools;

uses IOHelpers;

-------------------------------------------------------------------------------------------
----		OVERRIDEN RULES
-------------------------------------------------------------------------------------------
helper context AADLI!ConnectionInstance def : isDefaultConnectionInstance() : Boolean =
	(self.kind = #portConnection and (self.source.eContainer().category=#thread
			 or self.destination.eContainer().category=#thread))
	and not self.isDelayedConnectionInstance()
;

-------------------------------------------------------------------------------------------
----		NEW RULES
-------------------------------------------------------------------------------------------
helper context AADLI!ConnectionInstance def : isDelayedConnectionInstance() : Boolean =
	if (self.ownedPropertyAssociation->any(pa|pa.property.name='Timing').oclIsUndefined()) then
		false
	else
		self.ownedPropertyAssociation->any(pa|pa.property.name='Timing')
					.ownedValue->first().ownedValue.namedValue.name='delayed'
	endif
;

helper context AADLBA!Subcomponent def : getEventDataPorts() : Sequence(AADLBA!DataPort) =
	self.getComponentType().getOwnedEventDataPorts()
;
helper context AADLBA!Subcomponent def : getPortConnections() : Sequence(AADLBA!PortConnection) =
	self.getComponentImplementation().getOwnedPortConnections()
;

helper context AADLI!FeatureInstance def : getNameOnInternalThreadForCache() : String =
	self.getNameOnInternalThread().concat('_cache')
;

--rule DelayedConnectionWithOffset_Instance
--{
--	from
--		cnxInst: AADLI!ConnectionInstance
--		(
--			cnxInst.kind = #portConnection 
--			and cnxInst.source.eContainer().category=#thread
--			and cnxInst.destination.eContainer().category=#thread
--			and cnxInst.isDelayedConnectionInstance()
--			and not cnxInst.source.hasNoOutputOffset()
--		)
--	using
--	{
--		DeadlineThread    : AADLBA!ThreadSubcomponent = OclUndefined;
--	    OffsetThread      : AADLBA!ThreadSubcomponent = OclUndefined;
--		PeriodThread      : AADLBA!ThreadSubcomponent = OclUndefined;
--
--		DeadlineThreadCachePort : AADLBA!EventDataPort = OclUndefined;
--		OffsetThreadCachePortIN : AADLBA!EventDataPort = OclUndefined;
--		OffsetThreadCachePortOUT : AADLBA!EventDataPort = OclUndefined;
--		PeriodThreadCachePort   : AADLBA!EventDataPort = OclUndefined;
--
--		InternalProcess   : AADLBA!ThreadImplementation = OclUndefined;
--	}
--	do
--	{
--		-- Create scheduler components and connections with the process
--		thisModule.DelayedPortIntraConnection_Source (cnxInst.source);
--		thisModule.DelayedPortIntraConnection_Intermediate (cnxInst.source);
--		thisModule.DelayedPortIntraConnection_Destination (cnxInst.destination);
--		
--		-- Resolve scheduler threads
--		DeadlineThread <- thisModule.InternalThread_Deadline (cnxInst.source);
--		OffsetThread <- thisModule.InternalThread_Offset (cnxInst.source);
--		PeriodThread <- thisModule.InternalThread_Period (cnxInst.destination);
--		
--		
--		-- Create/resolve cache port of scheduler threads
--		DeadlineThreadCachePort <- thisModule.InternalThread_Deadline_SetupCache(DeadlineThread, cnxInst);
--		PeriodThreadCachePort <- PeriodThread.getEventDataPorts()->any(p|p.name = cnxInst.destination.getNameOnInternalThreadForCache());
--		OffsetThreadCachePortIN <- OffsetThread.getEventDataPorts()->any(p|p.name = cnxInst.source.getNameOnInternalThreadForCache().concat('_in'));
--		OffsetThreadCachePortOUT <- OffsetThread.getEventDataPorts()->any(p|p.name = cnxInst.source.getNameOnInternalThreadForCache().concat('_out'));
--		
--		-- Connect cache ports of scheduler threads
--		InternalProcess <- thisModule.InternalProcess (cnxInst.source.eContainer().eContainer());
--		
--		InternalProcess.getOwnedPortConnections().add(thisModule.InternalProcess_CacheConnection (DeadlineThread, OffsetThread, DeadlineThreadCachePort,OffsetThreadCachePortIN));
--		InternalProcess.getOwnedPortConnections().add(thisModule.InternalProcess_CacheConnection (OffsetThread, PeriodThread, OffsetThreadCachePortOUT,DeadlineThreadCachePort));
--		
--		-- Update internal threads BCET and WCET
--		thisModule.UpdateExecutionTime (DeadlineThread, cnxInst);
--		thisModule.UpdateExecutionTime (OffsetThread, cnxInst);
--		thisModule.UpdateExecutionTime (PeriodThread, cnxInst);
--	}
--}

--rule DelayedConnection_Instance
--{
--	from
--		cnxInst: AADLI!ConnectionInstance
--		(
--			cnxInst.kind = #portConnection 
--			and cnxInst.source.eContainer().category=#thread
--			and cnxInst.destination.eContainer().category=#thread
--			and cnxInst.isDelayedConnectionInstance()
--		)
--	using
--	{
--		DeadlineThread    : AADLBA!ThreadSubcomponent = OclUndefined;
--		PeriodThread      : AADLBA!ThreadSubcomponent = OclUndefined;
--
--		DeadlineThreadCachePort : AADLBA!EventDataPort = OclUndefined;
--		PeriodThreadCachePort   : AADLBA!EventDataPort = OclUndefined;
--
--		InternalProcess   : AADLBA!ThreadImplementation = OclUndefined;
--	}
--	do
--	{
--		-- Create scheduler components and connections with the process
--		thisModule.DelayedPortIntraConnection_Source (cnxInst.source);
--		thisModule.DelayedPortIntraConnection_Destination (cnxInst.destination);
--
--		-- Resolve scheduler threads
--		DeadlineThread <- thisModule.InternalThread_Deadline (cnxInst.source);
--		PeriodThread <- thisModule.InternalThread_Period (cnxInst.destination);
--		
--		-- Create/resolve cache port of scheduler threads
--		DeadlineThreadCachePort <- thisModule.InternalThread_Deadline_SetupCache(DeadlineThread, cnxInst);
--		PeriodThreadCachePort <- PeriodThread.getEventDataPorts()->any(p|p.name = cnxInst.destination.getNameOnInternalThreadForCache());
--		
--		-- Connect cache ports of scheduler threads
--		InternalProcess <- thisModule.InternalProcess (cnxInst.source.eContainer().eContainer());
--		InternalProcess.getOwnedPortConnections().add(thisModule.InternalProcess_CacheConnection (DeadlineThread, PeriodThread, DeadlineThreadCachePort,PeriodThreadCachePort));
--		
--		-- Update internal threads BCET and WCET
--		thisModule.UpdateExecutionTime (DeadlineThread, cnxInst);
--		thisModule.UpdateExecutionTime (PeriodThread, cnxInst);
--	}
--}

rule DelayedConnection_Instance
{
	from
		cnxInst: AADLI!ConnectionInstance
		(
			cnxInst.kind = #portConnection 
			and cnxInst.source.eContainer().category=#thread
			and cnxInst.destination.eContainer().category=#thread
			and cnxInst.isDelayedConnectionInstance()
		)
	using
	{
		DeadlineThread    : AADLBA!ThreadSubcomponent = OclUndefined;
		PeriodThread      : AADLBA!ThreadSubcomponent = OclUndefined;

		DeadlineThreadCachePort : AADLBA!EventDataPort = OclUndefined;
		PeriodThreadCachePort   : AADLBA!EventDataPort = OclUndefined;

		InternalProcess   : AADLBA!ThreadImplementation = OclUndefined;
	}
	do
	{
		-- Create scheduler components and connections with the process
		thisModule.DelayedPortIntraConnection_Source (cnxInst.source);
		thisModule.DelayedPortIntraConnection_Destination (cnxInst.destination);

		-- Resolve scheduler threads
		DeadlineThread <- thisModule.InternalThread_Deadline (cnxInst.source);
		PeriodThread <- thisModule.InternalThread_Period (cnxInst.destination);
		
		-- Create/resolve cache port of scheduler threads
		DeadlineThreadCachePort <- thisModule.InternalThread_Deadline_SetupCache(DeadlineThread, cnxInst);
		PeriodThreadCachePort <- PeriodThread.getEventDataPorts()->any(p|p.name = cnxInst.destination.getNameOnInternalThreadForCache());
		
		-- Connect cache ports of scheduler threads
		InternalProcess <- thisModule.InternalProcess (cnxInst.source.eContainer().eContainer());
		InternalProcess.getOwnedPortConnections().add(thisModule.InternalProcess_CacheConnection (DeadlineThread, PeriodThread, DeadlineThreadCachePort,PeriodThreadCachePort));
		
		-- Update internal threads BCET and WCET
		thisModule.UpdateExecutionTime (DeadlineThread, cnxInst);
		thisModule.UpdateExecutionTime (PeriodThread, cnxInst);
	}
}


rule UpdateExecutionTime (t : AADLBA!ThreadSubcomponent, cnxInst: AADLI!ConnectionInstance)
{
	do
	{
		t.getComponentType().getMinExecutionTime().value <- Sequence{
			t.getComponentType().getMinExecutionTime().value.doubleValue(),
			cnxInst.getIOTime()}->sum().doubleValue();
		
		t.getComponentType().getMaxExecutionTime().value <- Sequence{
			t.getComponentType().getMaxExecutionTime().value.doubleValue(),
			cnxInst.getIOTime()}->sum().doubleValue();
			
		t;
	}
}


unique lazy rule DelayedPortIntraConnection_Source
{
	from
		fi : AADLI!FeatureInstance
	using
	{
		processImg : AADLBA!ProcessType = thisModule.resolveTemp(fi.eContainer().eContainer(),'sub').getComponentType();
		processImplImg : AADLBA!ProcessType = thisModule.resolveTemp(fi.eContainer().eContainer(),'sub').getComponentImplementation();

		process : AADLBA!ProcessSubcomponent = thisModule.resolveTemp(fi.eContainer().eContainer(),'sub');
		
		vpInst    : AADLI!ComponentInstance = fi.eContainer().processorBinding();
		sysImpl   : AADLBA!SystemImplementation = thisModule.resolveTemp(fi.eContainer().getSystemInstance(),'impl');

		processor : AADLBA!ProcessorSubcomponent = thisModule.resolveTemp(vpInst.eContainer(),'sub');
		vp        : AADLBA!VirtualProcessorSubcomponent = thisModule.resolveTemp(vpInst,'sub');
		internalProcess   : AADLBA!ProcessImplementation = thisModule.InternalProcess (fi.eContainer().eContainer());
		internalThread    : AADLBA!ThreadSubcomponent = thisModule.InternalThread_Deadline (fi);
	}
	to
		processPort  : AADLBA!EventDataPort (
			name <- fi.nameForProcessPort(),
			direction <- #out,
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier()
		),
		threadToProcess : AADLBA!PortConnection (
			name <- processPort.name.concat('_update'),
			source <- threadToProcess_source,
			destination <- threadToProcess_dest
		),
		threadToProcess_source : AADLBA!ConnectedElement (
			context <- thisModule.resolveTemp(fi.eContainer(), 'sub'), -- thread
			connectionEnd <- thisModule.resolveTemp(fi, 'f') -- port thread
		),
		threadToProcess_dest : AADLBA!ConnectedElement (
			connectionEnd <- processPort
		),
		
		
		
		
		processorPort : AADLBA!EventDataPort (
			name <- vp.name.concat('_').concat(fi.getNameOnInternalThread()),
			direction <- 'in',
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier()
		),
		vpPort : AADLBA!EventDataPort (
			name <- fi.getNameOnInternalThread(),
			direction <- 'in',
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier()
		),
		internalProcessPort : AADLBA!EventDataPort (
			name <- fi.getNameOnInternalThread(),
			direction <- 'in',
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier()
		),
		internalThreadPort : AADLBA!EventDataPort (
			name <- fi.getNameOnInternalThread(),
			direction <- 'in',
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier(),
			ownedPropertyAssociation <- Sequence {queueSize}
		),
		queueSize : AADLBA!PropertyAssociation (
			property <- thisModule.getProperty('Queue_Size'),
			ownedValue <- queueSizeMPV
		),
		queueSizeMPV : AADLBA!ModalPropertyValue (
			ownedValue <- queueSizeL
		),
		queueSizeL : AADLBA!IntegerLiteral (
			value	   <- fi.getQueueSizeFromInputRate()
		),
		
		
		processorToVP : AADLBA!PortConnection (
			name <- 'copy_'.concat(fi.getNameOnInternalThread()),
			source <- processorToVP_source,
			destination <- processorToVP_dest
		),
		processorToVP_source : AADLBA!ConnectedElement (
			connectionEnd <- processorPort
		),
		processorToVP_dest : AADLBA!ConnectedElement (
			context <- vp,
			connectionEnd <- vpPort
		),	
		internal_processToThread : AADLBA!PortConnection (
			name <- 'copy_'.concat(fi.getNameOnInternalThread()),
			source <- internal_processToThread_source,
			destination <- internal_processToThread_dest
		),
		internal_processToThread_source : AADLBA!ConnectedElement (
			connectionEnd <- internalProcessPort
		),
		internal_processToThread_dest : AADLBA!ConnectedElement (
			context <- internalThread,
			connectionEnd <- internalThreadPort
		),
		processToProcessor : AADLBA!PortConnection (
			name <- 'copy_'.concat(fi.getNameOnInternalThread()),
			source <- processToProcessor_source,
			destination <- processToProcessor_dest
		),
		processToProcessor_source : AADLBA!ConnectedElement (
			context <- process,
			connectionEnd <- processPort
		),
		processToProcessor_dest : AADLBA!ConnectedElement (
			context <- processor,
			connectionEnd <- processorPort
		)
	do
	{
		processImg.getOwnedEventDataPorts().add(processPort);
		processImplImg.getOwnedPortConnections().add(threadToProcess);
		
		
		processor.getComponentType().getOwnedEventDataPorts().add(processorPort);
		vp.getComponentType().getOwnedEventDataPorts().add(vpPort);
		internalProcess.getComponentType().getOwnedEventDataPorts().add(internalProcessPort);
		internalThread.getComponentType().getOwnedEventDataPorts().add(internalThreadPort);
		
		processor.getComponentImplementation().getOwnedPortConnections().add(processorToVP);
		internalProcess.getOwnedPortConnections().add(internal_processToThread);
		
		sysImpl.getOwnedPortConnections().add(processToProcessor);
		
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(processPort, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(vpPort, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(internalProcessPort, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(internalThreadPort, fi);
		
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(threadToProcess, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(processorToVP, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(internal_processToThread, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(processToProcessor, fi);
		
		processPort;
	}
}

--unique lazy rule DelayedPortIntraConnection_Intermediate
--{
--	from
--		fi : AADLI!FeatureInstance
--	using
--	{
--		processImg : AADLBA!ProcessType = thisModule.resolveTemp(fi.eContainer().eContainer(),'sub').getComponentType();
--		processImplImg : AADLBA!ProcessType = thisModule.resolveTemp(fi.eContainer().eContainer(),'sub').getComponentImplementation();
--
--		process : AADLBA!ProcessSubcomponent = thisModule.resolveTemp(fi.eContainer().eContainer(),'sub');
--		
--		vpInst    : AADLI!ComponentInstance = fi.eContainer().processorBinding();
--		sysImpl   : AADLBA!SystemImplementation = thisModule.resolveTemp(fi.eContainer().getSystemInstance(),'impl');
--
--		processor : AADLBA!ProcessorSubcomponent = thisModule.resolveTemp(vpInst.eContainer(),'sub');
--		vp        : AADLBA!VirtualProcessorSubcomponent = thisModule.resolveTemp(vpInst,'sub');
--		internalProcess   : AADLBA!ProcessImplementation = thisModule.InternalProcess (fi.eContainer().eContainer());
--		internalThread    : AADLBA!ThreadSubcomponent = thisModule.InternalThread_Offset (fi);
--	}
--	to
--		internalThreadPortIN : AADLBA!EventDataPort (
--			name <- fi.getNameOnInternalThreadForCache().concat('_in'),
--			direction <- 'in',
--			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier(),
--			ownedPropertyAssociation <- Sequence {queueSize}
--		),
--		internalThreadPortOUT : AADLBA!EventDataPort (
--			name <- fi.getNameOnInternalThreadForCache().concat('_out'),
--			direction <- #out,
--			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier()
--		),
--		
--		internalThreadConnection : AADLBA!PortConnection (
--			name <- 'copy_'.concat(fi.getNameOnInternalThread()),
--			source <- internalThreadConnection_source,
--			destination <- internalThreadConnection_dest
--		),
--		internalThreadConnection_source : AADLBA!ConnectedElement (
--			connectionEnd <- internalThreadPortIN
--		),
--		internalThreadConnection_dest : AADLBA!ConnectedElement (
--			connectionEnd <- internalThreadPortOUT
--		),
--		queueSize : AADLBA!PropertyAssociation (
--			property <- thisModule.getProperty('Queue_Size'),
--			ownedValue <- queueSizeMPV
--		),
--		queueSizeMPV : AADLBA!ModalPropertyValue (
--			ownedValue <- queueSizeL
--		),
--		queueSizeL : AADLBA!IntegerLiteral (
--			value	   <- fi.getQueueSizeFromOutputRate()
--		)
--	do
--	{
--		internalThread.getComponentType().getOwnedEventDataPorts().add(internalThreadPortIN);
--		internalThread.getComponentType().getOwnedEventDataPorts().add(internalThreadPortOUT);
--		internalThread.getComponentImplementation().getOwnedPortConnections().add(internalThreadConnection);
--		
--		internalThread;
--	}
--}




unique lazy rule DelayedPortIntraConnection_Destination
{
	from
		fi : AADLI!FeatureInstance
	using
	{
		processImg : AADLBA!ProcessType = thisModule.resolveTemp(fi.eContainer().eContainer(),'sub').getComponentType();
		processImplImg : AADLBA!ProcessType = thisModule.resolveTemp(fi.eContainer().eContainer(),'sub').getComponentImplementation();



		process : AADLBA!ProcessSubcomponent = thisModule.resolveTemp(fi.eContainer().eContainer(),'sub');

		vpInst    : AADLI!ComponentInstance = fi.eContainer().processorBinding();
		sysImpl   : AADLBA!SystemImplementation = thisModule.resolveTemp(fi.eContainer().getSystemInstance(),'impl');

		processor : AADLBA!ProcessorSubcomponent = thisModule.resolveTemp(vpInst.eContainer(),'sub');
		vp        : AADLBA!VirtualProcessorSubcomponent = thisModule.resolveTemp(vpInst,'sub');
		internalProcess   : AADLBA!ProcessImplementation = thisModule.InternalProcess (fi.eContainer().eContainer());
		internalThread    : AADLBA!ThreadSubcomponent = thisModule.InternalThread_Period (fi);
	}
	to
		processPort  : AADLBA!EventDataPort (
			name <- fi.nameForProcessPort(),
			direction <- 'in',
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier()
		),
		processToThread : AADLBA!PortConnection (
			name <- processPort.name.concat('_update'),
			source <- processToThread_source,
			destination <- processToThread_dest
		),
		processToThread_source : AADLBA!ConnectedElement (
			connectionEnd <- processPort
		),
		processToThread_dest : AADLBA!ConnectedElement (
			context <- thisModule.resolveTemp(fi.eContainer(), 'sub'), -- thread
			connectionEnd <- thisModule.resolveTemp(fi, 'f') -- port thread
		),
		
		
		
		
		
		processorPort : AADLBA!EventDataPort (
			name <- vp.name.concat('_').concat(fi.getNameOnInternalThread()),
			direction <- #out,
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier()
		),
		vpPort : AADLBA!EventDataPort (
			name <- fi.getNameOnInternalThread(),
			direction <- #out,
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier()
		),
		internalProcessPort : AADLBA!EventDataPort (
			name <- fi.getNameOnInternalThread(),
			direction <- #out,
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier()
		),
		internalThreadPortTmp   : AADLBA!EventDataPort (
			name <- fi.getNameOnInternalThreadForCache(),
			direction <- 'in',
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier(),
			ownedPropertyAssociation <- Sequence {dequeueProtocol, queueSize}
		),
		
		queueSize : AADLBA!PropertyAssociation (
			property <- thisModule.getProperty('Queue_Size'),
			ownedValue <- queueSizeMPV
		),
		queueSizeMPV : AADLBA!ModalPropertyValue (
			ownedValue <- queueSizeL
		),
		queueSizeL : AADLBA!IntegerLiteral (
			value	   <- fi.getQueueSize().longValue()
		),
		
		dequeueProtocol : AADLBA!PropertyAssociation (
			property						<- thisModule.getProperty('Dequeue_Protocol'),
			ownedValue						<- dequeueProtocolMPV
		),
		
		dequeueProtocolMPV : AADLBA!ModalPropertyValue (
			ownedValue						<- dequeueProtocolNV 
		),
		
		dequeueProtocolNV  : AADLBA!NamedValue (
			namedValue						<- AADLI!EnumerationLiteral->allInstances()->any(e|e.name='AllItems')
		),
		
		internalThreadPort : AADLBA!EventDataPort (
			name <- fi.getNameOnInternalThread(),
			direction <- #out,
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier()
		),
		
		cacheToInternal : AADLBA!PortConnection (
			name <- 'update_'.concat(fi.getNameOnInternalThread()),
			source <- cacheToInternal_source,
			destination <- cacheToInternal_destination
		),
		cacheToInternal_source : AADLBA!ConnectedElement (
			connectionEnd <- internalThreadPortTmp
		),
		cacheToInternal_destination : AADLBA!ConnectedElement (
			connectionEnd <- internalThreadPort
		),
		vpToProcessor : AADLBA!PortConnection (
			name <- 'update_'.concat(fi.getNameOnInternalThread()),
			source <- vpToProcessor_source,
			destination <- vpToProcessor_dest
		),
		vpToProcessor_source : AADLBA!ConnectedElement (
			context <- vp,
			connectionEnd <- vpPort
		),		
		vpToProcessor_dest : AADLBA!ConnectedElement (
			connectionEnd <- processorPort
		),
		internal_processToThread : AADLBA!PortConnection (
			name <- 'update_'.concat(fi.getNameOnInternalThread()),
			source <- internal_processToThread_source,
			destination <- internal_processToThread_dest
		),
		internal_processToThread_source : AADLBA!ConnectedElement (
			context <- internalThread,
			connectionEnd <- internalThreadPort
		),
		internal_processToThread_dest : AADLBA!ConnectedElement (
			connectionEnd <- internalProcessPort
		),
		processToProcessor : AADLBA!PortConnection (
			name <- 'update_'.concat(fi.getNameOnInternalThread()),
			source <- processToProcessor_source,
			destination <- processToProcessor_dest
		),
		processToProcessor_source : AADLBA!ConnectedElement (
			context <- processor,
			connectionEnd <- processorPort
		),
		processToProcessor_dest : AADLBA!ConnectedElement (
			context <- process,
			connectionEnd <- processPort
		)
	do
	{
		processImg.getOwnedEventDataPorts().add(processPort);
		processImplImg.getOwnedPortConnections().add(processToThread);
		
		
		processor.getComponentType().getOwnedEventDataPorts().add(processorPort);
		vp.getComponentType().getOwnedEventDataPorts().add(vpPort);
		internalProcess.getComponentType().getOwnedEventDataPorts().add(internalProcessPort);
		
		internalThread.getComponentType().getOwnedEventDataPorts().add(internalThreadPortTmp);
		internalThread.getComponentType().getOwnedEventDataPorts().add(internalThreadPort);
		
		internalThread.getComponentImplementation().getOwnedPortConnections().add(cacheToInternal);
		processor.getComponentImplementation().getOwnedPortConnections().add(vpToProcessor);
		internalProcess.getOwnedPortConnections().add(internal_processToThread);
		
		sysImpl.getOwnedPortConnections().add(processToProcessor);
		
		
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(processPort, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(vpPort, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(internalProcessPort, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(internalThreadPort, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(internalThreadPortTmp, fi);
		
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(processToThread, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(cacheToInternal, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(vpToProcessor, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(internal_processToThread, fi);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(processToProcessor, fi);
		
		
		processPort;
	}
}


rule InternalProcess_CacheConnection (
	SourceThread : AADLBA!ThreadSubcomponent,
	DestThread   : AADLBA!ThreadSubcomponent,
	SourceThreadPort : AADLBA!EventDataPort,
	DestThreadPort : AADLBA!EventDataPort)
{
	to
		toCache : AADLBA!PortConnection (
			name <- 'update_'.concat(DestThreadPort.name),
			source <- toCache_source,
			destination <- toCache_dest
		),
		toCache_source : AADLBA!ConnectedElement (
			context <- SourceThread,
			connectionEnd <- SourceThreadPort
		),
		toCache_dest : AADLBA!ConnectedElement (
			context <- DestThread,
			connectionEnd <- DestThreadPort
		)
	do { toCache; }
}


rule InternalThread_Deadline_InputToCache (
	DeadlineThreadInputPort : AADLBA!DataPort, DeadlineThreadCachePort : AADLBA!EventDataPort)
{
	to
		toCache : AADLBA!PortConnection (
			name <- DeadlineThreadInputPort.name.concat('_to_').concat(DeadlineThreadCachePort.name),
			source <- toCache_source,
			destination <- toCache_dest
		),
		toCache_source : AADLBA!ConnectedElement (
			connectionEnd <- DeadlineThreadInputPort
		),
		toCache_dest : AADLBA!ConnectedElement (
			connectionEnd <- DeadlineThreadCachePort
		)
	do {
		toCache;
	}
}

rule InternalThread_Deadline_SetupCache (DeadlineThread : AADLBA!Subcomponent, 
										cnxInst : AADLI!ConnectionInstance)
{
	using
	{
		DeadlineThreadInputPort : AADLBA!EventDataPort = OclUndefined;
		DeadlineThreadCachePort : AADLBA!EventDataPort = OclUndefined;
		InputToCache            : AADLBA!PortConnection = OclUndefined;
	}
	do
	{
		-- Resolve input port of deadline thread
		DeadlineThreadInputPort <- DeadlineThread.getEventDataPorts()->any(
						p|p.name = cnxInst.source.getNameOnInternalThread());
		
		-- Create or resolve cache port of deadline thread
		DeadlineThreadCachePort <- thisModule.InternalThread_Deadline_CachePort(cnxInst.destination);
		if (not DeadlineThread.getEventDataPorts()->contains(DeadlineThreadCachePort))
		{
			DeadlineThread.getEventDataPorts().add(DeadlineThreadCachePort);
		}
		
		-- Connect input port to cache port into the deadline thread
		InputToCache <- thisModule.InternalThread_Deadline_InputToCache(DeadlineThreadInputPort, DeadlineThreadCachePort);
		DeadlineThread.getPortConnections().add(InputToCache);
		
		DeadlineThreadCachePort;
	}
}

unique lazy rule InternalThread_Deadline_CachePort
{
	from
		fi : AADLI!FeatureInstance
	to
		d : AADLBA!EventDataPort (
			name <- fi.getNameOnInternalThreadForCache(),
			direction <- #out,
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier.mapDataClassifier()
		)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(d, fi);
		d;
	}
}
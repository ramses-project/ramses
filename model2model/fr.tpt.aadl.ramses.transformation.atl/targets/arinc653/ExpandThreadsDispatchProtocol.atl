--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- nsURI AADLBA=http:///AADLBA

module ExpandThreadsDispatchProtocol;
create OUT : AADLBA 	from 		IN : AADLI,
									AADL_RUNTIME: AADLBA,
									DATA_MODEL: AADLBA,
									PROGRAMMING_PROPERTIES: AADLBA,
									HOOKS: ATLHOOKS,

									ARINC653_RUNTIME: AADLBA;


uses Services;
uses AADLCopyHelpers;
uses AADLICopyHelpers;
uses Uninstanciate;
uses PropertiesTools;


rule expandThreadDispatchProtocolInBA(inst: AADLBA!ComponentInstance,
									  spg: AADLBA!SuprogramImplementation,
									  actions: AADLBA!Actions) 
{
 do{
 	if(inst.isPeriodicThread())
 	{
 		thisModule.addPeriodicWaitCallAction(actions, spg);
 	}
 	if(inst.isPeriodicThread())
 	{
 	}
 	if(inst.isPeriodicThread())
 	{
 	}
 }
}

unique lazy rule addPeriodicWaitCallAction
{
	from
		actions: AADLBA!Actions,
		spgImg: AADLBA!SuprogramImplementation
	using
	{
		RETURN_CODE: AADLBA!DataSubcomponent = thisModule.retreiveReturnCodeValue(spgImg);
		spg : AADL!SubprogramType = 'Periodic_Wait'.asSubprogramType('ARINC653_RUNTIME');
	}
	to
		call: AADLBA!SubprogramCallAction
		(
			subprogram <- callHolder,
			parameterLabels <- Sequence{RETURN_CODE_HOLDER} 
		),
		callHolder: AADLBA!CalledSubprogramHolder
		(
			element <- spg
		),

		RETURN_CODE_HOLDER: AADLBA!DataSubcomponentHolder
		(
			element <- RETURN_CODE
		)
	do
	{
		actions.add(call);
	}
}


rule expandThreadDispatchProtocol(inst: AADLBA!ComponentInstance, implImg: AADLBA!ThreadImplementation) 
{
 do{
 	if(inst.isPeriodicThread())
 	{
 		for(seq in implImg.ownedSubprogramCallSequence)
 		{
 			thisModule.addPeriodicWaitCall(seq);
 		}
 	}
 	if(inst.isPeriodicThread())
 	{
 	}
 	if(inst.isPeriodicThread())
 	{
 	}
 }
}

unique lazy rule addPeriodicWaitCall
{
	from
		sequence: AADLBA!SubprogramCallSequence
	using
	{
		implImg: AADLBA!ThreadImplementation = sequence.eContainer();
		RETURN_CODE: AADLBA!DataSubcomponent = thisModule.retreiveReturnCodeValue(implImg);
		spg : AADL!SubprogramType = 'Periodic_Wait'.asSubprogramType('ARINC653_RUNTIME');
	}
	to
		call: AADLBA!SubprogramCall
		(
			name<-'call_PeriodicWait',
			calledSubprogram<-spg
		),
		connectedParam_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->first()
		),
		connectedSubcomponent_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-RETURN_CODE
		),
		paramConnection_RETURN_CODE: AADLBA!ParameterConnection
		(
			name<-'call_PeriodicWait_to_ReturnCode',
			source<-connectedParam_RETURN_CODE,
			destination<-connectedSubcomponent_RETURN_CODE
		)		
	do
	{
		connectedParam_RETURN_CODE.setContext(call);
		implImg.getOwnedParameterConnections().add(paramConnection_RETURN_CODE);
		sequence.ownedCallSpecification.add(call);
		call;
	}
}

--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore

module ExpandThreadsPorts;
create OUT : AADLBA 	from 		IN : AADLI,
									AADL_RUNTIME: AADLBA,
									DATA_MODEL: AADLBA,
									PROGRAMMING_PROPERTIES: AADLBA,
									HOOKS: ATLHOOKS,

									POK_RUNTIME: AADLBA;


uses Services;
uses AADLCopyHelpers;
uses AADLICopyHelpers;
uses Uninstanciate;
uses PropertiesTools;

-------------------------------------------------------------------------------------------
----		TO BE SUPERIMPOSED RULES
-------------------------------------------------------------------------------------------
	
rule expandThreadDispatchProtocol(inst: AADLBA!ComponentInstancs, implImg: AADLBA!ThreadImplementation) 
{
}
	
-------------------------------------------------------------------------------------------
----	OVERRIDEN MATCHED RULES
-------------------------------------------------------------------------------------------

rule DataPort_Instance
{
	from
		fi: AADLI!FeatureInstance (fi.category=#dataPort
									and fi.eContainer().category=#thread
									and not fi.isPeriodicDelayedPort())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		-- local variable that will be initialized in the "do" section.
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- creation of a data access feature, to be added to the target thread component, 
		-- this data access represent is an access to the global variable representing the
		-- ARINC653 communication identifier.
		
		-- target data access must be called 'f' to be retreived with resolveTemp
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		thisModule.addReturnCodeDataSubcomponent(implImg);
	}
}


rule EventPort_Instance
{
	from
		fi: AADLI!FeatureInstance (fi.category=#eventPort 
									and fi.eContainer().category = #thread
									and not fi.isPeriodicDelayedPort())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- target data access must be called 'f' to be retreived with resolveTemp
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			)
	do
	{
		f.debug('HHHHHHHH');
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		thisModule.addReturnCodeDataSubcomponent(implImg);
	}
}

rule EventDataPort_Instance
{
	from
		fi: AADLI!FeatureInstance(fi.category=#eventDataPort 
								and fi.eContainer().category=#thread
								and not fi.isPeriodicDelayedPort())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- target data access must be called 'f' to be retreived with resolveTemp 
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		thisModule.addReturnCodeDataSubcomponent(implImg);
		
	}
}

rule DataAccess_Instance
{
	from
		fi: AADLI!FeatureInstance (fi.category=#dataAccess)
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined; 
		processImplImg: AADLI!ProcessImplementation = OclUndefined;
	}
	to
		f: AADLBA!DataAccess
			(
				name <- fi.name,
				kind <- #requires,
				dataFeatureClassifier <- fi.feature.mapClassifier(),
				ownedPropertyAssociation <- fi.feature.mapOwnedPropertyAssociationList()
			),
		d: AADLBA!DataSubcomponent
			(name<-fi.name+thisModule.dataSubcomponentSuffix())
	do
	{
		if(c.category=#thread)
		{
			processImplImg <- c.eContainer().subcomponent.subcomponentType;
		}
		thisModule.addThreadsInternalConnections(fi);
		implImg = thisModule.resolveTemp(c, 'sub').subcomponentType.debug('Retreived Component Implementation');
	}
}

-------------------------------------------------------------------------------------------
----	OVERRIDEN HELPERS
-------------------------------------------------------------------------------------------


helper context AADLI!ConnectedElement def : getConnFeatureImg(owner : AADLBA!ComponentImplementation) : AADLBA!Feature =
	if(not self.connectionEnd.oclIsKindOf(AADLI!Feature)) then
		owner.ownedSubcomponent->any(f|f.name=self.connectionEnd.name)
	else
		if (self.context.oclIsUndefined()) then
			if(self.connectionEnd.oclIsKindOf(AADLI!Port)) then
				if(self.connectionEnd.isDataOrEventDataPort() and self.connectionEnd.isThreadPort()) then
					self.connectionEnd.retreiveIdAccess(owner).debug(owner.name+' Port Id access')
				else
					owner.getType().getOwnedFeatures()->any(f|f.name=self.connectionEnd.name)
				endif
			else
				owner.getType().getOwnedFeatures()->any(f|f.name=self.connectionEnd.name)
			endif
		else
			if (self.getConnContextImg(owner).oclIsUndefined()) then
			    -- subcomponent is not yet mapped: feature cannot be resolved yet
				OclUndefined
			else 
				if (self.getConnContextImg(owner).oclIsKindOf(AADLBA!SubprogramCall)) then
					self.getConnContextImg(owner).calledSubprogram.ownedFeature->any(p|p.name=self.connectionEnd.name)
				else
					-- subcomponent is mapped: feature is accessible
					self.getConnContextImg(owner).getType().getOwnedFeatures()->any(f|f.name=self.connectionEnd.name)
				endif
			endif
		endif
	endif
;




rule PortConnection_Instance
{
	from
		cnxInst: AADLI!ConnectionInstance
		(
			thisModule.toBeTransformedInterProcessConnection(cnxInst)
		)
		
	using
	{
		c_source: AADLBA!ComponentInstance = cnxInst.source.eContainer();
		c_destination: AADLBA!ComponentInstance = cnxInst.destination.eContainer();
		process_sourceImplImg: AADLBA!ProcessImplementation = OclUndefined;
		process_destinationImplImg: AADLBA!ProcessImplementation = OclUndefined;
		sourceImplImg: AADLBA!ThreadImplementation = OclUndefined;
		sourceImpl: AADLI!ComponentImplementation = c_source.subcomponent.subcomponentType;
		destinationImplImg: AADLBA!ThreadImplementation = OclUndefined;
		destinationImpl: AADLI!ComponentImplementation = c_destination.subcomponent.subcomponentType;
		sourceFeatureImg: AADLBA!DataAccess = OclUndefined;
		destinationFeatureImg: AADLBA!DataAccess = OclUndefined;

	}
	to
		
		-- creation of a data subcomponent, to be added to the container process of target thread component, 
		-- this data is a global variable representing the
		-- ARINC653 communication identifier.
		communicationSrcID: AADLBA!DataSubcomponent
			(name<-'src_'+cnxInst.source.name+thisModule.dataSubcomponentSuffix()),
		communicationDstID: AADLBA!DataSubcomponent
			(name<-'dst_'+cnxInst.source.name+thisModule.dataSubcomponentSuffix())
	do
	{
		cnxInst.debug('initializing connection instance');
		
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(communicationSrcID, cnxInst.source);
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(communicationDstID, cnxInst.destination);
		
		sourceImplImg <- c_source.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		destinationImplImg <- c_destination.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		process_sourceImplImg <- c_source.eContainer().getSubcomponentImg().subcomponentType.debug('Retreived Process Implementation');
		process_destinationImplImg <- c_destination.eContainer().getSubcomponentImg().subcomponentType.debug('Retreived Process Implementation');
		sourceFeatureImg <- cnxInst.source.getFeatureImg().debug('Retreived Feature Image');
		destinationFeatureImg <- cnxInst.destination.getFeatureImg().debug('Retreived Feature Image');
		process_destinationImplImg.ownedDataSubcomponent.add(communicationDstID);
		process_sourceImplImg.ownedDataSubcomponent.add(communicationSrcID);
		
		if(cnxInst.source.category=#eventPort or cnxInst.source.category=#eventDataPort)
		{
			sourceFeatureImg.dataFeatureClassifier <- 'Queuing_Port_Id_Type'.asDataType('POK_RUNTIME');
			destinationFeatureImg.dataFeatureClassifier <- 'Queuing_Port_Id_Type'.asDataType('POK_RUNTIME');
			thisModule.addQueuingGlobalVariable(cnxInst.source, communicationSrcID, process_sourceImplImg, sourceImplImg);
			thisModule.addQueuingGlobalVariable(cnxInst.destination, communicationDstID, process_destinationImplImg, destinationImplImg);
		}
		else if(cnxInst.source.category=#dataPort)
		{
			sourceFeatureImg.dataFeatureClassifier<-'Sampling_Port_Id_Type'.asDataType('POK_RUNTIME');
			destinationFeatureImg.dataFeatureClassifier<-'Sampling_Port_Id_Type'.asDataType('POK_RUNTIME');
			thisModule.addSamplingGlobalVariable(cnxInst.source, communicationSrcID, process_sourceImplImg, sourceImplImg);
			thisModule.addSamplingGlobalVariable(cnxInst.destination, communicationDstID, process_destinationImplImg, destinationImplImg);
		}
		
		thisModule.addThreadsInternalConnections(cnxInst.source);
		thisModule.addThreadsInternalConnections(cnxInst.destination);
		thisModule.setSourcePortAccessorParameterConnections(cnxInst.source, sourceImpl, sourceImplImg);
		if(c_source.featureInstance->last().debug('Last Feature Instance') = cnxInst.source.debug('Current Feature Instance'))
		{
			true.debug('Expand Dispatch Protocol');
			thisModule.expandThreadDispatchProtocol(c_source, sourceImplImg);
		}
		thisModule.setDestinationPortAccessorParameterConnections(cnxInst.destination, destinationImpl, destinationImplImg);
		if(c_destination.featureInstance->last().debug('Last Feature Instance') = cnxInst.destination.debug('Current Feature Instance'))
		{
			true.debug('Expand Dispatch Protocol');
			thisModule.expandThreadDispatchProtocol(c_destination, destinationImplImg);
		}
		
		thisModule.addImportedUnit(thisModule.public(), 'POK_RUNTIME', 'pok_runtime');
		thisModule.addImportedUnit(thisModule.public(), 'BASE_TYPES', 'Base_Types');
	}
}

-------------------------------------------------------------------------------------------
----		ADDED MATCHED RULES
-------------------------------------------------------------------------------------------

rule intraProcess_PortConnection_Instance
{
	from
		cnxInst: AADLI!ConnectionInstance
		(
			thisModule.toBeTransformedIntraProcessConnection(cnxInst)
		)
	using
	{
		c_source: AADLBA!ComponentInstance = cnxInst.source.eContainer();
		c_destination: AADLBA!ComponentInstance = cnxInst.destination.eContainer();
		impl_source: AADLBA!ComponentClassifier = c_source.subcomponent.subcomponentType;
		impl_destination: AADLBA!ComponentClassifier = c_destination.subcomponent.subcomponentType;
		processImplImg: AADLBA!ProcessImplementation = OclUndefined;
		sourceImplImg: AADLBA!ThreadImplementation = OclUndefined;
		destinationImplImg: AADLBA!ThreadImplementation = OclUndefined;
		sourceFeatureImg: AADLBA!Feature = OclUndefined;
		destinationFeatureImg: AADLBA!Feature = OclUndefined;
	}
	to
		d: AADLBA!DataSubcomponent
			(name<-cnxInst.destination.name+thisModule.dataSubcomponentSuffix())
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(d, cnxInst.destination);
		
		sourceImplImg <- c_source.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		destinationImplImg <- c_destination.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		processImplImg <- c_source.eContainer().getSubcomponentImg().subcomponentType.debug('Retreived Process Implementation');
		sourceFeatureImg <- cnxInst.source.getFeatureImg().debug('Retreived Feature Image');
		destinationFeatureImg <- cnxInst.destination.getFeatureImg().debug('Retreived Feature Image'); 
		processImplImg.ownedDataSubcomponent.add(d);
		
		-- add and connect data subcomponent, Id of the communication protocol
		if(cnxInst.source.category=#eventPort)
		{
			d.dataSubcomponentType<-'Event_Id_Type'.asDataType('POK_RUNTIME');
			sourceFeatureImg.dataFeatureClassifier <- 'Event_Id_Type'.asDataType('POK_RUNTIME');
			destinationFeatureImg.dataFeatureClassifier <- 'Event_Id_Type'.asDataType('POK_RUNTIME');
		}
		else if(cnxInst.source.category=#eventDataPort)
		{
			d.dataSubcomponentType<-'Buffer_Id_Type'.asDataType('POK_RUNTIME');
			sourceFeatureImg.dataFeatureClassifier <- 'Buffer_Id_Type'.asDataType('POK_RUNTIME');
			destinationFeatureImg.dataFeatureClassifier <- 'Buffer_Id_Type'.asDataType('POK_RUNTIME');
		}
		else if(cnxInst.source.category=#dataPort)
		{
			-- add data subcomponents for Blackboard
			destinationFeatureImg.dataFeatureClassifier <- 'Blackboard_Id_Type'.asDataType('POK_RUNTIME');
			sourceFeatureImg.dataFeatureClassifier <- 'Blackboard_Id_Type'.asDataType('POK_RUNTIME');
			d.dataSubcomponentType<-'Blackboard_Id_Type'.asDataType('POK_RUNTIME');
		}
		
		thisModule.addDataAccessConnection(
			processImplImg,
			'Id_instance_to_'+cnxInst.source.eContainer().name+'_'+cnxInst.source.name,
			cnxInst.source.retreiveIdAccess(sourceImplImg), 
			c_source.getSubcomponentImg(),
			d
		);
		
		thisModule.addDataAccessConnection(
			processImplImg,
			'Id_instance_to_'+cnxInst.destination.eContainer().name+'_'+cnxInst.destination.name,
			cnxInst.destination.retreiveIdAccess(destinationImplImg), 
			c_destination.getSubcomponentImg(),
			d
		);
		
		
		thisModule.addThreadsInternalConnections(cnxInst.destination);
		thisModule.addThreadsInternalConnections(cnxInst.source);
		thisModule.setSourcePortAccessorParameterConnections(cnxInst.source, impl_source, sourceImplImg);
		if(c_source.featureInstance->last().debug('Last Feature Instance') = cnxInst.source.debug('Current Feature Instance'))
		{
			true.debug('Expand Dispatch Protocol');
			thisModule.expandThreadDispatchProtocol(c_source, sourceImplImg);
			
		}
		thisModule.setDestinationPortAccessorParameterConnections(cnxInst.destination, impl_destination, destinationImplImg);
		if(c_destination.featureInstance->last().debug('Last Feature Instance') = cnxInst.destination.debug('Current Feature Instance'))
		{
			true.debug('Expand Dispatch Protocol');
			thisModule.expandThreadDispatchProtocol(c_destination, destinationImplImg);
			
		}
		thisModule.addImportedUnit(thisModule.public(), 'POK_RUNTIME', 'pok_runtime');
		thisModule.addImportedUnit(thisModule.public(), 'BASE_TYPES', 'Base_Types');
	}
}

-------------------------------------------------------------------------------------------
----		ADDED HELPERS
-------------------------------------------------------------------------------------------

helper def: toBeTransformedInterProcessConnection(cnxInst: AADLI!ConnectionInstance): Boolean =
	(cnxInst.kind = #portConnection and
	cnxInst.source.eContainer().category=#thread) and
	not cnxInst.isIntraProcessConnection()
	and not cnxInst.source.isPeriodicDelayedPort()
;

helper def: toBeTransformedIntraProcessConnection(cnxInst: AADLI!ConnectionInstance): Boolean =
	(cnxInst.kind = #portConnection and
	cnxInst.source.eContainer().category=#thread and
	cnxInst.isIntraProcessConnection())
	and not cnxInst.source.isPeriodicDelayedPort()
;

helper def : getTimeOutInitValue(port : AADLBA!Feature) : AADLBA!PropertyExpression =
	if(port.getModalPropertyValue('Timeout').oclIsUndefined())
	then
		OclUndefined
	else
		if(port.getModalPropertyValue('Timeout').ownedValue.value.oclIsUndefined())
		then
			OclUndefined
		else
			thisModule.toStringLiteral(port.getModalPropertyValue('Timeout').ownedValue.value.toString())
		endif
	endif
;

helper context AADLI!FeatureInstance def : retreiveMessageAddress(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataSubcomponent =
	threadImplImg.ownedDataSubcomponent->any(e| e.name=self.name+'_MsgAddr')
;

helper context AADLI!FeatureInstance def : retreiveLengthValue(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataSubcomponent =
	threadImplImg.ownedDataSubcomponent->any(e| e.name=self.name+'_Length')
;

helper def : retreiveReturnCodeValue(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataSubcomponent =
	if(threadImplImg.ownedDataSubcomponent->any(e| e.name='runtime_call_ret').oclIsUndefined() )
	then
		thisModule.addReturnCodeDataSubcomponent(threadImplImg)
	else
		threadImplImg.ownedDataSubcomponent->any(e| e.name='runtime_call_ret')
	endif
;

helper context AADLI!FeatureInstance def : retreiveTimeOutValue(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataSubcomponent =
	threadImplImg.ownedDataSubcomponent->any(e| e.name=self.name+'_TimeOut')
;

helper context AADLI!FeatureInstance def : retreiveValidityValue(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataSubcomponent =
	threadImplImg.ownedDataSubcomponent->any(e| e.name=self.name+'_Validity')
;

helper context AADLI!FeatureInstance def : retreiveIdAccess(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataAccess =
	threadImplImg.type.ownedDataAccess->any(e| e.name.debug('!!!!!!')=(self.name+thisModule.dataAccessSuffix()+self.direction).debug('????'))
;

helper context AADLI!FeatureInstance def : retreiveIdValue(processImplImg: AADLBA!ProcessImplementation) : AADLBA!DataAccess =
	processImplImg.ownedDataSubcomponent->any(e| e.name=self.name+thisModule.dataSubcomponentSuffix())
;

helper context AADLI!ConnectionInstanceEnd def : getDestinations() : Sequence(AADLI!ConnectionInstanceEnd) =
    AADLI!ConnectionInstance->allInstancesFrom('IN')->select(c|c.source=self)
                            ->collect(c|c.destination)
;

helper context AADLI!ConnectionInstanceEnd def : getSources() : Sequence(AADLI!ConnectionInstanceEnd) =
    AADLI!ConnectionInstance->allInstancesFrom('IN')->select(c|c.destination=self)
                            ->collect(c|c.source)
; 

helper context AADLI!ComponentInstance def : getProcessorBinding() : AADLI!SubcomponentImplementation =
	self.ownedPropertyAssociation->any(e | e.property = AADLBA!Property->allInstancesFrom('DEPLOYMENT_PROPERTIES')->any(f|f.name = 'Actual_Processor_Binding')).appliesTo
;


-------------------------------------------------------------------------------------------
----		ADDED LAZY RULES
-------------------------------------------------------------------------------------------

rule setDestinationPortAccessorParameterConnections(port: AADLI!FeatureInstance,
													impl: AADLI!ComponentImplementation,
													implImg: AADLI!ComponentImplementation)
{
	do
	{
		for(cnx in impl.getOwnedParameterConnections())
		{
			if(cnx.source.connectionEnd = port.feature)
			{
				thisModule.addParameterConnection
				(
					implImg,
					'transfer_'+port.retreiveMessageAddress(implImg).name+'_to_'+cnx.destination.getConnContextImg(implImg).name+'_'+cnx.destination.getConnFeatureImg(implImg).name,
					cnx.destination.getConnFeatureImg(implImg),
					cnx.destination.getConnContextImg(implImg),
					port.retreiveMessageAddress(implImg)
				);
			}
		}
	}
}

rule setSourcePortAccessorParameterConnections(port: AADLI!FeatureInstance, 
											   impl: AADLI!ComponentImplementation, 
											   implImg: AADLI!ComponentImplementation)
{
	do
	{
		for(cnx in impl.getOwnedParameterConnections())
		{
			if(cnx.destination.connectionEnd = port.feature)
			{
				thisModule.addParameterConnection
				(
					implImg,
					'transfer_'+
						port.retreiveMessageAddress(implImg).name+
						'_to_'+cnx.source.getConnContextImg(implImg).name+'_'+
						cnx.source.getConnFeatureImg(implImg).name,
					cnx.source.getConnFeatureImg(implImg),
					cnx.source.getConnContextImg(implImg),
					port.retreiveMessageAddress(implImg)
				);
			}
		}
	}
}

unique lazy rule addLengthDataSubcomponent
{
	from
		port : AADLI!FeatureInstance,
		implImg : AADLBA!ThreadImplementation
	using
	{
		typeId: String = port.feature.dataFeatureClassifier.getQualifiedName().replaceAll('::', '__').replaceAll('.','_');
		initValuePE: AADLBA!PropertyExpression = thisModule.CreateStringLiteralPropertyExpression('sizeof('+typeId+')');
	}
	to
		lv: AADLBA!ListValue
		(
			ownedListElement <- Sequence{initValuePE}
		),
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-port.feature.name+'_Length',
			dataSubcomponentType<-'Unsigned_8'.asBaseType(),
			ownedPropertyAssociation	<- Sequence {thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL',lv)}
		)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(dataSubcomponent, port);
		implImg.ownedDataSubcomponent.add(dataSubcomponent);
		dataSubcomponent;
	}
}

unique lazy rule addMessageAddrDataSubcomponent
{
	from
		port : AADLI!FeatureInstance,
		implImg : AADLBA!ThreadImplementation
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-port.feature.name+'_MsgAddr',
			dataSubcomponentType<-port.feature.dataFeatureClassifier
		)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(dataSubcomponent, port);
		implImg.ownedDataSubcomponent.add(dataSubcomponent);
		dataSubcomponent;
	}
}

unique lazy rule addValidityDataSubcomponent
{
	from
		port : AADLBA!FeatureInstance,
		implImg : AADLBA!ThreadImplementation
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-port.feature.name+'_Validity',
			dataSubcomponentType<-'Validity_Type'.asDataType('POK_RUNTIME')
		)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(dataSubcomponent, port);
		implImg.ownedDataSubcomponent.add(dataSubcomponent);
		dataSubcomponent;
	}
}

unique lazy rule addTimeOutSubcomponent
{
	from
		port : AADLI!FeatureInstance,
		implImg : AADLBA!ThreadImplementation
		
	using
	{
		initValuePE: AADLBA!PropertyExpression = thisModule.getTimeOutInitValue(port.feature);
	}
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-port.feature.name+'_TimeOut',
			dataSubcomponentType<-'System_Time_Type'.asDataType('POK_RUNTIME')
		)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(dataSubcomponent, port);
		implImg.ownedDataSubcomponent.add(dataSubcomponent);
		if(not initValuePE.oclIsUndefined())
		{
			dataSubcomponent.ownedPropertyAssociation.add(thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL',thisModule.createListValueFromPropertyExpression(initValuePE)));
		}
		dataSubcomponent;
	}
}

unique lazy rule addReturnCodeDataSubcomponent
{
	from
		impl: AADLBA!ThreadImplementation
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name <- 'runtime_call_ret',
			dataSubcomponentType<-'Return_Code_Type'.asDataType('POK_RUNTIME')
		)
	do
	{
		impl.getOwnedDataSubcomponents().add(dataSubcomponent);
		dataSubcomponent;
	}
}

------------------------------------
---      ADDED CALLED RULES     ----
------------------------------------

rule addNextValueSubprogramCall(seq : AADLBA!SubprogramCallSequence,
								impl : AADLBA!ComponentImplementation,
								implImg : AADLBA!ComponentImplementation,
								fi: AADLI!FeatureInstance)
{
	do
	{
		for(cnxInst in fi.dstConnectionInstance)
		{
			if(thisModule.toBeTransformedInterProcessConnection(cnxInst))
			{
				if(cnxInst.source.category=#eventPort or cnxInst.source.category=#eventDataPort)
				{
					thisModule.addReceiveQueuing(seq, fi, impl, implImg);
				}
				else if(cnxInst.source.category=#dataPort)
				{
					thisModule.addReadSampling(seq, fi, impl, implImg);
				}
			}
			else if(thisModule.toBeTransformedIntraProcessConnection(cnxInst))
			{
				if(cnxInst.source.category=#eventPort)
				{
					thisModule.addWaitEvent(seq, fi, impl, implImg);
				}
				else if(cnxInst.source.category=#eventDataPort)
				{
					thisModule.addReceiveBuffer(seq, fi, impl, implImg);
				}
				else if(cnxInst.source.category=#dataPort)
				{
					thisModule.addReadBlackBoard(seq, fi, impl, implImg);
				}
			}
		}
	}
}

rule addPutValueSubprogramCall(seq : AADLBA!SubprogramCallSequence,
								impl : AADLBA!ComponentImplementation,
								implImg : AADLBA!ComponentImplementation,
								fi: AADLI!FeatureInstance)
{
	do
	{
		for(cnxInst in fi.srcConnectionInstance)
		{
		
			if(thisModule.toBeTransformedInterProcessConnection(cnxInst))
			{
				if(cnxInst.destination.category=#eventPort or cnxInst.source.category=#eventDataPort)
				{
					thisModule.addSendQueuing(seq, fi, impl, implImg);
				}
				else if(cnxInst.destination.category=#dataPort)
				{
					thisModule.addWriteSampling(seq, fi, impl, implImg);
				}
			}
			else if(thisModule.toBeTransformedIntraProcessConnection(cnxInst))
			{
				if(cnxInst.destination.category=#eventPort)
				{
					thisModule.addSetEvent(seq, fi, impl, implImg);
				}
				else if(cnxInst.destination.category=#dataPort)
				{
					thisModule.addDisplayBlackBoard(seq, fi, impl, implImg);
				}
				else if(cnxInst.destination.category=#eventDataPort)
				{
					thisModule.addSendBuffer(seq, fi, impl, implImg);
				}
			}
		}
	}
}

rule addThreadsInternalConnections(fi: AADLI!FeatureInstance)
{
	using
	{
		c : AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLBA!ComponentImplementation = c.getSubcomponentImg().subcomponentType;
		impl: AADLBA!ComponentImplementation = c.getImpl();
	}
	do
	{
		if(c.category=#thread and c.featureInstance->last() = fi)
		{
			for(cnx in impl.ownedParameterConnection)
			{
				if(cnx.source.connectionEnd.oclIsKindOf(AADLI!Parameter) 
						and cnx.destination.connectionEnd.oclIsKindOf(AADLI!Parameter))
				{
					thisModule.addSuprogramCallParameterConnection(implImg, cnx);
				}
			}
			implImg.ownedAccessConnection <- impl.ownedAccessConnection->collect(co|thisModule.AccessConnection(co, implImg));
		}
	}
}


--------------------------------------------
--- Generation of ARINC Subprogram Calls ---
--------------------------------------------


--------------------------------------------
---              BLACKBOARD              ---
--------------------------------------------

rule addReadBlackBoard(seq : AADLBA!SubprogramCallSequence,
					   fi: AADLI!FeatureInstance,
					   impl:  AADLI!ComponentImplementation, 
					   implImg: AADLBA!ComponentImplementation)
{
	do
	{
		thisModule.addLengthDataSubcomponent(fi, implImg);
		thisModule.addMessageAddrDataSubcomponent(fi, implImg);
		thisModule.addTimeOutSubcomponent(fi, implImg);	
		-- add call to Read_Blackboard
		thisModule.addReadBlackBoardCallSpecification
		(
			seq,
			'Read_Blackboard'.asSubprogramType('POK_RUNTIME'),
			fi,
			implImg
		);
	}
}

rule addDisplayBlackBoard(seq : AADLBA!SubprogramCallSequence,
						  fi: AADLI!FeatureInstance,
						  impl:  AADLI!ComponentImplementation, 
						  implImg: AADLBA!ComponentImplementation)
{
	do
	{
		thisModule.addLengthDataSubcomponent(fi,implImg);
		thisModule.addMessageAddrDataSubcomponent(fi,implImg);
		thisModule.addTimeOutSubcomponent(fi,implImg);
					
		-- add call to Display_Blackboard
		thisModule.addDisplayBlackBoardCallSpecification
		(
			seq,
			'Display_Blackboard'.asSubprogramType('POK_RUNTIME'),
			fi,
			implImg
		);

	}
}


rule addDisplayBlackBoardCallSpecification(seq : AADLBA!SubprogramCallSequence,
										   spg: AADLBA!SubprogramType,
										   p: AADLI!FeatureInstance, 
										   implImg: AADLBA!ThreadImplementation)
{
	to
		call: AADLBA!SubprogramCall
		(
			name<-thisModule.callPrefix()+spg.name+p.name,
			calledSubprogram<-spg
		)
	do
	{
		thisModule.addBlackBoardCallSpecification(call, spg, p, implImg);
		seq.getOwnedCallSpecifications().add(call);
	}
}

rule addReadBlackBoardCallSpecification(seq : AADLBA!SubprogramCallSequence,
										spg: AADLBA!SubprogramType,
										p: AADLI!FeatureInstance,
										implImg: AADLBA!ThreadImplementation)
{
	using
	{
		TIME_OUT: AADLBA!DataSubcomponent = p.retreiveTimeOutValue(implImg);
	}
	to
		call: AADLBA!SubprogramCall
		(
			name<-thisModule.callPrefix()+spg.name+p.name,
			calledSubprogram<-spg
		),
		connectedParam_TIME_OUT: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->first().debug('TimeOut Parameter Connection End')
		),
		connectedSubcomponent_TIME_OUT: AADLBA!ConnectedElement
		(
			connectionEnd<-TIME_OUT.debug('TimeOut Subcomponent Connection End')
		),
		paramConnection_TIME_OUT: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_TimeOut',
			source<-connectedParam_TIME_OUT,
			destination<-connectedSubcomponent_TIME_OUT
		)
	do
	{
		thisModule.addBlackBoardCallSpecification(call, spg, p, implImg);
		connectedParam_TIME_OUT.setContext(call);
		implImg.getOwnedParameterConnections().add(paramConnection_TIME_OUT);
		seq.getOwnedCallSpecifications().add(call);
	}
}

rule addBlackBoardCallSpecification(call: AADLBA!SubprogramCall, spg: AADLBA!SubprogramType, p: AADLI!FeatureInstance, implImg: AADLBA!ThreadImplementation)
{
	using
	{
		BLACKBOARD_ID: AADLBA!DataAccess = p.getFeatureImg(); 
		MESSAGE_ADDR: AADLBA!DataSubcomponent = p.retreiveMessageAddress(implImg);
		LENGTH: AADLBA!DataSubcomponent = p.retreiveLengthValue	(implImg);
		RETURN_CODE: AADLBA!DataSubcomponent = thisModule.retreiveReturnCodeValue(implImg);
	}
	to
		
		connected_BLACKBOARD_ID_Access: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedDataAccess->first().debug('Id Data Access Connection End')
		),
		connected_BLACKBOARD_ID: AADLBA!ConnectedElement
		(
			connectionEnd<-BLACKBOARD_ID.debug('Id Subcomponent Connection End')
		),
		accessIDConnection: AADLBA!AccessConnection
		(
			name<-p.name+'_to_ID',
			accessCategory<-#data,
			source<-connected_BLACKBOARD_ID_Access,
			destination<-connected_BLACKBOARD_ID
		),
		
		connectedParam_MESSAGE_ADDR: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='MESSAGE_ADDR').debug('MessageAddr Parameter Connection End')
		),
		connectedSubcomponent_MESSAGE_ADDR: AADLBA!ConnectedElement
		(
			connectionEnd<-MESSAGE_ADDR.debug('MessageAddr Subcomponent Connection End')
		),
		paramConnection_MESSAGE_ADDR: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_MessageAddr',
			source<-connectedParam_MESSAGE_ADDR,
			destination<-connectedSubcomponent_MESSAGE_ADDR
		),
		
		connectedParam_LENGTH: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='LENGTH').debug('Length Parameter Connection End')
		),
		connectedSubcomponent_LENGTH: AADLBA!ConnectedElement
		(
			connectionEnd<-LENGTH.debug('Length Subcomponent Connection End')
		),
		
		paramConnection_LENGTH: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_MessageLength',
			source<-connectedParam_LENGTH,
			destination<-connectedSubcomponent_LENGTH
		),
		
		connectedParam_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='RETURN_CODE').debug('Subprogram Parameter Connection End')
		),
		connectedSubcomponent_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-RETURN_CODE.debug('Subprogram Subcomponent Connection End')
		),
		paramConnection_RETURN_CODE: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_ReturnCode',
			source<-connectedParam_RETURN_CODE,
			destination<-connectedSubcomponent_RETURN_CODE
		)
		
	do
	{
		
		connectedParam_MESSAGE_ADDR.setContext(call);
		connected_BLACKBOARD_ID_Access.setContext(call);
		connectedParam_RETURN_CODE.setContext(call);
		connectedParam_LENGTH.setContext(call);
		
		implImg.getOwnedParameterConnections().add(paramConnection_MESSAGE_ADDR);
		implImg.getOwnedAccessConnections().add(accessIDConnection);
		implImg.getOwnedParameterConnections().add(paramConnection_RETURN_CODE);
		implImg.getOwnedParameterConnections().add(paramConnection_LENGTH);
		
		call.debug('Created Call Sequence');
		call;
	}
}

--------------------------------------------
---                EVENT                 ---
--------------------------------------------


rule addWaitEvent(seq : AADLBA!SubprogramCallSequence,
				  fi: AADLI!FeatureInstance,
				  impl:  AADLI!ComponentImplementation,
				  implImg: AADLBA!ComponentImplementation)
{
	do
	{
		thisModule.addTimeOutSubcomponent(fi,implImg);
		-- add call to Wait_Event
		thisModule.addWaitEventCallSpecification
		(
			seq,
			'Wait_Event'.asSubprogramType('POK_RUNTIME'),
			fi,
			implImg
		);
	}
}

rule addSetEvent(seq : AADLBA!SubprogramCallSequence,
				 fi: AADLI!FeatureInstance,
				 impl:  AADLI!ComponentImplementation,
				 implImg: AADLBA!ComponentImplementation)
{
	do
	{
		for(dest in fi.getDestinations())
		{
			if(dest.eContainer().eContainer() = fi.eContainer().eContainer())
			{
				-- add call to Set_Event
				thisModule.addSetEventCallSpecification
				(
					seq,
					'Set_Event'.asSubprogramType('POK_RUNTIME'),
					fi,
					implImg
				);
				
			}
		}
	}
}


rule addWaitEventCallSpecification(seq : AADLBA!SubprogramCallSequence,
								   spg: AADLBA!SubprogramType,
								   p: AADLI!FeatureInstance,
								   implImg: AADLBA!ThreadImplementation)
{
	using
	{
		TIME_OUT: AADLBA!DataSubcomponent = p.retreiveTimeOutValue(implImg);
	}
	to
		call: AADLBA!SubprogramCall
		(
			name<-thisModule.callPrefix()+spg.name+p.name,
			calledSubprogram<-spg
		),
		connectedParam_TIME_OUT: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->first().debug('TimeOut Parameter Connection End')
		),
		connectedSubcomponent_TIME_OUT: AADLBA!ConnectedElement
		(
			connectionEnd<-TIME_OUT.debug('TimeOut Subcomponent Connection End')
		),
		paramConnection_TIME_OUT: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_TimeOut',
			source<-connectedParam_TIME_OUT,
			destination<-connectedSubcomponent_TIME_OUT
		)
	do
	{
		seq.getOwnedCallSpecifications().add(call);
		thisModule.addEventCallSpecification(call, spg, p, implImg);
		connectedParam_TIME_OUT.setContext(call);
		implImg.getOwnedParameterConnections().add(paramConnection_TIME_OUT);
	}
}

rule addSetEventCallSpecification(seq : AADLBA!SubprogramCallSequence,
								  spg: AADLBA!SubprogramType,
								  p: AADLI!FeatureInstance,
								  implImg: AADLBA!ThreadImplementation)
{
	to
		call: AADLBA!SubprogramCall
		(
			name<-thisModule.callPrefix()+spg.name+p.name,
			calledSubprogram<-spg
		)
	do
	{
		thisModule.addEventCallSpecification(call, spg, p, implImg);
		seq.getOwnedCallSpecifications().add(call);
	}
}

rule addEventCallSpecification(call: AADLBA!SubprogramCall, spg: AADLBA!SubprogramType, p: AADLI!FeatureInstance, implImg: AADLBA!ThreadImplementation)
{
	using
	{
		EVENT_ID: AADLBA!DataAccess = p.getFeatureImg(); 
		RETURN_CODE: AADLBA!DataSubcomponent = thisModule.retreiveReturnCodeValue(implImg);
	}
	to
		connected_EVENT_ID_Access: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedDataAccess->first().debug('Id Data Access Connection End')
		),
		connected_EVENT_ID: AADLBA!ConnectedElement
		(
			connectionEnd<-EVENT_ID.debug('Id Subcomponent Connection End')
		),
		accessIDConnection: AADLBA!AccessConnection
		(
			name<-p.name+'_to_ID',
			accessCategory<-#data,
			source<-connected_EVENT_ID_Access,
			destination<-connected_EVENT_ID
		),
		
		connectedParam_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='RETURN_CODE').debug('Subprogram Parameter Connection End')
		),
		connectedSubcomponent_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-RETURN_CODE.debug('Subprogram Subcomponent Connection End')
		),
		paramConnection_RETURN_CODE: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_ReturnCode',
			source<-connectedParam_RETURN_CODE,
			destination<-connectedSubcomponent_RETURN_CODE
		)
		
	do
	{
		
		connected_EVENT_ID_Access.setContext(call);
		connectedParam_RETURN_CODE.setContext(call);
		
		implImg.getOwnedAccessConnections().add(accessIDConnection);
		implImg.getOwnedParameterConnections().add(paramConnection_RETURN_CODE);

		
		call.debug('Created Call Sequence');
		call;
	}
}

--------------------------------------------
---               BUFFER                 ---
--------------------------------------------

rule addReceiveBuffer(seq : AADLBA!SubprogramCallSequence,
					  fi: AADLI!FeatureInstance,
					  impl:  AADLI!ComponentImplementation,
					  implImg: AADLBA!ComponentImplementation)
{
	do
	{
		thisModule.addTimeOutSubcomponent(fi,implImg);
		thisModule.addMessageAddrDataSubcomponent(fi,implImg);
		thisModule.addLengthDataSubcomponent(fi,implImg);
					
		-- add call to Receive_Buffer
		thisModule.addQueuingMessageCallSpecification
		(
			seq,
			'Receive_Buffer'.asSubprogramType('POK_RUNTIME'),
			fi,
			implImg
		);

	}
}

rule addSendBuffer(seq : AADLBA!SubprogramCallSequence,
				   fi: AADLI!FeatureInstance,
				   impl:  AADLI!ComponentImplementation,
				   implImg: AADLBA!ComponentImplementation)
{
	do
	{
		thisModule.addMessageAddrDataSubcomponent(fi,implImg);
		thisModule.addLengthDataSubcomponent(fi,implImg);
		thisModule.addTimeOutSubcomponent(fi,implImg);
		
		-- add call to Send_Buffer
		thisModule.addQueuingMessageCallSpecification
		(
			seq,
			'Send_Buffer'.asSubprogramType('POK_RUNTIME'),
			fi,
			implImg
		);
		
	}
}

--------------------------------------------
---               SAMPLING               ---
--------------------------------------------

rule addReadSampling(seq : AADLBA!SubprogramCallSequence,
					 fi: AADLI!FeatureInstance, 
					 impl:  AADLI!ComponentImplementation,
					 implImg: AADLBA!ComponentImplementation)
{
	do
	{
		thisModule.addLengthDataSubcomponent(fi,implImg);
		thisModule.addMessageAddrDataSubcomponent(fi,implImg);
		thisModule.addValidityDataSubcomponent(fi,implImg);
					
		-- add call to Read_Sampling_Message
		thisModule.addReadSamplingMessageCallSpecification
		(
			seq,
			'Read_Sampling_Message'.asSubprogramType('POK_RUNTIME'),
			fi,
			implImg
		);
					
	}
}

rule addWriteSampling(seq : AADLBA!SubprogramCallSequence,
					  fi: AADLI!FeatureInstance, 
					  impl:  AADLI!ComponentImplementation,
					  implImg: AADLBA!ComponentImplementation)
{
	do
	{
		-- add data subcomponents for Write_Sampling_Message
		thisModule.addLengthDataSubcomponent(fi,implImg);
		thisModule.addMessageAddrDataSubcomponent(fi,implImg);
					
		-- add call to Write_Sampling_Message
		thisModule.addWriteSamplingMessageCallSpecification
		(
			seq,
			'Write_Sampling_Message'.asSubprogramType('POK_RUNTIME'),
			fi,
			implImg
		);
					
	}
}

rule addSamplingGlobalVariable(fi: AADLI!FeatureInstance, 
					 communicationID: AADLBA!DataSubcomponent,
					 processImplImg: AADLBA!ComponentImplementation,
					 implImg: AADLBA!ComponentImplementation)
{
	do
	{
		communicationID.dataSubcomponentType<-'Sampling_Port_Id_Type'.asDataType('POK_RUNTIME');
		processImplImg.ownedDataSubcomponent.add(communicationID);
		thisModule.addDataAccessConnection(
			processImplImg,
			'Id_instance_to_'+fi.eContainer().name+'_'+fi.name,
			fi.retreiveIdAccess(implImg), 
			fi.eContainer().getSubcomponentImg(),
			communicationID
		);
	}
}

rule addWriteSamplingMessageCallSpecification(seq : AADLBA!SubprogramCallSequence,
											  spg: AADLBA!SubprogramType,
											  p: AADLI!Port, 
											  implImg: AADLBA!ThreadImplementation)
{
	to
		call: AADLBA!SubprogramCall
		(
			name<-thisModule.callPrefix()+spg.name+p.name,
			calledSubprogram<-spg
		)
	do
	{
		thisModule.addSamplingCallSpecification(call, spg, p, implImg);
		seq.getOwnedCallSpecifications().add(call);
	}
}

rule addReadSamplingMessageCallSpecification (seq : AADLBA!SubprogramCallSequence,
											  spg: AADLBA!SubprogramType, 
											  p: AADLI!Port, 
											  implImg: AADLBA!ThreadImplementation)
{
	using
	{
		VALIDITY: AADLBA!DataSubcomponent = p.retreiveValidityValue(implImg);
	}
	to
		call: AADLBA!SubprogramCall
		(
			name<-thisModule.callPrefix()+spg.name+p.name,
			calledSubprogram<-spg
		),
		connectedParam_VALIDITY: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='VALIDITY').debug('TimeOut Parameter Connection End')
		),
		connectedSubcomponent_VALIDITY: AADLBA!ConnectedElement
		(
			connectionEnd<-VALIDITY.debug('TimeOut Subcomponent Connection End')
		),
		paramConnection_VALIDITY: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_Validity',
			source<-connectedParam_VALIDITY,
			destination<-connectedSubcomponent_VALIDITY
		)
	do
	{
		thisModule.addSamplingCallSpecification(call, spg, p, implImg);
		connectedParam_VALIDITY.setContext(call);
		implImg.getOwnedParameterConnections().add(paramConnection_VALIDITY);
		seq.getOwnedCallSpecifications().add(call);
	}
}

rule addSamplingCallSpecification(call: AADLBA!SubprogramCall,
								  spg: AADLBA!SubprogramType,
								  p: AADLI!FeatureInstance,
								  implImg: AADLBA!ThreadImplementation)
{
	using
	{
		SAMPLING_ID: AADLBA!DataAccess = p.getFeatureImg(); 
		MESSAGE_ADDR: AADLBA!DataSubcomponent = p.retreiveMessageAddress(implImg);
		LENGTH: AADLBA!DataSubcomponent = p.retreiveLengthValue	(implImg);
		RETURN_CODE: AADLBA!DataSubcomponent = thisModule.retreiveReturnCodeValue(implImg);
	}
	to
		
		connected_SAMPLING_ID_Access: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedDataAccess->first().debug('Id Data Access Connection End')
		),
		connected_SAMPLING_ID: AADLBA!ConnectedElement
		(
			connectionEnd<-SAMPLING_ID.debug('Id Subcomponent Connection End')
		),
		accessIDConnection: AADLBA!AccessConnection
		(
			name<-p.name+'_to_ID',
			accessCategory<-#data,
			source<-connected_SAMPLING_ID_Access,
			destination<-connected_SAMPLING_ID
		),
		
		connectedParam_MESSAGE_ADDR: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='MESSAGE_ADDR').debug('MessageAddr Parameter Connection End')
		),
		connectedSubcomponent_MESSAGE_ADDR: AADLBA!ConnectedElement
		(
			connectionEnd<-MESSAGE_ADDR.debug('MessageAddr Subcomponent Connection End')
		),
		paramConnection_MESSAGE_ADDR: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_MessageAddr',
			source<-connectedParam_MESSAGE_ADDR,
			destination<-connectedSubcomponent_MESSAGE_ADDR
		),
		
		connectedParam_LENGTH: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='LENGTH').debug('Length Parameter Connection End')
		),
		connectedSubcomponent_LENGTH: AADLBA!ConnectedElement
		(
			connectionEnd<-LENGTH.debug('Length Subcomponent Connection End')
		),
		
		paramConnection_LENGTH: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_MessageLength',
			source<-connectedParam_LENGTH,
			destination<-connectedSubcomponent_LENGTH
		),
		
		connectedParam_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='RETURN_CODE').debug('Subprogram Parameter Connection End')
		),
		connectedSubcomponent_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-RETURN_CODE.debug('Subprogram Subcomponent Connection End')
		),
		paramConnection_RETURN_CODE: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_ReturnCode',
			source<-connectedParam_RETURN_CODE,
			destination<-connectedSubcomponent_RETURN_CODE
		)
		
	do
	{
		
		connectedParam_MESSAGE_ADDR.setContext(call);
		connected_SAMPLING_ID_Access.setContext(call);
		connectedParam_RETURN_CODE.setContext(call);
		connectedParam_LENGTH.setContext(call);
		
		implImg.getOwnedParameterConnections().add(paramConnection_MESSAGE_ADDR);
		implImg.getOwnedAccessConnections().add(accessIDConnection);
		implImg.getOwnedParameterConnections().add(paramConnection_RETURN_CODE);
		implImg.getOwnedParameterConnections().add(paramConnection_LENGTH);
		
		call.debug('Created Call Sequence');
		call;
	}
}

--------------------------------------------
---               QUEUING                ---
--------------------------------------------

rule addReceiveQueuing(seq : AADLBA!SubprogramCallSequence,
					   fi: AADLI!FeatureInstance, 
					   impl:  AADLI!ComponentImplementation,
					   implImg: AADLBA!ComponentImplementation)
{
	do
	{
		-- add data subcomponents for Receive_Queing_Message
		thisModule.addTimeOutSubcomponent(fi,implImg);
		thisModule.addMessageAddrDataSubcomponent(fi,implImg);
		thisModule.addLengthDataSubcomponent(fi,implImg);
		
		-- add call to Receive_Queing_Message
		thisModule.addQueuingMessageCallSpecification
		(
			seq,
			'Receive_Queuing_Message'.asSubprogramType('POK_RUNTIME'),
			fi,
			implImg
		);
		
	}
}

rule addSendQueuing(seq : AADLBA!SubprogramCallSequence,
					fi: AADLI!FeatureInstance, 
					impl:  AADLI!ComponentImplementation,
					implImg: AADLBA!ComponentImplementation)
{
	do
	{
		thisModule.addMessageAddrDataSubcomponent(fi,implImg);
		thisModule.addLengthDataSubcomponent(fi,implImg);
		thisModule.addTimeOutSubcomponent(fi,implImg);
		
		-- add call to Send_Queuing_Message
		thisModule.addQueuingMessageCallSpecification
		(
			seq,
			'Send_Queuing_Message'.asSubprogramType('POK_RUNTIME'),
			fi,
			implImg
		);
				
	}
}

rule addQueuingGlobalVariable(fi: AADLI!FeatureInstance, 
					 communicationID: AADLBA!DataSubcomponent,
					 processImplImg: AADLBA!ComponentImplementation,
					 implImg: AADLBA!ComponentImplementation)
{
	do
	{
		communicationID.dataSubcomponentType<-'Queuing_Port_Id_Type'.asDataType('POK_RUNTIME');
		processImplImg.ownedDataSubcomponent.add(communicationID);
		thisModule.addDataAccessConnection(
			processImplImg,
			'Id_instance_to_'+fi.eContainer().name+'_'+fi.name,
			fi.retreiveIdAccess(implImg), 
			fi.eContainer().getSubcomponentImg(),
			communicationID
		);
	}
}

rule addQueuingMessageCallSpecification(seq : AADLBA!SubprogramCallSequence,
										spg: AADLBA!SubprogramType, 
										p: AADLI!FeatureInstance, 
										implImg: AADLBA!ThreadImplementation)
{
	using
	{
		QUEUING_PORT_ID: AADLBA!DataAccess = p.getFeatureImg();
		TIME_OUT: AADLBA!DataSubcomponent = p.retreiveTimeOutValue(implImg);
		MESSAGE_ADDR: AADLBA!DataSubcomponent = p.retreiveMessageAddress(implImg);
		LENGTH: AADLBA!DataSubcomponent = p.retreiveLengthValue	(implImg);
		RETURN_CODE: AADLBA!DataSubcomponent = thisModule.retreiveReturnCodeValue(implImg);
	}
	to
		call: AADLBA!SubprogramCall
		(
			name<-thisModule.callPrefix()+spg.name+'_'+p.name+seq.getOwnedCallSpecifications().size(),
			calledSubprogram<-spg
		),
		
		connected_QUEUING_ID_Access: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedDataAccess->first().debug('Id Data Access Connection End')
		),
		connected_QUEUING_ID: AADLBA!ConnectedElement
		(
			connectionEnd<-QUEUING_PORT_ID.debug('Id Subcomponent Connection End')
		),
		accessIDConnection: AADLBA!AccessConnection
		(
			name<-p.name+'_to_ID',
			accessCategory<-#data,
			source<-connected_QUEUING_ID_Access,
			destination<-connected_QUEUING_ID
		),
		
		connectedParam_TIME_OUT: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='TIME_OUT').debug('TimeOut Parameter Connection End')
		),
		connectedSubcomponent_TIME_OUT: AADLBA!ConnectedElement
		(
			connectionEnd<-TIME_OUT.debug('TimeOut Subcomponent Connection End')
		),
		paramConnection_TIME_OUT: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_TimeOut',
			source<-connectedParam_TIME_OUT,
			destination<-connectedSubcomponent_TIME_OUT
		),
		
		connectedParam_MESSAGE_ADDR: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='MESSAGE_ADDR').debug('MsgAddr Parameter Connection End')
		),
		connectedSubcomponent_MESSAGE_ADDR: AADLBA!ConnectedElement
		(
			connectionEnd<-MESSAGE_ADDR.debug('MsgAddr Subcomponent Connection End')
		),
		paramConnection_MESSAGE_ADDR: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_MsgAddr',
			source<-connectedParam_MESSAGE_ADDR,
			destination<-connectedSubcomponent_MESSAGE_ADDR
		),
		
		connectedParam_LENGTH: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='LENGTH').debug('MessageAddr Parameter Connection End')
		),
		connectedSubcomponent_LENGTH: AADLBA!ConnectedElement
		(
			connectionEnd<-LENGTH.debug('TimeOut Subcomponent Connection End')
		),
		paramConnection_LENGTH: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_Length',
			source<-connectedParam_LENGTH,
			destination<-connectedSubcomponent_LENGTH
		),
		
		connectedParam_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='RETURN_CODE').debug('ReturnCode Parameter Connection End')
		),
		connectedSubcomponent_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-RETURN_CODE.debug('ReturnCode Subcomponent Connection End')
		),
		paramConnection_RETURN_CODE: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_ReturnCode',
			source<-connectedParam_RETURN_CODE,
			destination<-connectedSubcomponent_RETURN_CODE
		)
		
	do
	{
		
		connected_QUEUING_ID_Access.setContext(call);
		connectedParam_TIME_OUT.setContext(call);
		connectedParam_MESSAGE_ADDR.setContext(call);
		connectedParam_LENGTH.setContext(call);
		connectedParam_RETURN_CODE.setContext(call);
		
		implImg.getOwnedAccessConnections().add(accessIDConnection);
		implImg.getOwnedParameterConnections().add(paramConnection_TIME_OUT);
		implImg.getOwnedParameterConnections().add(paramConnection_MESSAGE_ADDR);
		implImg.getOwnedParameterConnections().add(paramConnection_LENGTH);
		implImg.getOwnedParameterConnections().add(paramConnection_RETURN_CODE);
		
		seq.getOwnedCallSpecifications().add(call);
		
		call.debug('Created Call Sequence');
		call;
	}
}
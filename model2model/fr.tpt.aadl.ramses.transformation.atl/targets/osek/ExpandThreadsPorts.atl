module ExpandThreadsPorts;
create OUT : AADLBA								-- Detailed model : org.osate.aadl2/model/addl2.ecore
from 		IN : AADLI,							-- Simplified model : org.osate.aadl2/model/instance.ecore
			AADL_RUNTIME: AADLBA,
			DATA_MODEL: AADLBA,
			PROGRAMMING_PROPERTIES: AADLBA,
			HOOKS: ATLHOOKS,						
			OSEK_RUNTIME: AADLBA;

uses Services;
uses AADLCopyHelpers;
uses AADLICopyHelpers;
uses Uninstanciate;
uses PropertiesTools;

rule PortConnection_Instance
{
	from
		cnxInst: AADLI!ConnectionInstance
		(
			false
		)
}

rule EventDataPort_Instance
{
	from
		fi: AADLI!FeatureInstance (fi.category=#dataPort
									and fi.eContainer().category=#thread
									and not fi.isPeriodicDelayedPort())
	to
		-- target data access must be called 'f' to be retreived with resolveTemp 
		f: AADLBA!DataAccess
		(
			name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
			kind <- #requires
		)
}
		

rule addNextValueSubprogramCall(seq : AADLBA!SubprogramCallSequence,
								impl : AADLBA!ComponentImplementation,
								implImg : AADLBA!ComponentImplementation,
								fi: AADLI!FeatureInstance)
{
	
}

rule addPutValueSubprogramCall(seq : AADLBA!SubprogramCallSequence,
								impl : AADLBA!ComponentImplementation,
								implImg : AADLBA!ComponentImplementation,
								fi: AADLI!FeatureInstance)
{
	
}

rule setSourcePortAccessorParameterConnections(port: AADLI!FeatureInstance, 
											   impl: AADLI!ComponentImplementation, 
											   implImg: AADLI!ComponentImplementation)
{
	do
	{
		
	}
}

rule setDestinationPortAccessorParameterConnections(port: AADLI!FeatureInstance, 
											   		impl: AADLI!ComponentImplementation, 
											   		implImg: AADLI!ComponentImplementation)
{
	do
	{
		
	}
}

unique lazy rule addStatusType
{
	from
		implImg : AADLBA!BehavioredImplementation
	to
		status: AADLBA!DataSubcomponent
		(
			name <- 'osek_calls_status',
			dataSubcomponentType <- 'StatusType'.asSubprogramType('OSEK_RUNTIME')
		)
	do
	{
		implImg.ownedDataSubcomponent.add(status);
		status;
	}	
}
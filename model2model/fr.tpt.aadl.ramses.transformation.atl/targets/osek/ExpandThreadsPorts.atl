module ExpandThreadsPorts;
create OUT : AADLBA								-- Detailed model : org.osate.aadl2/model/addl2.ecore
from 		IN : AADLI,							-- Simplified model : org.osate.aadl2/model/instance.ecore
			AADL_RUNTIME: AADLBA,
			DATA_MODEL: AADLBA,
			PROGRAMMING_PROPERTIES: AADLBA,
			HOOKS: ATLHOOKS,						
			OSEK_RUNTIME: AADLBA;

uses Services;
uses AADLCopyHelpers;
uses AADLICopyHelpers;
uses Uninstanciate;
uses PropertiesTools;

rule PortConnection_Instance
{
	from
		cnxInst: AADLI!ConnectionInstance
		(
			false
		)
}

rule EventDataPort_Instance
{
	from
		fi: AADLI!FeatureInstance (fi.category=#dataPort
									and fi.eContainer().category=#thread
									and not fi.isPeriodicDelayedPort())
	to
		-- target data access must be called 'f' to be retreived with resolveTemp 
		f: AADLBA!DataAccess
		(
			name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
			kind <- #requires
		)
}
		

rule addNextValueSubprogramCall(seq : AADLBA!SubprogramCallSequence,
								impl : AADLBA!ComponentImplementation,
								implImg : AADLBA!ComponentImplementation,
								fi: AADLI!FeatureInstance)
{
	
}

rule addPutValueSubprogramCall(seq : AADLBA!SubprogramCallSequence,
								impl : AADLBA!ComponentImplementation,
								implImg : AADLBA!ComponentImplementation,
								fi: AADLI!FeatureInstance)
{
	
}

rule setSourcePortAccessorParameterConnections(port: AADLI!FeatureInstance, 
											   impl: AADLI!ComponentImplementation, 
											   implImg: AADLI!ComponentImplementation)
{
	do
	{
		
	}
}

rule setDestinationPortAccessorParameterConnections(port: AADLI!FeatureInstance, 
											   		impl: AADLI!ComponentImplementation, 
											   		implImg: AADLI!ComponentImplementation)
{
	do
	{
		
	}
}

rule addThreadsInternalConnections(fi: AADLI!FeatureInstance)
{
	using
	{
		c : AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLBA!ComponentImplementation = c.getSubcomponentImg().subcomponentType;
		impl: AADLBA!ComponentImplementation = c.getImpl();
	}
	do
	{
		if(c.category=#thread and c.featureInstance->last() = fi)
		{
			thisModule.mapSubprogramParameters(implImg, impl);
			implImg.ownedAccessConnection <- impl.ownedAccessConnection->collect(co|thisModule.AccessConnection(co, implImg));
		}
	}
}

unique lazy rule addTerminationCall
{
	from
		callSequenceImg : AADLBA!SubprogramCallSequence
	using
	{
		implImg: AADLBA!BehaviouredImplementation = callSequenceImg.eContainer();
		spg: AADLBA!SubprogramType = 'TerminateTask'.asSubprogramType('OSEK_RUNTIME');
	}
	to
		terminateTaskCall: AADLBA!SubprogramCall
		(
			name<-'call_TerminateTask',
			calledSubprogram <- spg
		)
	do
	{
		callSequenceImg.getOwnedCallSpecifications().add(terminateTaskCall);
		thisModule.addImportedUnit(thisModule.public(), 'OSEK_RUNTIME', 'OSEK_runtime');
	}
}

unique lazy rule addStatusType
{
	from
		implImg : AADLBA!BehavioredImplementation
	to
		status: AADLBA!DataSubcomponent
		(
			name <- 'osek_calls_status',
			dataSubcomponentType <- 'StatusType'.asSubprogramType('OSEK_RUNTIME')
		)
	do
	{
		implImg.ownedDataSubcomponent.add(status);
		status;
	}	
}
--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- nsURI AADLBA=http:///AADLBA

module DispatchCommonRefinementSteps;
create OUT : AADLBA 	from 		IN : AADLI,
									AADL_RUNTIME: AADLBA,
									DATA_MODEL: AADLBA,
									PROGRAMMING_PROPERTIES: AADLBA,
									HOOKS: ATLHOOKS,

									ARINC653_RUNTIME: AADLBA;


uses Services;
uses AADLCopyHelpers;
uses AADLICopyHelpers;
uses Uninstanciate;
uses PropertiesTools;


rule expandThreadDispatchProtocolInBA(inst: AADLBA!ComponentInstance,
									  spg: AADLBA!SuprogramImplementation,
									  actions: AADLBA!Actions) 
{
 do{
 	if(inst.isPeriodicThread())
 	{
 		thisModule.addPeriodicWaitCallAction(actions, spg);
 	}
 	if(inst.isSporadicThread())
 	{
 		thisModule.addSporadicWaitCallAction(actions, spg);
 	}
 	if(inst.isAperiodicThread())
 	{
 		thisModule.addAperiodicWaitCallAction(actions, spg);
 	}
 }
}

rule expandThreadDispatchProtocol(inst: AADLBA!NamedElement, implImg: AADLBA!ThreadImplementation) 
{
 do{
 	if(inst.isPeriodicThread())
 	{
 		for(seq in implImg.ownedSubprogramCallSequence)
 		{
 			thisModule.addPeriodicWaitCall(seq);
 		}
 	}
 	else if(inst.isSporadicThread())
 	{
 		for(seq in implImg.ownedSubprogramCallSequence)
 		{
 			thisModule.addSporadicWaitCall(seq);
 		}
 	}
 	else if(inst.isAperiodicThread())
 	{
 		for(seq in implImg.ownedSubprogramCallSequence)
 		{
 			thisModule.addAperiodicWaitCall(seq);
 		}
 	}
 }
}

--@TODO: actually, isPeriodicThread() is not working on ThreadImplementation
-- because Dispatch_Protocol property is generated on the thread subcomponent
-- instead of the thread type/implementation. This helper fix the problem
-- waiting to find a better solution
helper context AADLBA!NamedElement def : isPeriodic() : Boolean =
	self.isPeriodicThread() or 
		AADLBA!ThreadSubcomponent->allInstances()
			->select(s|s.threadSubcomponentType=self)
			->select(s|not s.isPeriodic())->isEmpty()
;

endpoint rule EndRule()
{
	do
	{
		for(thread in AADLBA!ThreadImplementation->allInstancesFrom('OUT')
				->select(e|
						e.type.ownedDataPort->isEmpty()
						and
						e.type.ownedEventDataPort->isEmpty()
						and
						e.type.ownedEventDataPort->isEmpty()
						--and
						--e.type.ownedDataAccess->isEmpty()
					))
		{
			if(thread.isPeriodic())
			{
				for(seq in thread.ownedSubprogramCallSequence)
 				{
					thread.debug('addPeriodicWaitCall()');
 					thisModule.addPeriodicWaitCall(seq);
 				}
			}
			else if(thread.isSporadicThread())
 			{
 				for(seq in thread.ownedSubprogramCallSequence)
 				{
 					thisModule.addSporadicWaitCall(seq);
 				}
 			}
 			else if(thread.isAperiodicThread())
 			{
 				for(seq in thread.ownedSubprogramCallSequence)
 				{
 					thisModule.addAperiodicWaitCall(seq);
 				}
 			}
		}
		'Executing Endpoint Rule'.debug('DEBUG');
	}
}

--endpoint rule SecondEndRule()
--{
--	do
--	{
--		'Executing Endpoint Rule'.debug('####');
--	}
--}
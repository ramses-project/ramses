--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore

module BehaviorAnnexCommonRefinementSteps;
create OUT : AADLBA 	from 		IN : AADLI,
									AADL_RUNTIME: AADLBA,
									DATA_MODEL: AADLBA,
									PROGRAMMING_PROPERTIES: AADLBA,
									HOOKS: ATLHOOKS,
									ARINC653_RUNTIME: AADLBA;


unique lazy rule copyBehaviorAnnexFromThread
{
	from
		c: AADLI!ComponentInstance,
		src_ba: AADLBA!BehaviorAnnex,
		currentStateAccess: AADLBA!DataAccess,
		stateType: AADLBA!DataAccess,
		subprogram: AADLBA!SubprogramImplementation
	to
		target_ba: AADLBA!BehaviorAnnex
		(
			name        <- src_ba.name,
			states      <- Sequence{sourceState,finalState},
			-- TODO implement mapBehaviorVariable
			variables   <- src_ba.variables->collect(e| thisModule.copyBehaviorVariable(e)),
			transitions <- Sequence{computationTransition},
			actions     <- Sequence{thisModule.mapBehaviorActionBlockFromThread(c, src_ba, currentStateAccess, stateType, subprogram)}
								->union(src_ba.transitions->collect(e|thisModule.copyBehaviorActionBlock(e.actionBlock, c)))
		),
		sourceState: AADLBA!BehaviorState
		(
			initial  <- true,
			final    <- false,
			complete <- false,
			name     <- 'BA_entrypoint_s'
		),
		finalState: AADLBA!BehaviorState
		(
			initial  <- false,
			final    <- true,
			complete <- false,
			name     <- 'BA_entrypoint_f'
		),
		computationTransition: AADLBA!BehaviorTransition
		(
			actionBlock       <- thisModule.mapBehaviorActionBlockFromThread(c, src_ba, currentStateAccess, stateType, subprogram),
			destinationState  <- finalState,
			sourceState       <- sourceState
		)
		
	do
	{
		target_ba;
	}
}

unique lazy rule mapBehaviorActionBlockFromThread
{
  from
	c: AADLI!ComponentInstance,
	src_ba: AADLBA!BehaviorAnnex,
	currentStateAccess: AADLBA!DataAccess,
	stateType: AADLBA!DataAccess,
	subprogram: AADLBA!SubprogramImplementation
	
  to
	target_actionBlock: AADLBA!BehaviorActionBlock
	(content<-target_actions),
	target_actions: AADLBA!BehaviorActionSequence
  do
  {
  	target_actions.actions.addAll(src_ba.transitions->collect(e| thisModule.mapBehaviorActionsFromThread(c, e, currentStateAccess, stateType, subprogram)));
  	if(thisModule.baNeedsElif(src_ba))
  	{
  		
  	}
  	
  	target_actionBlock;
  }
}

helper def: baNeedsElif(src_ba: AADLBA!BehaviorAnnex) : Boolean =
	src_ba.transitions->size()>2
;


unique lazy rule mapBehaviorActionsFromThread
{
  from
	c: AADLI!ComponentInstance,
	src_transition: AADLBA!BehaviorTransition,
	currentStateAccess: AADLBA!DataAccess,
	stateType: AADLBA!DataAccess,
	subprogram: AADLBA!SubprogramImplementation
  using
  {
	bab_content: AADLBA!BehaviorActions = OclUndefined;
	ba: AADLBA!BehaviorAnnex = c.subcomponent.classifier.ownedAnnexSubclause->any(e|e.name='behavior_specification');
  }
  to
	ifStatement: AADLBA!IfStatement
	(
		logicalValueExpression <- isStateSource,
		elif <- false,
		behaviorActions <- ifStatementActionSequence
	),
	ifStatementActionSequence: AADLBA!BehaviorActionSequence,
	isStateSource: AADLBA!ValueExpression
	(
		relations <- Sequence{comparisonRelation}	
	),
	comparisonRelation: AADLBA!Relation
	(
		relationalOperator<-#Equal,
		firstExpression<-comparisonFirstExpression,
		secondExpression<-comparisonSecondExpression
	),
	comparisonFirstExpression: AADLBA!SimpleExpression
	(
		terms <- Sequence{currentStateAccessTerm}
	),
	comparisonSecondExpression: AADLBA!SimpleExpression
	(
		terms <- Sequence{enumValueSourceStateTerm}
	),
	currentStateAccessTerm: AADLBA!Term
	(
		factors <- Sequence{currentStateAccessFactor}
	),
	enumValueSourceStateTerm: AADLBA!Term
	(
		factors <- Sequence{enumValueSourceStateFactor}
	),
	currentStateAccessFactor: AADLBA!Factor
	(
		firstValue <- Sequence{currentStateAccessHolder}
	),
	currentStateAccessHolder:AADLBA!DataAccessHolder
	(
		element <- currentStateAccess
	),
	enumValueSourceStateFactor: AADLBA!Factor
	(
		firstValue <- Sequence{sourceStateID}
	),
	sourceStateID: AADLBA!BehaviorEnumerationLiteral
	(
		enumLiteral<-enumSourceStringLiteral,
		component<-stateType
	),
	enumSourceStringLiteral: AADLBA!StringLiteral
	(
		value <- src_transition.sourceState.name
	),
	updateState: AADLBA!AssignmentAction
	(
		target <- updateStateAccessHolder,
		valueExpression <- updateValueExpression
	),
	updateStateAccessHolder:AADLBA!DataAccessHolder
	(
		element <- currentStateAccess
	),
	updateValueExpression: AADLBA!ValueExpression
	(
		relations <- Sequence{updateRelation}	
	),
	updateRelation: AADLBA!Relation
	(
		firstExpression<-updateFirstExpression
	),
	updateFirstExpression: AADLBA!SimpleExpression
	(
		terms <- Sequence{enumValueTargetStateTerm}
	),
	enumValueTargetStateTerm: AADLBA!Term
	(
		factors <- Sequence{enumValueTargetStateFactor}
	),
	enumValueTargetStateFactor: AADLBA!Factor
	(
		firstValue <- Sequence{targetStateID}
	),
	targetStateID: AADLBA!BehaviorEnumerationLiteral
	(
		enumLiteral<-enumTargetStringLiteral,
		component<-stateType
	),
	enumTargetStringLiteral: AADLBA!StringLiteral
	(
		value <- src_transition.sourceState.name
	)
  do
  {
  	if(src_transition.sourceState.complete=true)
  	{
  		for(fi in c.featureInstance)
  		{
  			if(fi.category=#dataPort and (fi.direction.toString()='in' or fi.direction.toString()='inout'))
  			{
  				thisModule.addNextValueSubprogramCallAction(ifStatementActionSequence.actions, fi, subprogram);
  			}
  		}
  	}
  	bab_content <- thisModule.copyBehaviorActionBlock(src_transition.actionBlock,c).content;
  	if(bab_content.oclIsKindOf(AADLBA!BehaviorActionCollection))
	  	ifStatementActionSequence.actions.addAll(bab_content.actions);
  	else if (not bab_content.oclIsUndefined())
  		ifStatementActionSequence.actions.add(bab_content.debug(bab_content.getClass().toString()));
  	ifStatementActionSequence.actions.add(updateState);
  	
  	for(fi in c.featureInstance)
  	{
  		if(fi.category=#dataPort or fi.category=#eventDataPort or fi.category=#eventPort)
  		{
  			if(ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().isUsedInFreshClause(ba, fi.feature))
			{
				for(trans in ba.transitions)
				{
					ifStatementActionSequence.actions.add(thisModule.resolveTemp(fi, 'updateFreshness'));
				}
			}
  			else if(fi.isUsedInFresh())
  			{
  				for(trans in ba.transitions)
				{
					ifStatementActionSequence.actions.add(thisModule.resolveTemp(fi, 'updateFreshnessOutput'));
					ifStatementActionSequence.actions.add(thisModule.resolveTemp(fi, 'sendFreshnessOutput'));
				}
  			}
  		}
  	}
  	
	if(src_transition.destinationState.complete=true)
	{
		for(fi in c.featureInstance)
  		{
  			if(fi.category=#dataPort and (fi.direction.toString()='out' or fi.direction.toString()='inout'))
  			{
  				thisModule.addPutValueSubprogramCallAction(ifStatementActionSequence.actions, fi, subprogram);
  			}
  		}
		thisModule.expandThreadDispatchProtocolInBA(c, subprogram, ifStatementActionSequence.actions);
	}
	ifStatement;
  }
}

lazy rule copyEventPortHolder
{
	from
		src_EventPortHolder: AADLBA!EventPortHolder,
		c: AADLI!ComponentInstance
	to
		target_EventPortHolder: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveTemp(c.featureInstance->any(e|e.name=src_EventPortHolder.element.name), 'dataSubcomponent')	
		)
	do
	{
		target_EventPortHolder;
	}
}

lazy rule copyEventDataPortHolder
{
	from
		src_EventDataPortHolder:AADLBA!EventDataPortHolder,
		c: AADLI!ComponentInstance
	to
		target_EventDataPortHolder: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveTemp(c.featureInstance->any(e|e.name=src_EventDataPortHolder.element.name), 'dataSubcomponent')	
		)
	do
	{
		target_EventDataPortHolder;
	}
}

helper def: copyDataPortHolder(src_DataPortHolder:AADLBA!DataPortHolder, c: AADLI!ComponentInstance) : AADLBA!ValueVariable =
	let f: AADLI!FeatureInstance = c.featureInstance->any(e|e.name=src_DataPortHolder.element.name) in 
	if (f.isUsedInFresh()) then
		thisModule.copyDataPortHolder_withFresh(src_DataPortHolder, c)
	else
		thisModule.copyDataPortHolder_withoutFresh(src_DataPortHolder, c)
	endif
;

lazy rule copyDataPortHolder_withFresh
{
	from
		src_DataPortHolder:AADLBA!DataPortHolder,
		c: AADLI!ComponentInstance
	to
		target_DataPortHolder: AADLBA!DataComponentReference
		(
			data <- Sequence{dataSubcomponentHolder,functionalPartHolder}
			
				
		),
		dataSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveTemp(c.featureInstance->any(e|e.name=src_DataPortHolder.element.name), 'dataSubcomponent')
		),
		functionalPartHolder: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveTemp(c.featureInstance->any(e|e.name=src_DataPortHolder.element.name), 'struct_functional_data_subcomponent')
		)
	do
	{
		target_DataPortHolder;
	}
}

lazy rule copyDataPortHolder_withoutFresh
{
	from
		src_DataPortHolder:AADLBA!DataPortHolder,
		c: AADLI!ComponentInstance
	to
		target_DataPortHolder: AADLBA!DataSubcomponentHolder
		(
			element<-thisModule.resolveTemp(c.featureInstance->any(e|e.name=src_DataPortHolder.element.name), 'dataSubcomponent')	
		)
	do
	{
		target_DataPortHolder;
	}
}

lazy rule copyDataAccessHolder
{
	from
		src_DataAccessHolder:AADLBA!DataAccessHolder,
		c: AADLI!ComponentInstance
	to
		target_DataAccessHolder: AADLBA!DataAccessHolder
		(
			element<-thisModule.resolveTemp(c.featureInstance->any(e|e.name=src_DataAccessHolder.element.name), 'f_entrypoint')	
		)
	do
	{
		target_DataAccessHolder;
	}
}

lazy rule copyPortFreshValue
{
	from
		src_PortFreshValue: AADLBA!PortFreshValue,
		c: AADLI!ComponentInstance
	using
	{
		portImgSubcomponent: AADLBA!DataSubcomponent = thisModule.resolveTemp(
							c.featureInstance->any(e|e.name = src_PortFreshValue.element.name), 'dataSubcomponent'
						);
		portImgFresh_prev: AADLBA!DataAccess = thisModule.resolveTemp(
							c.featureInstance->any(e|e.name = src_PortFreshValue.element.name), 'fresh_previous_access'
						);
		struct_freshness_data_subcomponent: AADLBA!DataSubcomponent = thisModule.resolveTemp(
							c.featureInstance->any(e|e.name = src_PortFreshValue.element.name), 'struct_freshness_data_subcomponent'
						);
	}
	to
		isFresh: AADLBA!ValueExpression
		(
			relations <- Sequence{comparisonRelation}
		),
		comparisonRelation: AADLBA!Relation
		(
			relationalOperator<-#NotEqual,
			firstExpression<-comparisonFirstExpression,
			secondExpression<-comparisonSecondExpression
		),
		comparisonFirstExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{currentFreshnessTerm}
		),
		comparisonSecondExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{previousFreshnessTerm}
		),
		currentFreshnessTerm: AADLBA!Term
		(
			factors <- Sequence{currentFreshnessFactor}
		),
		previousFreshnessTerm: AADLBA!Term
		(
			factors <- Sequence{previousFreshnessFactor}
		),
		currentFreshnessFactor: AADLBA!Factor
		(
			firstValue <- Sequence{portImgFreshPrevComponentReference}
		),
		portImgSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- portImgSubcomponent
		),
		previousFreshnessFactor: AADLBA!Factor
		(
			firstValue <- Sequence{portImgFreshPrevAccessHolder}
		),
		portImgFreshPrevComponentReference: AADLBA!DataComponentReference
		(
			data <- Sequence{portImgSubcomponentHolder, portImgFreshPrevSubcomponentHolder}
		),
		portImgFreshPrevAccessHolder: AADLBA!DataAccessHolder
		(
			element <- portImgFresh_prev
		),
		portImgFreshPrevSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- struct_freshness_data_subcomponent
		)
	do
	{
		isFresh;
	}
}

helper context AADLI!FeatureInstance def: isDirectlyUsedInFresh() : Boolean =
	let ba: AADLBA!BehaviorAnnex = self.eContainer().subcomponent.classifier.ownedAnnexSubclause->any(e|e.name='behavior_specification') in 
	if(not ba.oclIsUndefined()) then
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().isUsedInFreshClause
		(ba,
		self.feature)
	else
		false
	endif
;

helper context AADLI!FeatureInstance def: isUsedInFresh() : Boolean =
	--if(self.direction=#out or self.direction=#inOut) then
		self.isDirectlyUsedInFresh()
		or 
		not self.srcConnectionInstance->any(e|e.source.isDirectlyUsedInFresh()).oclIsUndefined()
	--else
	--	self.isUsedInFreshClause(ba)
		or
		not self.dstConnectionInstance->any(e|e.destination.isDirectlyUsedInFresh()).oclIsUndefined()
		or
		not self.srcConnectionInstance->any(e|e.destination.isDirectlyUsedInFresh()).oclIsUndefined()
		or
		not self.dstConnectionInstance->any(e|e.source.isDirectlyUsedInFresh()).oclIsUndefined()
	--endif
;

helper context AADLI!FeatureInstance def: getDirectlyUsedInFresh() : AADLI!FeatureInstance =
	if(self.isDirectlyUsedInFresh()) then
		self
	else
		if(not self.srcConnectionInstance->any(e|e.source.isDirectlyUsedInFresh()).oclIsUndefined()) then
			self.srcConnectionInstance->any(e|e.source.isDirectlyUsedInFresh()).source
		else
			if(not self.dstConnectionInstance->any(e|e.destination.isDirectlyUsedInFresh()).oclIsUndefined()) then
				self.dstConnectionInstance->any(e|e.destination.isDirectlyUsedInFresh()).destination
			else
				if(not self.srcConnectionInstance->any(e|e.destination.isDirectlyUsedInFresh()).oclIsUndefined()) then
					self.srcConnectionInstance->any(e|e.destination.isDirectlyUsedInFresh()).destination
				else
					if(not self.dstConnectionInstance->any(e|e.source.isDirectlyUsedInFresh()).oclIsUndefined()) then
						self.dstConnectionInstance->any(e|e.source.isDirectlyUsedInFresh()).source
					else
						OclUndefined
					endif
				endif
			endif
		endif
	endif
;
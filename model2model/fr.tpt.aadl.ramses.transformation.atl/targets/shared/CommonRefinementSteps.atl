--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore

module CommonRefinementSteps;
create OUT : AADLBA 	from 		IN : AADLI,
									AADL_RUNTIME: AADLBA,
									DATA_MODEL: AADLBA,
									PROGRAMMING_PROPERTIES: AADLBA,
									HOOKS: ATLHOOKS,

									POK_RUNTIME: AADLBA;


-------------------------------------------------------------------------------------------
----	TO BE SUPERIMPOSED

-- addNextValueSubprogramCall
-- addPutValueSubprogramCall
-- threadImplementationPostTreatment(implImg: AADLBA!ThreadImplementation)

rule threadImplementationPostTreatment(implImg: AADLBA!ThreadImplementation){
	
}

helper def: freshness_suffix : String = '_freshness_t';
helper def: impl_suffix : String = '.impl';
helper context AADLI!FeatureInstance def: getFreshnessType() : String =
	self.name+thisModule.freshness_suffix
;
-------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------
----	ADDED MATCHED RULES
-------------------------------------------------------------------------------------------

helper def: assignPortVariableType(fi: AADLI!FeatureInstance, fresh_data_impl_wrapper: AADLBA!DataSubcomponentType): AADLBA!DataSubcomponentType =
	if(fi.isUsedInFresh()) then
 		fresh_data_impl_wrapper
	else 		
		fi.feature.dataFeatureClassifier
	endif
;

helper context AADLI!FeatureInstance def: getBehaviorAnnex():  AADLBA!BehaviorAnnex = 
	self.eContainer().subcomponent.classifier.ownedAnnexSubclause->any(e| e.oclIsTypeOf(AADLBA!BehaviorAnnex))
;

helper context AADLBA!Classifier def: needsToMapBehaviorAnnex(): Boolean =
	not self.ownedAnnexSubclause->any(e| e.oclIsTypeOf(AADLBA!BehaviorAnnex)).oclIsUndefined()
	and
	self.getPropertyAssociation('Source_Name').oclIsUndefined()
	and
	self.getPropertyAssociation('Source_Text').oclIsUndefined()
;

lazy rule createFreshnessImplIdentifier
{
	from
		fresh_data_type_wrapper:AADLBA!DataType
	to
		result: String
	do
	{
		result <- fresh_data_type_wrapper.name+thisModule.impl_suffix;
		
		result;
	}
}

rule DataPort_Instance_with_BA
{
	from
		fi: AADLI!FeatureInstance (fi.category=#dataPort
									and fi.eContainer().category=#thread
									and not fi.isPeriodicDelayedPort()
									and fi.eContainer().subcomponent.classifier.needsToMapBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		-- local variable that will be initialized in the "do" section.
		implImg: AADLI!ComponentImplementation = OclUndefined;
		ba: AADLBA!BehaviorAnnex = fi.getBehaviorAnnex();
	}
	to
		-- creation of a data access feature, to be added to the target thread component, 
		-- this data access represents an access to the global variable representing the
		-- communication 'port variable'.
		
		-- target data access must be called 'f' to be retreived with resolveTemp
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			),
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-fi.feature.name+'_MsgAddr'
		),
		actualParam: AADLBA!Parameter,
		
		-- target data access must be called 'f_entrypoint' to be retreived with resolveTemp
		f_entrypoint: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			),
		fresh_data_previous: AADLBA!DataSubcomponent
			(
				name<-fi.name+'_freshness_previous',
				dataSubcomponentType<-'Integer_16'.asClassifier('BASE_TYPES'),
				ownedPropertyAssociation <- Sequence{
					thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL', FRESH_INIT)
				}
			),
		FRESH_INIT: AADLBA!ListValue
		(
			ownedListElement <- Sequence{thisModule.CreateStringLiteralPropertyExpression('0')}
		),
		fresh_previous_access: AADLBA!DataAccess
		(
			name<-fi.name+'_freshness_previous_access',
			dataFeatureClassifier<-'Integer_16'.asClassifier('BASE_TYPES'),
			kind <- #requires
		),
		fresh_data_type_wrapper:AADLBA!DataType
		(
			name<-fi.getFreshnessType(),
			ownedPropertyAssociation <- Sequence
			{
				thisModule.CreatePropertyAssociation('Data_Representation', 'DATA_MODEL',
					'Struct'.asEnumeration('DATA_MODEL').asNamedValue())
			}
		),
		fresh_data_impl_wrapper:AADLBA!DataImplementation
		(
			name<-thisModule.createFreshnessImplIdentifier(),
			ownedDataSubcomponent<-Sequence{struct_functional_data_subcomponent,struct_freshness_data_subcomponent}
		),
		struct_freshness_data_subcomponent: AADLBA!DataSubcomponent
		(
			name<-'fresh_ba',
			dataSubcomponentType <- 'Integer_16'.asClassifier('BASE_TYPES')
		),
		struct_functional_data_subcomponent: AADLBA!DataSubcomponent
		(
			name <- 'value',
			dataSubcomponentType <- fi.feature.dataFeatureClassifier
		),
		updateFreshness: AADLBA!AssignmentAction
		(
			target <- updatePreviousFreshAccessHolder,
			valueExpression <- updateValueExpression
		),
		updatePreviousFreshAccessHolder:AADLBA!DataAccessHolder
		(
			element <- fresh_previous_access
		),
		updateValueExpression: AADLBA!ValueExpression
		(
			relations <- Sequence{updateRelation}	
		),
		updateRelation: AADLBA!Relation
		(
			firstExpression<-updateFirstExpression
		),
		updateFirstExpression: AADLBA!SimpleExpression
		(
			terms <- Sequence{updateFreshTerm}
		),
		updateFreshTerm: AADLBA!Term
		(
			factors <- Sequence{updateFreshFactor}
		),
		updateFreshFactor: AADLBA!Factor
		(
			firstValue <- Sequence{updateFreshCDR}
		),
		updateFreshCDR: AADLBA!DataComponentReference
		(
			data <- Sequence{dataSubcomponentHolder,dataFreshnessSubcomponentHolder}
		),
		dataSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- dataSubcomponent
		),
		dataFreshnessSubcomponentHolder: AADLBA!DataSubcomponentHolder
		(
			element <- struct_freshness_data_subcomponent
		),
		
		
		
		-------- Emitter freshness update
		sendFreshnessOutput: AADLBA!AssignmentAction
		(
			target <- sendFreshDataComponentReference,
			valueExpression <- sendValueExpressionOutput
		),
		sendFreshDataComponentReference: AADLBA!DataComponentReference
		(
			data<-Sequence{dataSubcomponentSend,dataSubcomponentStructSend}
		),
		dataSubcomponentSend: AADLBA!DataSubcomponentHolder
		(
			element<-dataSubcomponent
		),
		dataSubcomponentStructSend: AADLBA!DataSubcomponentHolder
		(
			element<-struct_freshness_data_subcomponent
		),
		sendValueExpressionOutput: AADLBA!ValueExpression
		(
			relations <- Sequence{sendRelationOutput}	
		),
		sendRelationOutput: AADLBA!Relation
		(
			firstExpression<-sendFirstExpressionOutput
		),
		sendFirstExpressionOutput: AADLBA!SimpleExpression
		(
			terms <- Sequence{sendFreshTermOutput}
		),
		sendFreshTermOutput: AADLBA!Term
		(
			factors <- Sequence{sendFreshFactorOutput}
		),
		sendFreshFactorOutput: AADLBA!Factor
		(
			firstValue <- Sequence{dataAccessHolderSend}
		),
		dataAccessHolderSend: AADLBA!DataSubcomponentHolder
		(
			element <- fresh_previous_access
		),
		
		
		
		updateFreshnessOutput: AADLBA!AssignmentAction
		(
			target <- updatePreviousFreshAccessHolderOutput,
			valueExpression <- updateValueExpressionOutput
		),
		updatePreviousFreshAccessHolderOutput:AADLBA!DataAccessHolder
		(
			element <- fresh_previous_access
		),
		updateValueExpressionOutput: AADLBA!ValueExpression
		(
			relations <- Sequence{updateRelationOutput}	
		),
		updateRelationOutput: AADLBA!Relation
		(
			firstExpression<-updateFirstExpressionOutput
		),
		updateFirstExpressionOutput: AADLBA!SimpleExpression
		(
			terms <- Sequence{updateFreshTermOutput, updateConstantTermOutput},
			binaryAddingOperators <- Sequence{#Plus}
		),
		updateFreshTermOutput: AADLBA!Term
		(
			factors <- Sequence{updateFreshFactorOutput}
		),
		updateFreshFactorOutput: AADLBA!Factor
		(
			firstValue <- Sequence{dataAccessHolderOutput}
		),
		dataAccessHolderOutput: AADLBA!DataSubcomponentHolder
		(
			element <- fresh_previous_access
		),
		updateConstantTermOutput: AADLBA!Term
		(
			factors <- Sequence{updateConstantFactorOutput}
		),
		updateConstantFactorOutput: AADLBA!Factor
		(
			firstValue <- Sequence{valueConstantOutput}
		),
		valueConstantOutput: AADLBA!BehaviorIntegerLiteral
		(
			value <- 1.longValue()
		)
		
		
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		f_entrypoint.dataFeatureClassifier <- f.dataFeatureClassifier;
		if(thisModule.public().ownedClassifier->any(e|e.name = fresh_data_type_wrapper.name).oclIsUndefined())
		{
			thisModule.public().ownedClassifier.add(fresh_data_type_wrapper);
			thisModule.public().ownedClassifier.add(fresh_data_impl_wrapper);
		}
		dataSubcomponent.dataSubcomponentType <- thisModule.assignPortVariableType(fi, fresh_data_impl_wrapper);
		actualParam.dataFeatureClassifier <- dataSubcomponent.dataSubcomponentType;
		thisModule.addImportedUnitFromInputModel(thisModule.public(), fi.feature);
	}
}


rule EventPort_Instance_with_BA
{
	from
		fi: AADLI!FeatureInstance (fi.category=#eventPort 
									and fi.eContainer().category = #thread
									and not fi.isPeriodicDelayedPort()
									and fi.eContainer().subcomponent.classifier.needsToMapBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- target data access must be called 'f' to be retreived with resolveTemp
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			),
		f_entrypoint: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		f_entrypoint.dataFeatureClassifier <- f.dataFeatureClassifier;
	}
}

rule EventDataPort_Instance_with_BA
{
	from
		fi: AADLI!FeatureInstance(fi.category=#eventDataPort 
								and fi.eContainer().category=#thread
								and not fi.isPeriodicDelayedPort()
								and fi.eContainer().subcomponent.classifier.needsToMapBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- target data access must be called 'f' to be retreived with resolveTemp 
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			),
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-fi.feature.name+'_MsgAddr',
			dataSubcomponentType<-fi.feature.dataFeatureClassifier
		),
		f_entrypoint: AADLBA!DataAccess
		(
			name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
			kind <- #requires
		),
		actualParam: AADLBA!Parameter
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		f_entrypoint.dataFeatureClassifier <- f.dataFeatureClassifier;
	}
}

rule DataAccess_Instance_with_BA
{
	from
		fi: AADLI!FeatureInstance (fi.category=#dataAccess
			 and fi.eContainer().category=#thread
			 and fi.eContainer().subcomponent.classifier.needsToMapBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined; 
		processImplImg: AADLI!ProcessImplementation = OclUndefined;
	}
	to
		f: AADLBA!DataAccess
			(
				name <- fi.name,
				kind <- #requires,
				dataFeatureClassifier <- fi.feature.dataFeatureClassifier,
				ownedPropertyAssociation <- fi.feature.mapOwnedPropertyAssociationList()
			),
		f_entrypoint: AADLBA!DataAccess
			(
				name <- fi.name,
				kind <- #requires,
				dataFeatureClassifier <- fi.feature.dataFeatureClassifier,
				ownedPropertyAssociation <- fi.feature.mapOwnedPropertyAssociationList()
			)
	do
	{
		if(c.category=#thread)
		{
			processImplImg <- c.eContainer().subcomponent.subcomponentType;
		}
		thisModule.addThreadsInternalConnections(fi);
		implImg <- thisModule.resolveTemp(c, 'sub').subcomponentType.debug('Retreived Component Implementation');
		f_entrypoint.dataFeatureClassifier <- f.dataFeatureClassifier;
		thisModule.addImportedUnitFromInputModel(thisModule.public(), fi.feature);
	}
}





-------------------------------------------------------------------------------------------
----	OVERRIDEN MATCHED RULES
-------------------------------------------------------------------------------------------

rule DataPort_Instance
{
	from
		fi: AADLI!FeatureInstance (fi.category=#dataPort
									and fi.eContainer().category=#thread
									and not fi.isPeriodicDelayedPort()
									and not fi.eContainer().subcomponent.classifier.needsToMapBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		-- local variable that will be initialized in the "do" section.
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- creation of a data access feature, to be added to the target thread component, 
		-- this data access represents an access to the global variable representing the
		-- communication 'port variable'.
		
		-- target data access must be called 'f' to be retreived with resolveTemp
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			),
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-fi.feature.name+'_MsgAddr',
			dataSubcomponentType<-fi.feature.dataFeatureClassifier
		),
		actualParam: AADLBA!Parameter
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		actualParam.dataFeatureClassifier <- dataSubcomponent.dataSubcomponentType;
	}
}


rule EventPort_Instance
{
	from
		fi: AADLI!FeatureInstance (fi.category=#eventPort 
									and fi.eContainer().category = #thread
									and not fi.isPeriodicDelayedPort()
									and not fi.eContainer().subcomponent.classifier.needsToMapBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- target data access must be called 'f' to be retreived with resolveTemp
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
	}
}

rule EventDataPort_Instance
{
	from
		fi: AADLI!FeatureInstance(fi.category=#eventDataPort 
								and fi.eContainer().category=#thread
								and not fi.isPeriodicDelayedPort()
								and not fi.eContainer().subcomponent.classifier.needsToMapBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- target data access must be called 'f' to be retreived with resolveTemp 
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			),
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-fi.feature.name+'_MsgAddr',
			dataSubcomponentType<-fi.feature.dataFeatureClassifier
		),
		actualParam: AADLBA!Parameter
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		actualParam.dataFeatureClassifier <- dataSubcomponent.dataSubcomponentType;
	}
}

rule DataAccess_Instance
{
	from
		fi: AADLI!FeatureInstance (fi.category=#dataAccess
			 and fi.eContainer().category=#thread
			 and not fi.eContainer().subcomponent.classifier.needsToMapBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined; 
		processImplImg: AADLI!ProcessImplementation = OclUndefined;
	}
	to
		f: AADLBA!DataAccess
		(
			name <- fi.name,
			kind <- #requires,
			dataFeatureClassifier <- fi.feature.dataFeatureClassifier,
			ownedPropertyAssociation <- fi.feature.mapOwnedPropertyAssociationList()
		)
	do
	{
		if(c.category=#thread)
		{
			processImplImg <- c.eContainer().subcomponent.subcomponentType;
		}
		thisModule.addImportedUnitFromInputModel(thisModule.public(), fi.feature);
		thisModule.addThreadsInternalConnections(fi);
		implImg <- thisModule.resolveTemp(c, 'sub').subcomponentType.debug('Retreived Component Implementation');
	}
}


unique lazy rule ThreadType {
 from 
 	c : AADLI!ComponentInstance,
 	type : AADLI!ThreadType
 to 
 	typeImg : AADLBA!ThreadType (
 	 name <- c.uniqueName().debug('thread type'),
	 ownedDataAccess <- c.featureInstance->
										select(e| (e.category=#dataPort or e.category=#eventDataPort
													or e.category=#eventPort or e.category=#dataAccess) )->
										collect(f| f.getFeatureImg())
 	)
}

helper def: ThreadImplementation(c : AADLI!ComponentInstance, typeImg : AADLBA!ThreadType, impl : AADLI!ThreadImplementation) : AADLBA!ThreadImplementation =
	if(impl.needsToMapBehaviorAnnex()) then
		thisModule.ThreadImplementationWithBA(c, typeImg, impl)
	else
		thisModule.ThreadImplementationWithoutBA(c, typeImg, impl)
	endif
;

lazy rule duplicateSubprogramSubcomponent {
	from
		e: AADLI!ComponentInstance
	to
		copy: AADLBA!SubprogramSubcomponent
		(
			name <- e.subcomponent.name,
			subprogramSubcomponentType <- e.subcomponent.subprogramSubcomponentType
		)
}

lazy rule duplicateDataSubcomponent {
	from
		e: AADLI!ComponentInstance
	to
		copy: AADLBA!DataSubcomponent
		(
			name <- e.subcomponent.name,
			dataSubcomponentType <- e.subcomponent.dataSubcomponentType
		)
		
}

lazy rule ThreadImplementationWithBA {
 from 
    c : AADLI!ComponentInstance,
 	typeImg : AADLBA!ThreadType,
 	impl : AADLI!ThreadImplementation
 using
 {
 	implBA: AADLBA!BehaviorAnnex = impl.ownedAnnexSubclause->any(e| e.oclIsTypeOf(AADLBA!BehaviorAnnex));
	fresh_data_previous: AADLBA!DataSubcomponent = OclUndefined;
	fresh_data_type_wrapper: AADLBA!DataType = OclUndefined;
	fresh_data_impl_wrapper: AADLBA!DataType = OclUndefined;
	fresh_previous_access: AADLBA!DataAccess = OclUndefined;
	dataSubcomponent: AADLBA!DataSubcomponent = OclUndefined;
 }
 to 
 	implImg : AADLBA!ThreadImplementation (
 		name <- c.uniqueName().concat('.impl'),
		ownedRealization 				<- thisModule.Realization(typeImg, implImg),
		ownedSubprogramSubcomponent 	<- impl.getSubcomponentsInstances('subprogram')->collect(e|thisModule.duplicateSubprogramSubcomponent(e)),
		ownedDataSubcomponent 			<- impl.getSubcomponentsInstances('data')->collect(e|thisModule.duplicateDataSubcomponent(e)),
		ownedSubprogramCallSequence     <- thisModule.copyCallSequence(c,impl,implImg),
		ownedAccessConnection           <- Sequence{accessConnection_CURRENT_STATE}
	),
	entryPointImg: AADLBA!SubprogramType
	(
		name <- c.uniqueName().concat('_entrypoint'),
		ownedDataAccess <- Sequence{currentStateAccess}
	),
	entryPointImplImg: AADLBA!SubprogramImplementation
	(
		name <- entryPointImg.name.concat('.impl'),
		ownedRealization<-thisModule.Realization(entryPointImg, entryPointImplImg)
	),
	callEntryPoint: AADLBA!SubprogramCall
	(
		name<-thisModule.callPrefix()+entryPointImg.name,
		calledSubprogram<-entryPointImplImg
	),
	stateType: AADLBA!DataType
	(
		name <- c.uniqueName().concat('_currentState'),
		ownedPropertyAssociation <- Sequence {
												
												thisModule.CreatePropertyAssociation
												(
												 	'Data_Representation',
													'DATA_MODEL',
													'Enum'.asEnumeration('DATA_MODEL').asNamedValue()
												),
												thisModule.CreatePropertyAssociation
												(
												 	'Enumerators',
													'DATA_MODEL',
													 thisModule.CreateListValueFromListOfString(implBA.states->collect(e|e.name))
												)
									}
	),
	currentState: AADLBA!DataSubcomponent
	(
		name <- 'Parent_BA_currentState',
		dataSubcomponentType <- stateType
	),
	currentStateAccess: AADLBA!DataAccess
	(
		name <- 'Parent_BA_currentState_Access',
		dataFeatureClassifier <- stateType,
		kind <- #requires
	),
	
	
	-- connect currentState feature of entryPointImg to the data subcomponent of the implImg that
	-- represents the state of implImg
	connectedAccess_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentStateAccess,
		context<-callEntryPoint
	),
	connectedSubcomponent_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentState
	),
	accessConnection_CURRENT_STATE: AADLBA!AccessConnection
	(
		name<-'CNX_CURRENT_STATE_BA',
		source<-connectedAccess_CURRENT_STATE,
		destination<-connectedSubcomponent_CURRENT_STATE,
		accessCategory <- #data
	)
 do
 {
 	-- set ownership
	-- add current state to thread implementation implImg
 	implImg.ownedDataSubcomponent->add(currentState);
 	-- add data type to package
	thisModule.public().getOwnedClassifiers()->add(stateType);
 	
 	-- add initial value to statType; must be set after adding stateType to the package
 	-- otherwise the qualified name is incorrect.
 	stateType.ownedPropertyAssociation.add(thisModule.CreatePropertyAssociation
												(
												 	'Initial_Value',
													'DATA_MODEL',
													 thisModule.CreateListValueFromString(stateType.get_C_Identifier().concat('_')+thisModule.getBAInitialStateIdentifier(implBA))
												));
 	
 	-- add subprogram type to package
	thisModule.public().getOwnedClassifiers()->add(entryPointImg);
 	thisModule.public().getOwnedClassifiers()->add(entryPointImplImg);
 	
 	if(implImg.ownedSubprogramCallSequence->isEmpty())
 		implImg.ownedSubprogramCallSequence<-thisModule.createSubprogramCallSequence(implImg);
	
 	-- add call to entryPointImg
	implImg.ownedSubprogramCallSequence->first().getOwnedCallSpecifications().add(callEntryPoint);

 	-- add data accesses created from c.featureInstance
	entryPointImg.ownedDataAccess->addAll(c.featureInstance->collect(e|e.retreiveEntrypointFeature()));
	
 	for(f in c.featureInstance)
	{
 		dataSubcomponent <- thisModule.resolveTemp(f, 'dataSubcomponent');
 		if(not dataSubcomponent.oclIsUndefined())
 			entryPointImplImg.ownedDataSubcomponent.add(dataSubcomponent);
 	
 		if(f.direction=#out and f.category=#eventPort)
 		{
 			thisModule.addPutValueSubprogramCall(implImg.ownedSubprogramCallSequence->first(), impl, implImg, f);
 		}
 		
 		-- connect each feature of implImg to each copy of this feature in entryPointImg
		thisModule.addDataAccessConnection(	implImg,
							 		   	   	f.name.concat('_to_EntryPoint'),
							 			   	f.retreiveEntrypointFeature(),
							 			   	callEntryPoint,
							 				f.getFeatureImg());
 		if(f.feature.oclIsKindOf(AADLBA!Port))
		{
 			if(f.isUsedInFresh())
 			{
 				fresh_data_previous <- thisModule.resolveTemp(f, 'fresh_data_previous');
				fresh_data_type_wrapper <- thisModule.resolveTemp(f, 'fresh_data_type_wrapper');
				fresh_data_impl_wrapper <- thisModule.resolveTemp(f, 'fresh_data_impl_wrapper');
				fresh_previous_access <- thisModule.resolveTemp(f, 'fresh_previous_access');
				implImg.ownedDataSubcomponent.add(fresh_data_previous);
				-- add fresh_current_access to subprogram
				entryPointImg.ownedDataAccess.add(fresh_previous_access);
				-- add connection to call
				thisModule.addDataAccessConnection(implImg,
							 			f.name+'_freshness_cnx',
							 			fresh_previous_access,
							 			callEntryPoint,
							 			fresh_data_previous);
 			}
		}
	}
 	
 	-- add BA in entryPointImg
	entryPointImplImg.ownedAnnexSubclause->add(thisModule.copyBehaviorAnnexFromThread(c, 
															implBA, 
															currentStateAccess,
															stateType,
															entryPointImplImg));
 	thisModule.threadImplementationPostTreatment(entryPointImplImg);
 }
}

helper def: getBAInitialStateIdentifier(implBA: AADLBA!BehaviorAnnex) : String =
	implBA.states->any(s|s.initial=true).name
;

helper context AADLI!FeatureInstance def : retreiveIdAccess(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataAccess =
	self.getFeatureImg()
;

helper context AADLI!FeatureInstance def : retreiveEntrypointFeature() : AADLBA!DataAccess =
	thisModule.resolveTemp(self, 'f_entrypoint')
;

unique lazy rule ThreadImplementationWithoutBA {
 from 
    c : AADLI!ComponentInstance,
 	typeImg : AADLBA!ThreadType,
 	impl : AADLI!ThreadImplementation
 using
 {
 	dataSubcomponent: AADLBA!DataSubcomponent = OclUndefined;
 }
 to 
 	implImg : AADLBA!ThreadImplementation (
 		name <- c.uniqueName().concat('.impl'),
		ownedRealization 				<- thisModule.Realization(typeImg, implImg),
		ownedSubprogramSubcomponent 	<- impl.getSubcomponentsInstances('subprogram'),
		ownedDataSubcomponent 			<- impl.getSubcomponentsInstances('data'),
		ownedSubprogramCallSequence     <- thisModule.copyCallSequence(c,impl,implImg)
	)
 do
 {
 	if(implImg.ownedSubprogramCallSequence->isEmpty())
 		implImg.ownedSubprogramCallSequence<-thisModule.createSubprogramCallSequence(implImg);
  	for(f in c.featureInstance)
	{
  		dataSubcomponent <- thisModule.resolveTemp(f, 'dataSubcomponent');
  		if(not dataSubcomponent.oclIsUndefined())
	 		implImg.ownedDataSubcomponent.add(dataSubcomponent);
 		if(f.direction=#out and f.category=#eventPort)
 		{
 			thisModule.addPutValueSubprogramCall(implImg.ownedSubprogramCallSequence->first(), impl, implImg, f);
 		}
	}
  	thisModule.threadImplementationPostTreatment(implImg);
 }
}

unique lazy rule createSubprogramCallSequence {
 from
 	implImg: AADLBA!ThreadImplementation
 to
	seq: AADLBA!SubprogramCallSequence(
			name <- 'callSeq_Default'
		)
}

unique lazy rule mapOrphanOutputEventPorts
{
	from
		fi: AADLI!FeatureInstance,
		implImg : AADLBA!ThreadImplementation
	using
	{
		seq: AADLBA!SubprogramCallSequence = OclUndefined;
	}
	to 
		call: AADLBA!SubprogramCall
	do
	{
		call;
	}
}

unique lazy rule mapComputeEntrypoint
{
	from
		implImg : AABDBA!ComponentImplementation,
		c : AADLI!ComponentInstance,
		impl : AADLI!ComponentImplementation
	using
	{
		callImg : AADLBA!SubprogramCall = OclUndefined;
		fi: AADLI!FeatureInstance = OclUndefined;
		calledSubprogram: AADLBA!SubprogramClassifier = OclUndefined;
		referencedSubprogram: AADLI!Subprogram = impl.callSequenceFromComputeEntryPoint();
	}
	to
		seq: AADLBA!SubprogramCallSequence(
			name <- 'callSeq_'+referencedSubprogram.name
		),
		call : AADLBA!SubprogramCall (
			name <- 'call_'+referencedSubprogram.name,
			calledSubprogram <- referencedSubprogram
		)
	do
	{
		
		if(not impl.type.ownedEventPort->first().getModalPropertyValue('Compute_Entrypoint').oclIsUndefined())
		{
			fi<-c.featureInstance->any(e|e.name = impl.type.ownedEventPort->first().name);
			thisModule.addNextValueSubprogramCall(seq, impl, implImg, fi);
		}
		seq.ownedCallSpecification->add(call);
		if (referencedSubprogram.oclIsKindOf(AADLI!SubprogramType))
			call.calledSubprogram <- thisModule.Type(OclUndefined,referencedSubprogram);
		else if(referencedSubprogram.oclIsKindOf(AADLI!SubprogramImplementation))
			call.calledSubprogram <- thisModule.Implementation(OclUndefined,referencedSubprogram, thisModule.Type(OclUndefined,referencedSubprogram.getOwnedRealization().implemented));
		seq;
	}
}

rule mapInputParameterConnection(s2 : AADLBA!SubprogramCallSequence,
								 impl : AADLI!ComponentImplementation,
								 implImg : AABDBA!ComponentImplementation,
								 fi: AADLI!FeatureInstance,
								 call : AADLI!SubprogramCall,
								 calledSubprogram: AADLBA!SubprogramClassifier,
								 c : AADLI!ComponentInstance)
{
	do
	{
		for(paramCnx in impl.ownedParameterConnection)
		{
			if(paramCnx.destination.getContext() = call 
					and calledSubprogram.ownedParameter.contains(paramCnx.destination.connectionEnd)
					and paramCnx.destination.connectionEnd.isInputFeature())
			{
				fi<-c.featureInstance->any(e|e.name = paramCnx.source.connectionEnd.name);
				if(not fi.oclIsUndefined())
				{
					if(fi.feature.oclIsKindOf(AADLI!Port))
					{
						thisModule.addNextValueSubprogramCall(s2, impl, implImg, fi);
					}
			 	}
			}
		}
	}	
}


rule mapOutputParameterConnection(s2 : AADLBA!SubprogramCallSequence,
								 impl : AADLI!ComponentImplementation,
								 implImg : AABDBA!ComponentImplementation,
								 fi: AADLI!FeatureInstance,
								 call : AADLI!SubprogramCall,
								 calledSubprogram: AADLBA!SubprogramClassifier,
								 c : AADLI!ComponentInstance)
{
	do
	{
		for(paramCnx in impl.ownedParameterConnection)
		{
			if(paramCnx.source.getContext() = call 
					and calledSubprogram.ownedParameter.contains(paramCnx.source.connectionEnd)
					and paramCnx.source.connectionEnd.isOutputFeature())
			{
				fi<-c.featureInstance->any(e|e.name = paramCnx.destination.connectionEnd.name);
				if(not fi.oclIsUndefined())
				{
					if(fi.feature.oclIsKindOf(AADLI!Port))
					{
						thisModule.addPutValueSubprogramCall(s2, impl, implImg, fi);
					}
				}
			}
		}
	}
}



unique lazy rule mapCallSequence
{
	from
		implImg : AABDBA!ComponentImplementation,
		c : AADLI!ComponentInstance,
		impl : AADLI!ComponentImplementation
	using
	{
		callImg : AADLBA!SubprogramCall = OclUndefined;
		fi: AADLI!FeatureInstance = OclUndefined;
		calledSubprogram: AADLBA!SubprogramClassifier = OclUndefined;
	}
	to
		s2 : AADLBA!SubprogramCallSequence (name <- impl.callSequenceFromImpl().name)
	do
	{
		impl.callSequenceFromImpl().debug('  copy call sequence');
		
		for(call in impl.callSequenceFromImpl().ownedCallSpecification)
		{
			callImg <- thisModule.SubprogramCall(c, call, impl, implImg, call);
			if(call.calledSubprogram.oclIsKindOf(AADLBA!SubprogramAccess))
				calledSubprogram<-call.calledSubprogram.subprogramFeatureClassifier;
			else
				calledSubprogram<-call.calledSubprogram;
			-- if an in parameter is connected to an input port
			-- we must call next_value here
			
			thisModule.mapInputParameterConnection(s2, impl, implImg, fi, call, calledSubprogram, c);
			
			s2.getOwnedCallSpecifications().add(callImg);
			-- if an ou parameter is connected to an in data port or event data port
			-- we must call put_value here
			
			thisModule.mapOutputParameterConnection(s2, impl, implImg, fi, call, calledSubprogram, c);
			
			callImg.debug('  copy subprogram call');
		}
		s2;
	}
}



rule SubprogramCall (c: AADLI!ComponentInstance,
					 s : AADLI!SubprogramCall, 
					 impl : AADLI!ComponentImplementation, 
					 implImg : AADLBA!ComponentImplementation) {
	using
	{
		constantValue: Sequence(AADLBA!StringLiteral) = OclUndefined;
		constantValueParameters: Sequence(AADLBA!StringLiteral) = OclUndefined;
		parameterConstantValue: String = '';
	}
	to
		s2 : AADLBA!SubprogramCall (
			name <- s.name
		)
	do
	{
		if(not s.calledSubprogram.getPropertyAssociation('Source_Name').oclIsUndefined()
					and not s.calledSubprogram.getPropertyAssociation('Source_Text').oclIsUndefined())
		{
			s2.calledSubprogram <- s.calledSubprogram;
			thisModule.addImportedUnitFromInputModel(thisModule.public(), s.calledSubprogram);
		}
		else
		{
			if (s.calledSubprogram.oclIsKindOf(AADLI!SubprogramType))
				s2.calledSubprogram <- thisModule.Type(OclUndefined,s.calledSubprogram);
			else if(s.calledSubprogram.oclIsKindOf(AADLI!SubprogramImplementation))
				s2.calledSubprogram <- thisModule.Implementation(OclUndefined,s.calledSubprogram, thisModule.Type(OclUndefined,s.calledSubprogram.getOwnedRealization().implemented));
			else if (s.calledSubprogram.oclIsKindOf(AADLI!SubprogramAccess))
				if(s.calledSubprogram.subprogramFeatureClassifier.oclIsKindOf(AADLI!SubprogramType))
					s2.calledSubprogram <-  thisModule.Type(OclUndefined,s.calledSubprogram.subprogramFeatureClassifier);
				else if (s.calledSubprogram.subprogramFeatureClassifier.oclIsKindOf(AADLI!SubprogramType))
					s2.calledSubprogram <-  thisModule.Implementation(OclUndefined,s.calledSubprogram.subprogramFeatureClassifier, thisModule.Type(OclUndefined,s.calledSubprogram.subprogramFeatureClassifier.getOwnedRealization().implemented));
		
			if(not s.calledSubprogram.getModalPropertyValue('Constant_Value_Parameters').oclIsUndefined()
				and not s.calledSubprogram.getModalPropertyValue('Constant_Value').oclIsUndefined())
			{
				constantValue <- s.calledSubprogram.getModalPropertyValue('Constant_Value').ownedValue;
				constantValueParameters <- s.calledSubprogram.getModalPropertyValue('Constant_Value_Parameters').ownedValue;
				-- WARNING : We use both s (from input model) and s2 (from output model)
				-- in this code
				-- It is ok if: 
					-- 1) parameter constant values ('Constant_Value') and 
					-- parameters ('Constant_Value_Parameters') are identified 
					-- by strings in the property set
					-- 2) properties are copied from source to target model
					-- 3) parameters have the same name in the source and target model
				for(p in s2.calledSubprogram.getSubprogramParameters())
				{
					for(constantParamString in constantValueParameters.ownedListElement)
					{
						if(constantParamString.value=p.name)
						{
							parameterConstantValue <- constantValue.ownedListElement->at(constantValueParameters.ownedListElement->indexOf(constantParamString)).value;
							thisModule.mapConstantParameter(p, parameterConstantValue, s2, implImg);
						}
					}	
				}
			} else
			{
				if(not s2.calledSubprogram.getModalPropertyValue('Constant_Value_Parameters').oclIsUndefined()
					and not s2.calledSubprogram.getModalPropertyValue('Constant_Value').oclIsUndefined())
				{
					constantValue <- s2.calledSubprogram.getModalPropertyValue('Constant_Value').ownedValue;
					constantValueParameters <- s2.calledSubprogram.getModalPropertyValue('Constant_Value_Parameters').ownedValue;
					for(p in s2.calledSubprogram.getSubprogramParameters())
					{
						for(constantParamString in constantValueParameters.ownedListElement)
						{
							if(constantParamString.value=p.name)
							{
								parameterConstantValue <- constantValue.ownedListElement->at(constantValueParameters.ownedListElement->indexOf(constantParamString)).value;
								thisModule.mapConstantParameter(p, parameterConstantValue, s2, implImg);
							}
						}	
					}
				}
			}
		}
		s2;
	}
}

rule addDataAccessConnection(implImg: AADLBA!ComponentImplementation,
							 name: String,
							 param: AADLBA!DataAccess,
							 ctx:AADLBA!Context,
							 variable: AADLBA!DataAccessConnectionEnd)
{
  to
	connectedParam: AADLBA!ConnectedElement
	(
		connectionEnd<-param,
		context<-ctx
	),
	connectedSubcomponent: AADLBA!ConnectedElement
	(
		connectionEnd<-variable
	),
	accessConnection: AADLBA!AccessConnection
	(
		name<-name,
		source<-connectedParam,
		accessCategory<-#data,
		destination<-connectedSubcomponent
	)
  do
  {
  	if(implImg.ownedAccessConnection->any(e|e.name=name).oclIsUndefined())
	  	implImg.ownedAccessConnection.add(accessConnection);
  }
}
--
-- AADL-RAMSES
-- 
-- Copyright Â© 2012 TELECOM ParisTech and CNRS
-- 
-- TELECOM ParisTech/LTCI
-- 
-- Authors: see AUTHORS
-- 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php
--

-- @nsURI AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore

module CommonRefinementSteps;
create OUT : AADLBA 	from 		IN : AADLI,
									AADL_RUNTIME: AADLBA,
									DATA_MODEL: AADLBA,
									PROGRAMMING_PROPERTIES: AADLBA,
									HOOKS: ATLHOOKS,

									POK_RUNTIME: AADLBA;


-------------------------------------------------------------------------------------------
----	TO BE SUPERIMPOSED

-- addNextValueSubprogramCall
-- addPutValueSubprogramCall
-- featureInstanceMappingPostTreatment(implImg: AADLBA!ThreadImplementation)

rule featureInstanceMappingPostTreatment(implImg: AADLBA!ThreadImplementation){
	
}
-------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------
----	ADDED MATCHED RULES
-------------------------------------------------------------------------------------------

rule DataPort_Instance_with_BA
{
	from
		fi: AADLI!FeatureInstance (fi.category=#dataPort
									and fi.eContainer().category=#thread
									and not fi.isPeriodicDelayedPort()
									and fi.eContainer().subcomponent.classifier.hasBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		-- local variable that will be initialized in the "do" section.
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- creation of a data access feature, to be added to the target thread component, 
		-- this data access represents an access to the global variable representing the
		-- communication 'port variable'.
		
		-- target data access must be called 'f' to be retreived with resolveTemp
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			),
		-- target data access must be called 'f_entrypoint' to be retreived with resolveTemp
		f_entrypoint: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		thisModule.featureInstanceMappingPostTreatment(implImg);
		f_entrypoint.dataFeatureClassifier <- f.dataFeatureClassifier;
	}
}


rule EventPort_Instance_with_BA
{
	from
		fi: AADLI!FeatureInstance (fi.category=#eventPort 
									and fi.eContainer().category = #thread
									and not fi.isPeriodicDelayedPort()
									and fi.eContainer().subcomponent.classifier.hasBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- target data access must be called 'f' to be retreived with resolveTemp
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			),
		f_entrypoint: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		thisModule.featureInstanceMappingPostTreatment(implImg);
		f_entrypoint.dataFeatureClassifier <- f.dataFeatureClassifier;
	}
}

rule EventDataPort_Instance_with_BA
{
	from
		fi: AADLI!FeatureInstance(fi.category=#eventDataPort 
								and fi.eContainer().category=#thread
								and not fi.isPeriodicDelayedPort()
								and fi.eContainer().subcomponent.classifier.hasBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- target data access must be called 'f' to be retreived with resolveTemp 
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			),
		f_entrypoint: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		thisModule.featureInstanceMappingPostTreatment(implImg);
		f_entrypoint.dataFeatureClassifier <- f.dataFeatureClassifier;
	}
}

rule DataAccess_Instance_with_BA
{
	from
		fi: AADLI!FeatureInstance (fi.category=#dataAccess
			 and fi.eContainer().category=#thread
			 and fi.eContainer().subcomponent.classifier.hasBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined; 
		processImplImg: AADLI!ProcessImplementation = OclUndefined;
	}
	to
		f: AADLBA!DataAccess
			(
				name <- fi.name,
				kind <- #requires,
				dataFeatureClassifier <- fi.feature.dataFeatureClassifier,
				ownedPropertyAssociation <- fi.feature.mapOwnedPropertyAssociationList()
			),
		f_entrypoint: AADLBA!DataAccess
			(
				name <- fi.name,
				kind <- #requires,
				dataFeatureClassifier <- fi.feature.dataFeatureClassifier,
				ownedPropertyAssociation <- fi.feature.mapOwnedPropertyAssociationList()
			)
	do
	{
		if(c.category=#thread)
		{
			processImplImg <- c.eContainer().subcomponent.subcomponentType;
		}
		thisModule.addThreadsInternalConnections(fi);
		implImg <- thisModule.resolveTemp(c, 'sub').subcomponentType.debug('Retreived Component Implementation');
		f_entrypoint.dataFeatureClassifier <- f.dataFeatureClassifier;
		thisModule.addImportedUnitFromInputModel(thisModule.public(), fi.feature);
	}
}





-------------------------------------------------------------------------------------------
----	OVERRIDEN MATCHED RULES
-------------------------------------------------------------------------------------------

rule DataPort_Instance
{
	from
		fi: AADLI!FeatureInstance (fi.category=#dataPort
									and fi.eContainer().category=#thread
									and not fi.isPeriodicDelayedPort()
									and not fi.eContainer().subcomponent.classifier.hasBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		-- local variable that will be initialized in the "do" section.
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- creation of a data access feature, to be added to the target thread component, 
		-- this data access represents an access to the global variable representing the
		-- communication 'port variable'.
		
		-- target data access must be called 'f' to be retreived with resolveTemp
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		thisModule.featureInstanceMappingPostTreatment(implImg);
	}
}


rule EventPort_Instance
{
	from
		fi: AADLI!FeatureInstance (fi.category=#eventPort 
									and fi.eContainer().category = #thread
									and not fi.isPeriodicDelayedPort()
									and not fi.eContainer().subcomponent.classifier.hasBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- target data access must be called 'f' to be retreived with resolveTemp
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		thisModule.featureInstanceMappingPostTreatment(implImg);
	}
}

rule EventDataPort_Instance
{
	from
		fi: AADLI!FeatureInstance(fi.category=#eventDataPort 
								and fi.eContainer().category=#thread
								and not fi.isPeriodicDelayedPort()
								and not fi.eContainer().subcomponent.classifier.hasBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined;
	}
	to
		-- target data access must be called 'f' to be retreived with resolveTemp 
		f: AADLBA!DataAccess
			(
				name <- fi.name+thisModule.dataAccessSuffix()+fi.direction,
				kind <- #requires
			)
	do
	{
		ATLHOOKS!HookAccess.allInstancesFrom('HOOKS')->first().addTransformationBackTrace(f, fi);
		
		implImg <- c.getSubcomponentImg().subcomponentType.debug('Retreived Component Implementation');
		thisModule.featureInstanceMappingPostTreatment(implImg);
	}
}

rule DataAccess_Instance
{
	from
		fi: AADLI!FeatureInstance (fi.category=#dataAccess
			 and fi.eContainer().category=#thread
			 and not fi.eContainer().subcomponent.classifier.hasBehaviorAnnex())
	using
	{
		c: AADLI!ComponentInstance = fi.eContainer();
		implImg: AADLI!ComponentImplementation = OclUndefined; 
		processImplImg: AADLI!ProcessImplementation = OclUndefined;
	}
	to
		f: AADLBA!DataAccess
			(
				name <- fi.name,
				kind <- #requires,
				dataFeatureClassifier <- fi.feature.dataFeatureClassifier,
				ownedPropertyAssociation <- fi.feature.mapOwnedPropertyAssociationList()
			)--,
--		d: AADLBA!DataSubcomponent
--			(name<-fi.name+thisModule.dataSubcomponentSuffix())
	do
	{
		if(c.category=#thread)
		{
			processImplImg <- c.eContainer().subcomponent.subcomponentType;
		}
		thisModule.addImportedUnitFromInputModel(thisModule.public(), fi.feature);
		thisModule.addThreadsInternalConnections(fi);
		implImg <- thisModule.resolveTemp(c, 'sub').subcomponentType.debug('Retreived Component Implementation');
	}
}


unique lazy rule ThreadType {
 from 
 	c : AADLI!ComponentInstance,
 	type : AADLI!ThreadType
 to 
 	typeImg : AADLBA!ThreadType (
 	 name <- c.uniqueName().debug('thread type'),
	 ownedDataAccess <- c.featureInstance->
										select(e| (e.category=#dataPort or e.category=#eventDataPort
													or e.category=#eventPort or e.category=#dataAccess) )->
										collect(f| f.getFeatureImg())
 	)
}

helper context AADLBA!Classifier def: hasBehaviorAnnex(): Boolean =
	not self.ownedAnnexSubclause->any(e| e.oclIsTypeOf(AADLBA!BehaviorAnnex)).oclIsUndefined()
;

helper def: ThreadImplementation(c : AADLI!ComponentInstance, typeImg : AADLBA!ThreadType, impl : AADLI!ThreadImplementation) : AADLBA!ThreadImplementation =
	if(impl.hasBehaviorAnnex()) then
		thisModule.ThreadImplementationWithBA(c, typeImg, impl)
	else
		thisModule.ThreadImplementationWithoutBA(c, typeImg, impl)
	endif
;

unique lazy rule ThreadImplementationWithBA {
 from 
    c : AADLI!ComponentInstance,
 	typeImg : AADLBA!ThreadType,
 	impl : AADLI!ThreadImplementation
 using
 {
 	implBA: AADLBA!BehaviorAnnex = impl.ownedAnnexSubclause->any(e| e.oclIsTypeOf(AADLBA!BehaviorAnnex));
 }
 to 
 	implImg : AADLBA!ThreadImplementation (
 		name <- c.uniqueName().concat('.impl'),
		ownedRealization 				<- thisModule.Realization(typeImg, implImg),
		ownedSubprogramSubcomponent 	<- impl.getSubcomponentsInstances('subprogram'),
		ownedDataSubcomponent 			<- impl.getSubcomponentsInstances('data'),
		ownedSubprogramCallSequence     <- thisModule.copyCallSequence(c,impl,implImg),
		ownedAccessConnection           <- Sequence{accessConnection_CURRENT_STATE}
	),
	entryPointImg: AADLBA!SubprogramType
	(
		name <- c.uniqueName().concat('_entrypoint'),
		ownedDataAccess <- Sequence{currentStateAccess}
	),
	entryPointImplImg: AADLBA!SubprogramImplementation
	(
		name <- entryPointImg.name.concat('.impl'),
		ownedRealization<-thisModule.Realization(entryPointImg, entryPointImplImg)
	),
	callEntryPoint: AADLBA!SubprogramCall
	(
		name<-thisModule.callPrefix()+entryPointImg.name,
		calledSubprogram<-entryPointImplImg
	),
	stateType: AADLBA!DataType
	(
		ownedPropertyAssociation <- Sequence {
												
												thisModule.CreatePropertyAssociation
												(
												 	'Data_Representation',
													'DATA_MODEL',
													'Enum'.asEnumeration('DATA_MODEL').asNamedValue()
												),
												thisModule.CreatePropertyAssociation
												(
												 	'Initial_Value',
													'DATA_MODEL',
													 thisModule.CreateListValueFromString(thisModule.getBAInitialStateIdentifier(implBA))
												),
												thisModule.CreatePropertyAssociation
												(
												 	'Enumerators',
													'DATA_MODEL',
													 thisModule.CreateListValueFromListOfString(implBA.states->collect(e|e.name))
												)
									},
		name <- c.uniqueName().concat('_currentState')
	),
	currentState: AADLBA!DataSubcomponent
	(
		name <- 'Parent_BA_currentState',
		dataSubcomponentType <- stateType
	),
	currentStateAccess: AADLBA!DataAccess
	(
		name <- 'Parent_BA_currentState_Access',
		dataFeatureClassifier <- stateType,
		kind <- #requires
	),
	
	
	-- connect currentState feature of entryPointImg to the data subcomponent of the implImg that
	-- represents the state of implImg
	connectedAccess_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentStateAccess,
		context<-callEntryPoint
	),
	connectedSubcomponent_CURRENT_STATE: AADLBA!ConnectedElement
	(
		connectionEnd<-currentState
	),
	accessConnection_CURRENT_STATE: AADLBA!AccessConnection
	(
		name<-'CNX_CURRENT_STATE_BA',
		source<-connectedAccess_CURRENT_STATE,
		destination<-connectedSubcomponent_CURRENT_STATE,
		accessCategory <- #data
	)
 do
 {
 	-- set ownership
	-- add current state to thread implementation implImg
 	implImg.ownedDataSubcomponent->add(currentState);
 	-- add data type to package
	thisModule.public().getOwnedClassifiers()->add(stateType);
 	-- add subprogram type to package
	thisModule.public().getOwnedClassifiers()->add(entryPointImg);
 	thisModule.public().getOwnedClassifiers()->add(entryPointImplImg);
 	
 	if(implImg.ownedSubprogramCallSequence->isEmpty())
 		implImg.ownedSubprogramCallSequence<-thisModule.createSubprogramCallSequence(implImg);
	
 	-- add call to entryPointImg
	implImg.ownedSubprogramCallSequence->first().getOwnedCallSpecifications().add(callEntryPoint);

 	-- add data accesses created from c.featureInstance
	entryPointImg.ownedDataAccess->addAll(c.featureInstance->collect(e|e.retreiveEntrypointFeature()));
 	
	entryPointImplImg.ownedAnnexSubclause->add(thisModule.copyBehaviorAnnexFromThread(c, 
															implBA, 
															currentStateAccess,
															stateType,
															entryPointImplImg));
	
	-- add BA in entryPointImg
	
 	for(f in c.featureInstance)
	{
 		if(f.direction=#out and f.category=#eventPort)
 		{
 			thisModule.addPutValueSubprogramCall(implImg.ownedSubprogramCallSequence->first(), impl, implImg, f);
 		}
 		
 		-- connect each feature of implImg to each copy of this feature in entryPointImg
		thisModule.addDataAccessConnection(	implImg,
							 		   	   	f.name.concat('_to_EntryPoint'),
							 			   	f.retreiveEntrypointFeature(),
							 			   	callEntryPoint,
							 				f.getFeatureImg());
	}	
 }
}

helper def: getBAInitialStateIdentifier(implBA: AADLBA!BehaviorAnnex) : String =
	implBA.states->any(s|s.initial=true).name
;

helper context AADLI!FeatureInstance def : retreiveIdAccess(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataAccess =
	self.getFeatureImg()
;

helper context AADLI!FeatureInstance def : retreiveEntrypointFeature() : AADLBA!DataAccess =
	thisModule.resolveTemp(self, 'f_entrypoint')
;

unique lazy rule ThreadImplementationWithoutBA {
 from 
    c : AADLI!ComponentInstance,
 	typeImg : AADLBA!ThreadType,
 	impl : AADLI!ThreadImplementation
 to 
 	implImg : AADLBA!ThreadImplementation (
 		name <- c.uniqueName().concat('.impl'),
		ownedRealization 				<- thisModule.Realization(typeImg, implImg),
		ownedSubprogramSubcomponent 	<- impl.getSubcomponentsInstances('subprogram'),
		ownedDataSubcomponent 			<- impl.getSubcomponentsInstances('data'),
		ownedSubprogramCallSequence     <- thisModule.copyCallSequence(c,impl,implImg)
	)
 do
 {
 	if(implImg.ownedSubprogramCallSequence->isEmpty())
 		implImg.ownedSubprogramCallSequence<-thisModule.createSubprogramCallSequence(implImg);
  	for(f in c.featureInstance)
	{
 		if(f.direction=#out and f.category=#eventPort)
 		{
 			thisModule.addPutValueSubprogramCall(implImg.ownedSubprogramCallSequence->first(), impl, implImg, f);
 		}
	}	
 }
}

unique lazy rule createSubprogramCallSequence {
 from
 	implImg: AADLBA!ThreadImplementation
 to
	seq: AADLBA!SubprogramCallSequence(
			name <- 'callSeq_Default'
		)
}

unique lazy rule mapOrphanOutputEventPorts
{
	from
		fi: AADLI!FeatureInstance,
		implImg : AADLBA!ThreadImplementation
	using
	{
		seq: AADLBA!SubprogramCallSequence = OclUndefined;
	}
	to 
		call: AADLBA!SubprogramCall
	do
	{
		call;
	}
}

unique lazy rule mapComputeEntrypoint
{
	from
		implImg : AABDBA!ComponentImplementation,
		c : AADLI!ComponentInstance,
		impl : AADLI!ComponentImplementation
	using
	{
		callImg : AADLBA!SubprogramCall = OclUndefined;
		fi: AADLI!FeatureInstance = OclUndefined;
		calledSubprogram: AADLBA!SubprogramClassifier = OclUndefined;
		referencedSubprogram: AADLI!Subprogram = impl.callSequenceFromComputeEntryPoint();
	}
	to
		seq: AADLBA!SubprogramCallSequence(
			name <- 'callSeq_'+referencedSubprogram.name
		),
		call : AADLBA!SubprogramCall (
			name <- 'call_'+referencedSubprogram.name,
			calledSubprogram <- referencedSubprogram
		)
	do
	{
		
		if(not impl.type.ownedEventPort->first().getModalPropertyValue('Compute_Entrypoint').oclIsUndefined())
		{
			fi<-c.featureInstance->any(e|e.name = impl.type.ownedEventPort->first().name);
			thisModule.addNextValueSubprogramCall(seq, impl, implImg, fi);
		}
		seq.ownedCallSpecification->add(call);
		if (referencedSubprogram.oclIsKindOf(AADLI!SubprogramType))
			call.calledSubprogram <- thisModule.Type(OclUndefined,referencedSubprogram);
		else if(referencedSubprogram.oclIsKindOf(AADLI!SubprogramImplementation))
			call.calledSubprogram <- thisModule.Implementation(OclUndefined,referencedSubprogram, thisModule.Type(OclUndefined,referencedSubprogram.getOwnedRealization().implemented));
		seq;
	}
}

rule mapInputParameterConnection(s2 : AADLBA!SubprogramCallSequence,
								 impl : AADLI!ComponentImplementation,
								 implImg : AABDBA!ComponentImplementation,
								 fi: AADLI!FeatureInstance,
								 call : AADLI!SubprogramCall,
								 calledSubprogram: AADLBA!SubprogramClassifier,
								 c : AADLI!ComponentInstance)
{
	do
	{
		for(paramCnx in impl.ownedParameterConnection)
		{
			if(paramCnx.destination.getContext() = call 
					and calledSubprogram.ownedParameter.contains(paramCnx.destination.connectionEnd)
					and paramCnx.destination.connectionEnd.isInputFeature())
			{
				fi<-c.featureInstance->any(e|e.name = paramCnx.source.connectionEnd.name);
				if(not fi.oclIsUndefined())
				{
					if(fi.feature.oclIsKindOf(AADLI!Port))
					{
						thisModule.addNextValueSubprogramCall(s2, impl, implImg, fi);
					}
			 	}
			}
		}
	}	
}


rule mapOutputParameterConnection(s2 : AADLBA!SubprogramCallSequence,
								 impl : AADLI!ComponentImplementation,
								 implImg : AABDBA!ComponentImplementation,
								 fi: AADLI!FeatureInstance,
								 call : AADLI!SubprogramCall,
								 calledSubprogram: AADLBA!SubprogramClassifier,
								 c : AADLI!ComponentInstance)
{
	do
	{
		for(paramCnx in impl.ownedParameterConnection)
		{
			if(paramCnx.source.getContext() = call 
					and calledSubprogram.ownedParameter.contains(paramCnx.source.connectionEnd)
					and paramCnx.source.connectionEnd.isOutputFeature())
			{
				fi<-c.featureInstance->any(e|e.name = paramCnx.destination.connectionEnd.name);
				if(not fi.oclIsUndefined())
				{
					if(fi.feature.oclIsKindOf(AADLI!Port))
					{
						thisModule.addPutValueSubprogramCall(s2, impl, implImg, fi);
					}
				}
			}
		}
	}
}



unique lazy rule mapCallSequence
{
	from
		implImg : AABDBA!ComponentImplementation,
		c : AADLI!ComponentInstance,
		impl : AADLI!ComponentImplementation
	using
	{
		callImg : AADLBA!SubprogramCall = OclUndefined;
		fi: AADLI!FeatureInstance = OclUndefined;
		calledSubprogram: AADLBA!SubprogramClassifier = OclUndefined;
	}
	to
		s2 : AADLBA!SubprogramCallSequence (name <- impl.callSequenceFromImpl().name)
	do
	{
		impl.callSequenceFromImpl().debug('  copy call sequence');
		
		for(call in impl.callSequenceFromImpl().ownedCallSpecification)
		{
			callImg <- thisModule.SubprogramCall(c, call, impl, implImg, call);
			if(call.calledSubprogram.oclIsKindOf(AADLBA!SubprogramAccess))
				calledSubprogram<-call.calledSubprogram.subprogramFeatureClassifier;
			else
				calledSubprogram<-call.calledSubprogram;
			-- if an in parameter is connected to an input port
			-- we must call next_value here
			
			thisModule.mapInputParameterConnection(s2, impl, implImg, fi, call, calledSubprogram, c);
			
			s2.getOwnedCallSpecifications().add(callImg);
			-- if an ou parameter is connected to an in data port or event data port
			-- we must call put_value here
			
			thisModule.mapOutputParameterConnection(s2, impl, implImg, fi, call, calledSubprogram, c);
			
			callImg.debug('  copy subprogram call');
		}
		s2;
	}
}



rule SubprogramCall (c: AADLI!ComponentInstance,
					 s : AADLI!SubprogramCall, 
					 impl : AADLI!ComponentImplementation, 
					 implImg : AADLBA!ComponentImplementation) {
	using
	{
		constantValue: Sequence(AADLBA!StringLiteral) = OclUndefined;
		constantValueParameters: Sequence(AADLBA!StringLiteral) = OclUndefined;
		parameterConstantValue: String = '';
	}
	to
		s2 : AADLBA!SubprogramCall (
			name <- s.name
		)
	do
	{
		if(not s.calledSubprogram.getPropertyAssociation('Source_Name').oclIsUndefined()
					and not s.calledSubprogram.getPropertyAssociation('Source_Text').oclIsUndefined())
		{
			s2.calledSubprogram <- s.calledSubprogram;
			thisModule.addImportedUnitFromInputModel(thisModule.public(), s.calledSubprogram);
		}
		else
		{
			if (s.calledSubprogram.oclIsKindOf(AADLI!SubprogramType))
				s2.calledSubprogram <- thisModule.Type(OclUndefined,s.calledSubprogram);
			else if(s.calledSubprogram.oclIsKindOf(AADLI!SubprogramImplementation))
				s2.calledSubprogram <- thisModule.Implementation(OclUndefined,s.calledSubprogram, thisModule.Type(OclUndefined,s.calledSubprogram.getOwnedRealization().implemented));
			else if (s.calledSubprogram.oclIsKindOf(AADLI!SubprogramAccess))
				if(s.calledSubprogram.subprogramFeatureClassifier.oclIsKindOf(AADLI!SubprogramType))
					s2.calledSubprogram <-  thisModule.Type(OclUndefined,s.calledSubprogram.subprogramFeatureClassifier);
				else if (s.calledSubprogram.subprogramFeatureClassifier.oclIsKindOf(AADLI!SubprogramType))
					s2.calledSubprogram <-  thisModule.Implementation(OclUndefined,s.calledSubprogram.subprogramFeatureClassifier, thisModule.Type(OclUndefined,s.calledSubprogram.subprogramFeatureClassifier.getOwnedRealization().implemented));
		
			if(not s.calledSubprogram.getModalPropertyValue('Constant_Value_Parameters').oclIsUndefined()
				and not s.calledSubprogram.getModalPropertyValue('Constant_Value').oclIsUndefined())
			{
				constantValue <- s.calledSubprogram.getModalPropertyValue('Constant_Value').ownedValue;
				constantValueParameters <- s.calledSubprogram.getModalPropertyValue('Constant_Value_Parameters').ownedValue;
				-- WARNING : We use both s (from input model) and s2 (from output model)
				-- in this code
				-- It is ok if: 
					-- 1) parameter constant values ('Constant_Value') and 
					-- parameters ('Constant_Value_Parameters') are identified 
					-- by strings in the property set
					-- 2) properties are copied from source to target model
					-- 3) parameters have the same name in the source and target model
				for(p in s2.calledSubprogram.getSubprogramParameters())
				{
					for(constantParamString in constantValueParameters.ownedListElement)
					{
						if(constantParamString.value=p.name)
						{
							parameterConstantValue <- constantValue.ownedListElement->at(constantValueParameters.ownedListElement->indexOf(constantParamString)).value;
							thisModule.mapConstantParameter(p, parameterConstantValue, s2, implImg);
						}
					}	
				}
			} else
			{
				if(not s2.calledSubprogram.getModalPropertyValue('Constant_Value_Parameters').oclIsUndefined()
					and not s2.calledSubprogram.getModalPropertyValue('Constant_Value').oclIsUndefined())
				{
					constantValue <- s2.calledSubprogram.getModalPropertyValue('Constant_Value').ownedValue;
					constantValueParameters <- s2.calledSubprogram.getModalPropertyValue('Constant_Value_Parameters').ownedValue;
					for(p in s2.calledSubprogram.getSubprogramParameters())
					{
						for(constantParamString in constantValueParameters.ownedListElement)
						{
							if(constantParamString.value=p.name)
							{
								parameterConstantValue <- constantValue.ownedListElement->at(constantValueParameters.ownedListElement->indexOf(constantParamString)).value;
								thisModule.mapConstantParameter(p, parameterConstantValue, s2, implImg);
							}
						}	
					}
				}
			}
		}
		s2;
	}
}

rule addDataAccessConnection(implImg: AADLBA!ComponentImplementation,
							 name: String,
							 param: AADLBA!DataAccess,
							 ctx:AADLBA!Context,
							 variable: AADLBA!DataAccessConnectionEnd)
{
  to
	connectedParam: AADLBA!ConnectedElement
	(
		connectionEnd<-param,
		context<-ctx
	),
	connectedSubcomponent: AADLBA!ConnectedElement
	(
		connectionEnd<-variable
	),
	accessConnection: AADLBA!AccessConnection
	(
		name<-name,
		source<-connectedParam,
		accessCategory<-#data,
		destination<-connectedSubcomponent
	)
  do
  {
  	implImg.ownedAccessConnection.add(accessConnection);
  }
}
-- @nsURI AADLBA=/fr.tpt.aadl.annex.behavior/model/aadlba.ecore

module ExpandThreadsPorts;
create OUT : AADLBA 	from 		IN : AADLI,
									AADL_RUNTIME: AADLBA,
									DATA_MODEL: AADLBA,
									PROGRAMMING_PROPERTIES: AADLBA,
									HOOKS: ATLHOOKS,

									POK_RUNTIME: AADLBA;


uses Services;
uses AADLCopyHelpers;
uses AADLICopyHelpers;
uses Uninstanciate;
uses PropertiesTools;

-- TODO :
	-- create global variables in process implementation
	-- Treat standard properties associated to ports

-------------------------------------------------------------------------------------------
----		TO BE SUPERIMPOSED RULES
-------------------------------------------------------------------------------------------
	
rule expandThreadDispatchProtocol(inst: AADLBA!ComponentInstancs, implImg: AADLBA!ThreadImplementation) 
{
}

rule createThreadBehavior(threadImpl: AADLBA!ThreadImplementation)
{
}
	
-------------------------------------------------------------------------------------------
----		SUPERIMPOSED RULES
-------------------------------------------------------------------------------------------

unique lazy rule ThreadType {
 from 
 	c : AADLI!ComponentInstance,
 	type : AADLI!ThreadType
 to 
 	typeImg : AADLBA!ThreadType (
 	 name <- c.uniqueName(),
	 ownedDataAccess <- type.ownedDataAccess->collect(e|thisModule.DataAccess(e))
 	)
}

unique lazy rule ThreadImplementation {
 from 
    c : AADLI!ComponentInstance,
 	typeImg : AADLBA!ThreadType,
 	impl : AADLI!ThreadImplementation
 to 
 	implImg : AADLBA!ThreadImplementation (
 		name <- c.uniqueName().concat('.impl'),
		ownedRealization 				<- thisModule.Realization(typeImg, implImg),
		ownedSubprogramSubcomponent 	<- impl.getSubcomponentsInstances('subprogram'),
		ownedDataSubcomponent 			<- impl.getSubcomponentsInstances('data')
	)
 do
 {
 	implImg.getOwnedSubprogramCallSequences().add(thisModule.CallSequence(impl,implImg));
	thisModule.addReturnCodeDataSubcomponent(implImg);
	for(p in c.featureInstance->select(e|e.category=#dataPort and (e.direction.toString()='in' or e.direction=#inOut)))
	{
		for(src in p.getSources())
		{
			if(src.eContainer().eContainer().debug(src.name+' double econtainer') = c.eContainer().debug(c.name+' simple econtainer'))
			{
				-- add data subcomponents for Blackboard
				implImg.type.ownedDataAccess.add(thisModule.PortInThread(p, 'Blackboard_Id_Type'.asDataType('POK_RUNTIME')));
				thisModule.addLengthDataSubcomponent(implImg,p.feature);
				thisModule.addMessageAddrDataSubcomponent(implImg,p.feature);
				thisModule.addTimeOutSubcomponent(implImg,p.feature);	
				
				-- add call to Read_Blackboard
				thisModule.addReadBlackBoardCallSpecification
				(
					'Read_Blackboard'.asSubprogramType('POK_RUNTIME'),
					impl.type.ownedDataPort->any(e| e.name = p.name),
					implImg
				);
				
				-- add connection to Read_Blackboard call
				for(cnx in impl.getOwnedParameterConnections())
				{
					if(cnx.source.connectionEnd = p.feature)
					{
						thisModule.addParameterConnection
						(
							implImg,
							'transfer_'+p.feature.retreiveMessageAddress(implImg).name+'_to_'+cnx.destination.getConnContextImg(implImg).name+'_'+cnx.destination.getConnFeatureImg(implImg).name,
							cnx.destination.getConnFeatureImg(implImg),
							cnx.destination.getConnContextImg(implImg),
							p.feature.retreiveMessageAddress(implImg)
						);
	
					}
				}
			}
			else if(src.eContainer().eContainer().getProcessorBinding().debug(src.name+' double econtainer + processor binding') = c.eContainer().getProcessorBinding().debug(c.name+' simple econtainer + processor binding'))
			{
				-- add data subcomponents for Read_Sampling_Message
				implImg.type.ownedDataAccess.add(thisModule.PortInThread(p, 'Sampling_Port_Id_Type'.asDataType('POK_RUNTIME')));
				thisModule.addLengthDataSubcomponent(implImg,p.feature);
				thisModule.addMessageAddrDataSubcomponent(implImg,p.feature);
				thisModule.addValidityDataSubcomponent(implImg,p.feature);
				
				-- add call to Read_Sampling_Message
				thisModule.addReadSamplingMessageCallSpecification
				(
					'Read_Sampling_Message'.asSubprogramType('POK_RUNTIME'),
					impl.type.ownedDataPort->any(e| e.name = p.name),
					implImg
				);
				
				-- add connection to Read_Sampling_Message call
				for(cnx in impl.getOwnedParameterConnections())
				{
					if(cnx.source.connectionEnd = p.feature)
					{
						thisModule.addParameterConnection
						(
							implImg,
							'transfer_'+p.feature.retreiveMessageAddress(implImg).name+'_to_'+cnx.destination.getConnContextImg(implImg).name+'_'+cnx.destination.getConnFeatureImg(implImg).name,
							cnx.destination.getConnFeatureImg(implImg),
							cnx.destination.getConnContextImg(implImg),
							p.feature.retreiveMessageAddress(implImg)
						);
	
					}
				}
				
			}
			else
			{
				OclUndefined.debug('ERROR : Unexpected Deployment Model');
			}
		}
	}
	for(p in c.featureInstance->select(e|e.category=#eventDataPort and (e.direction.toString()='in' or e.direction=#inOut)))
	{
		for(src in p.getSources())
		{
			if(src.eContainer().eContainer() = c.eContainer())
			{
				-- add call to Receive_Buffer
				thisModule.createReceiveBufferCallSpecification
				(
					impl.type.ownedDataPort->any(e| e.name = p.name),
					implImg
				);
			}
			else if(src.eContainer().eContainer().getProcessorBinding() = c.eContainer().getProcessorBinding())
			{
				-- add data subcomponents for Receive_Queing_Message
				implImg.type.ownedDataAccess.add(thisModule.PortInThread(p, 'Queuing_Port_Id_Type'.asDataType('POK_RUNTIME')));
				thisModule.addTimeOutSubcomponent(implImg,p.feature);
				thisModule.addMessageAddrDataSubcomponent(implImg,p.feature);
				thisModule.addLengthDataSubcomponent(implImg,p.feature);
				
				-- add call to Receive_Queing_Message
				thisModule.addQueuingMessageCallSpecification
				(
					'Receive_Queuing_Message'.asSubprogramType('POK_RUNTIME'),
					impl.type.ownedEventDataPort->any(e| e.name = p.name),
					implImg
				);
				
				-- add connection to Receive_Queing_Message call
				for(cnx in impl.getOwnedParameterConnections())
				{
					
					if(cnx.destination.connectionEnd = p.feature)
					{
						thisModule.addParameterConnection
						(
							implImg,
							'transfer_'+p.feature.retreiveMessageAddress(implImg).name+'_to_'+cnx.source.getConnContextImg(implImg).name+'_'+cnx.source.getConnFeatureImg(implImg).name,
							cnx.source.getConnFeatureImg(implImg),
							cnx.source.getConnContextImg(implImg),
							p.feature.retreiveMessageAddress(implImg)
						);
	
					}
				}
			}
		}
	}
	for(p in c.featureInstance->select(e|e.category=#dataPort and (e.direction=#out or e.direction=#inOut) ))
	{
		for(dest in p.getDestinations())
		{
			if(dest.eContainer().eContainer() = c.eContainer())
			{
				-- add data subcomponents for Blackboard
				implImg.type.ownedDataAccess.add(thisModule.PortInThread(p, 'Blackboard_Id_Type'.asDataType('POK_RUNTIME')));
				thisModule.addLengthDataSubcomponent(implImg,p.feature);
				thisModule.addMessageAddrDataSubcomponent(implImg,p.feature);
				thisModule.addTimeOutSubcomponent(implImg,p.feature);
				
				-- add call to Display_Blackboard
				thisModule.addDisplayBlackBoardCallSpecification
				(
					'Display_Blackboard'.asSubprogramType('POK_RUNTIME'),
					impl.type.ownedDataPort->any(e| e.name = p.name),
					implImg
				);
				
				-- add connection to Display_Blackboard call
				for(cnx in impl.getOwnedParameterConnections())
				{
					
					if(cnx.destination.connectionEnd = p.feature)
					{
						thisModule.addParameterConnection
						(
							implImg,
							'transfer_'+p.feature.retreiveMessageAddress(implImg).name+'_to_'+cnx.source.getConnContextImg(implImg).name+'_'+cnx.source.getConnFeatureImg(implImg).name,
							cnx.source.getConnFeatureImg(implImg),
							cnx.source.getConnContextImg(implImg),
							p.feature.retreiveMessageAddress(implImg)
						);
	
					}
				}
			}
			else if(dest.eContainer().eContainer().getProcessorBinding() = c.eContainer().getProcessorBinding())
			{
				-- add data subcomponents for Write_Sampling_Message
				implImg.type.ownedDataAccess.add(thisModule.PortInThread(p, 'Sampling_Port_Id_Type'.asDataType('POK_RUNTIME')));
				thisModule.addLengthDataSubcomponent(implImg,p.feature);
				thisModule.addMessageAddrDataSubcomponent(implImg,p.feature);
				
				-- add call to Write_Sampling_Message
				thisModule.addWriteSamplingMessageCallSpecification
				(
					'Write_Sampling_Message'.asSubprogramType('POK_RUNTIME'),
					impl.type.ownedDataPort->any(e| e.name = p.name),
					implImg
				);
				
				-- add connection to Write_Sampling_Message call
				for(cnx in impl.getOwnedParameterConnections())
				{
					if(cnx.destination.connectionEnd = p.feature)
					{
						thisModule.addParameterConnection
						(
							implImg,
							'transfer_'+p.feature.retreiveMessageAddress(implImg).name+'_to_'+cnx.source.getConnContextImg(implImg).name+'_'+cnx.source.getConnFeatureImg(implImg).name,
							cnx.source.getConnFeatureImg(implImg),
							cnx.source.getConnContextImg(implImg),
							p.feature.retreiveMessageAddress(implImg)
						);
	
					}
				}
				
			}
		}
	}
	for(p in c.featureInstance->select(e|e.category=#eventDataPort and (e.direction=#out or e.direction=#inOut) ))
	{
		for(dest in p.getDestinations())
		{
			if(dest.eContainer().eContainer() = c.eContainer())
			{
				-- add call to Send_Buffer
				thisModule.createSendBufferCallSpecification
				(
					'Send_Buffer'.asSubprogramType('POK_RUNTIME'),
					impl.type.ownedEventDataPort->any(e| e.name = p.name),
					implImg
				);
			}
			else if(dest.eContainer().eContainer().getProcessorBinding() = c.eContainer().getProcessorBinding())
			{
				-- add data subcomponents for Send_Queuing_Message
				implImg.type.ownedDataAccess.add(thisModule.PortInThread(p, 'Queuing_Port_Id_Type'.asDataType('POK_RUNTIME')));
				thisModule.addMessageAddrDataSubcomponent(implImg,p.feature);
				thisModule.addLengthDataSubcomponent(implImg,p.feature);
				thisModule.addTimeOutSubcomponent(implImg,p.feature);
				
				-- add call to Send_Queuing_Message
				thisModule.addQueuingMessageCallSpecification
				(
					'Send_Queuing_Message'.asSubprogramType('POK_RUNTIME'),
					impl.type.ownedEventDataPort->any(e| e.name = p.name),
					implImg
				);
				
				-- add connection to Send_Queuing_Message call
				for(cnx in impl.getOwnedParameterConnections())
				{
					if(cnx.destination.connectionEnd = p.feature)
					{
						thisModule.addParameterConnection
						(
							implImg,
							'transfer_'+p.feature.retreiveMessageAddress(implImg).name+'_to_'+cnx.source.getConnContextImg(implImg).name+'_'+cnx.source.getConnFeatureImg(implImg).name,
							cnx.source.getConnFeatureImg(implImg),
							cnx.source.getConnContextImg(implImg),
							p.feature.retreiveMessageAddress(implImg)
						);
	
					}
				}
				
			}
		}
	}
	for(paramConnection in impl.ownedParameterConnection)
	{
		if(paramConnection.source.oclIsTypeOf(AADLI!DataClassifier)
				or paramConnection.destination.oclIsTypeOf(AADLI!DataClassifier))
		{
			implImg.ownedParameterConnection.add(thisModule.ParameterConnection(paramConnection, implImg));
		} else if(paramConnection.source.connectionEnd.oclIsKindOf(AADLI!Parameter) and paramConnection.destination.connectionEnd.oclIsKindOf(AADLI!Parameter))
		{
			thisModule.addSuprogramCallParameterConnection(implImg, paramConnection);
		}
	}
	thisModule.expandThreadDispatchProtocol(c, implImg);
	thisModule.createThreadBehavior(implImg);
 }
}

helper context AADLI!ConnectedElement def : getConnFeatureImg(owner : AADLBA!ComponentImplementation) : AADLBA!Feature =
	if (self.context.oclIsUndefined()) then
		if(self.connectionEnd.oclIsKindOf(AADLI!Port)) then
			if(self.connectionEnd.isDataOrEventDataPort() and self.connectionEnd.isThreadPort()) then
				self.connectionEnd.retreiveIdAccess(owner).debug(owner.name+' Port Id access')
			else
				owner.getType().getOwnedFeatures()->any(f|f.name=self.connectionEnd.name)
			endif
		else
			owner.getType().getOwnedFeatures()->any(f|f.name=self.connectionEnd.name)
		endif
	else
		if (self.getConnContextImg(owner).oclIsUndefined()) then
		    -- subcomponent is not yet mapped: feature cannot be resolved yet
			OclUndefined
		else 
			if (self.getConnContextImg(owner).oclIsKindOf(AADLBA!SubprogramCall)) then
				self.getConnContextImg(owner).calledSubprogram.ownedParameter->any(p|p.name=self.connectionEnd.name)
			else
				-- subcomponent is mapped: feature is accessible
				self.getConnContextImg(owner).getType().getOwnedFeatures()->any(f|f.name=self.connectionEnd.name)
			endif
		endif
	endif
;

unique lazy rule ProcessImplementation {
 from
    typeImg : AADLBA!ProcessType,
 	impl : AADLI!ProcessImplementation
 to 
 	implImg : AADLBA!ProcessImplementation (
 		name 							<- impl.name,
		ownedRealization 				<- thisModule.Realization(typeImg, implImg),
		ownedThreadGroupSubcomponent 	<- impl.getSubcomponentsInstances('thread group'),
		ownedThreadSubcomponent 		<- impl.getSubcomponentsInstances('thread'),
		ownedSubprogramSubcomponent 	<- impl.getSubcomponentsInstances('subprogram'),
		ownedDataSubcomponent 			<- impl.getSubcomponentsInstances('data'),
		ownedAccessConnection			<- impl.ownedAccessConnection->collect(co|thisModule.AccessConnection(co))
	)
 do
 {
 	thisModule.addImportedUnit(thisModule.public(), 'POK_RUNTIME' ,'pok_runtime');
 	for(cnx in impl.ownedConnection)
 	{
 		if(	cnx.source.connectionEnd.isThreadPort()
				and cnx.destination.connectionEnd.isThreadPort())
 		{
 			if(cnx.source.connectionEnd.oclIsKindOf(AADLBA!DataPort)
 				and cnx.destination.connectionEnd.oclIsKindOf(AADLBA!DataPort))
 			{
 				
				-- add and connect data subcomponent, Id of the communication protocol
				implImg.ownedDataSubcomponent.add
				(
					thisModule.ThreadPortIdInstance
					(
						cnx.destination.connectionEnd,
						'Blackboard_Id_Type'.asDataType('POK_RUNTIME')
					)
				);
				
				thisModule.addDataAccessConnection
				(
					implImg,
					'Id_instance_from_'+cnx.source.connectionEnd.name,
					cnx.source.connectionEnd.retreiveIdAccess(cnx.source.getConnContextImg(implImg).threadSubcomponentType), 
					cnx.source.getConnContextImg(implImg),
					cnx.destination.connectionEnd.retreiveIdValue(implImg)
				);
				
				thisModule.addDataAccessConnection
				(
					implImg,
					'Id_instance_to_'+cnx.destination.connectionEnd.name,
					cnx.destination.connectionEnd.retreiveIdAccess(cnx.destination.getConnContextImg(implImg).threadSubcomponentType), 
					cnx.destination.getConnContextImg(implImg),
					cnx.destination.connectionEnd.retreiveIdValue(implImg)
				);
 			}
 		}
 		else if(	cnx.source.connectionEnd.isProcessPort()
				and cnx.destination.connectionEnd.isThreadPort())
 		{
 			if(cnx.source.connectionEnd.oclIsKindOf(AADLBA!DataPort)
 				and cnx.destination.connectionEnd.oclIsKindOf(AADLBA!DataPort))
 			{
 				-- add and connect data subcomponent, Id of the communication protocol
				implImg.ownedDataSubcomponent.add
				(
					thisModule.ThreadPortIdInstance
					(
						cnx.destination.connectionEnd,
						'Sampling_Port_Id_Type'.asDataType('POK_RUNTIME')
					)
				);	
 			}
 			
 			if(cnx.source.connectionEnd.oclIsKindOf(AADLBA!EventDataPort)
 				and cnx.destination.connectionEnd.oclIsKindOf(AADLBA!EventDataPort))
 			{
 				-- add and connect data subcomponent, Id of the communication protocol
				implImg.ownedDataSubcomponent.add
				(
					thisModule.ThreadPortIdInstance
					(
						cnx.destination.connectionEnd,
						'Queuing_Port_Id_Type'.asDataType('POK_RUNTIME')
					)
				);	
 			}
				
			thisModule.addDataAccessConnection
			(
				implImg,
				'Id_instance_to_'+cnx.destination.connectionEnd.name,
				cnx.destination.connectionEnd.retreiveIdAccess(cnx.destination.getConnContextImg(implImg).threadSubcomponentType), 
				cnx.destination.getConnContextImg(implImg),
				cnx.destination.connectionEnd.retreiveIdValue(implImg)
			);
 		}
 		else if(	cnx.source.connectionEnd.isThreadPort()
				and cnx.destination.connectionEnd.isProcessPort())
 		{
 			if(cnx.source.connectionEnd.oclIsKindOf(AADLBA!DataPort)
 				and cnx.destination.connectionEnd.oclIsKindOf(AADLBA!DataPort))
 			{
 				-- add and connect data subcomponent, Id of the communication protocol
				implImg.ownedDataSubcomponent.add
				(
					thisModule.ThreadPortIdInstance
					(
						cnx.destination.connectionEnd,
						'Sampling_Port_Id_Type'.asDataType('POK_RUNTIME')
					)
				);
 			}
 			
 			if(cnx.source.connectionEnd.oclIsKindOf(AADLBA!EventDataPort)
 				and cnx.destination.connectionEnd.oclIsKindOf(AADLBA!EventDataPort))
 			{
 				-- add and connect data subcomponent, Id of the communication protocol
				implImg.ownedDataSubcomponent.add
				(
					thisModule.ThreadPortIdInstance
					(
						cnx.destination.connectionEnd,
						'Queuing_Port_Id_Type'.asDataType('POK_RUNTIME')
					)
				);	
 			}
			thisModule.addDataAccessConnection
			(
				implImg,
				'Id_instance_from_'+cnx.source.connectionEnd.name,
				cnx.source.connectionEnd.retreiveIdAccess(cnx.source.getConnContextImg(implImg).threadSubcomponentType), 
				cnx.source.getConnContextImg(implImg),
				cnx.destination.connectionEnd.retreiveIdValue(implImg)
			);
 		}
 	}
 }
}

-------------------------------------------------------------------------------------------
----		ADDED HELPERS
-------------------------------------------------------------------------------------------

helper context AADLI!Port def : retreiveDataPortAccessor(prefix:String) : AADLBA!SubprogramImplementation =
	thisModule.public().ownedClassifier->select(e| e.oclIsTypeOf(AADLBA!SubprogramImplementation) and e.name=prefix+self.dataFeatureClassifier.name+'.impl')->first()
;

helper context AADLI!Port def : retreiveMessageAddress(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataSubcomponent =
	threadImplImg.ownedDataSubcomponent->any(e| e.name=self.name+'_MsgAddr')
;

helper context AADLI!Port def : retreiveLengthValue(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataSubcomponent =
	threadImplImg.ownedDataSubcomponent->any(e| e.name=self.name+'_Length')
;

helper def : retreiveReturnCodeValue(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataSubcomponent =
	if(threadImplImg.ownedDataSubcomponent->any(e| e.name='runtime_call_ret').oclIsUndefined() )
	then
		thisModule.addReturnCodeDataSubcomponent(threadImplImg)
	else
		threadImplImg.ownedDataSubcomponent->any(e| e.name='runtime_call_ret')
	endif
;

helper context AADLI!Port def : retreiveTimeOutValue(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataSubcomponent =
	threadImplImg.ownedDataSubcomponent->any(e| e.name=self.name+'_TimeOut')
;

helper context AADLI!Port def : retreiveValidityValue(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataSubcomponent =
	threadImplImg.ownedDataSubcomponent->any(e| e.name=self.name+'_Validity')
;

helper context AADLI!Port def : retreiveIdAccess(threadImplImg: AADLBA!ThreadImplementation) : AADLBA!DataAccess =
	threadImplImg.type.ownedDataAccess->any(e| e.name=self.name+'_PortIdAccess_'+self.direction)
;

helper context AADLI!Port def : retreiveIdValue(processImplImg: AADLBA!ProcessImplementation) : AADLBA!DataAccess =
	processImplImg.ownedDataSubcomponent->any(e| e.name=self.name+'_Instance')
;

helper def: dataSubcomponentSuffix: String = '_InternalValue';
helper def: dataAccessSuffix: String ='_PortIdAccess_';
helper def: connectionToDataAccessSuffix: String ='_from_PortVariable';
helper def: connectionToDataSubcomponentSuffix: String ='_to_InternalValue';
helper def: callPrefix: String ='call_';

helper context AADLI!ConnectionInstanceEnd def : getDestinations() : Sequence(AADLI!ConnectionInstanceEnd) =
    AADLI!ConnectionInstance->allInstancesFrom('IN')->select(c|c.source=self)
                            ->collect(c|c.destination)
;

helper context AADLI!ConnectionInstanceEnd def : getSources() : Sequence(AADLI!ConnectionInstanceEnd) =
    AADLI!ConnectionInstance->allInstancesFrom('IN')->select(c|c.destination=self)
                            ->collect(c|c.source)
; 

helper context AADLI!ComponentInstance def : getProcessorBinding() : AADLI!SubcomponentImplementation =
	self.ownedPropertyAssociation->any(e | e.property = AADLBA!Property->allInstancesFrom('DEPLOYMENT_PROPERTIES')->any(f|f.name = 'Actual_Processor_Binding')).appliesTo
;


-------------------------------------------------------------------------------------------
----		ADDED RULES
-------------------------------------------------------------------------------------------

rule addImportedUnit(packageImg: AADLBA!PackageSection,	model: String,	importedPackage:String) {
	using
	{
		unit: AADLBA!ModelUnit = AADLBA!ModelUnit->allInstancesFrom(model)->any(e|e.name = importedPackage);
		isNotYetImported: Boolean =  AADLBA!ModelUnit->allInstancesFrom('OUT')->any(e|e.name = importedPackage).oclIsUndefined();
	}
	do
	{
		if(isNotYetImported)
		{
			packageImg.importedUnit.add(unit);
		}
	}
}

------------
--- Module Specific rules

lazy rule addLengthDataSubcomponent
{
	from
		implImg : AADLBA!ThreadImplementation,
		port : AADLBA!Feature
	using
	{
		typeId: String = port.dataFeatureClassifier.getQualifiedName().replaceAll('::', '__').replaceAll('.','_');
		initValuePE: AADLBA!PropertyExpression = thisModule.CreateStringLiteralPropertyExpression('sizeof('+typeId+')');
	}
	to
		lv: AADLBA!ListValue
		(
			ownedListElement <- Sequence{initValuePE}
		),
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-port.name+'_Length',
			dataSubcomponentType<-'Unsigned_8'.asBaseType(),
			ownedPropertyAssociation	<- Sequence {thisModule.CreatePropertyAssociation('Initial_Value','DATA_MODEL',lv)}
		)
	do
	{
		implImg.ownedDataSubcomponent.add(dataSubcomponent);
	}
}

lazy rule addMessageAddrDataSubcomponent
{
	from
		implImg : AADLBA!ThreadImplementation,
		port : AADLBA!Feature
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-port.name+'_MsgAddr',
			dataSubcomponentType<-'Unsigned_8'.asBaseType()
		)
	do
	{
		if(port.isDataOrEventDataPort())
		{
			dataSubcomponent.dataSubcomponentType <- AADLBA!DataSubcomponentType.allInstancesFrom('OUT')->any(e|e.name = port.dataFeatureClassifier.name);
			if(dataSubcomponent.dataSubcomponentType.oclIsUndefined())
			{
				dataSubcomponent.dataSubcomponentType <- port.dataFeatureClassifier;
			}
		}
		implImg.ownedDataSubcomponent.add(dataSubcomponent);
	}
}

lazy rule addValidityDataSubcomponent
{
	from
		implImg : AADLBA!ThreadImplementation,
		port : AADLBA!Feature
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-port.name+'_Validity',
			dataSubcomponentType<-'Validity_Type'.asDataType('POK_RUNTIME')
		)
	do
	{
		implImg.ownedDataSubcomponent.add(dataSubcomponent);
	}
}

lazy rule addTimeOutSubcomponent
{
	from
		implImg : AADLBA!ThreadImplementation,
		port : AADLBA!Feature
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-port.name+'_TimeOut',
			dataSubcomponentType<-'System_Time_Type'.asDataType('POK_RUNTIME')
		)
	do
	{
		implImg.ownedDataSubcomponent.add(dataSubcomponent);
	}
}

unique lazy rule addReturnCodeDataSubcomponent
{
	from
		impl: AADLBA!ThreadImplementation
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name <- 'runtime_call_ret',
			dataSubcomponentType<-'Return_Code_Type'.asDataType('POK_RUNTIME')
		)
	do
	{
		impl.getOwnedDataSubcomponents().add(dataSubcomponent);
		dataSubcomponent;
	}
}

rule addQueuingMessageCallSpecification(spg: AADLBA!SubprogramType, p: AADLI!Port, implImg: AADLBA!ThreadImplementation)
{
	using
	{
		QUEUING_PORT_ID: AADLBA!DataAccess = p.retreiveIdAccess(implImg);
		TIME_OUT: AADLBA!DataSubcomponent = p.retreiveTimeOutValue(implImg);
		MESSAGE_ADDR: AADLBA!DataSubcomponent = p.retreiveMessageAddress(implImg);
		LENGTH: AADLBA!DataSubcomponent = p.retreiveLengthValue	(implImg);
		RETURN_CODE: AADLBA!DataSubcomponent = thisModule.retreiveReturnCodeValue(implImg);
	}
	to
		call: AADLBA!SubprogramCall
		(
			name<-'call_'+spg.name,
			calledSubprogram<-spg
		),
		
		connected_QUEUING_ID_Access: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedDataAccess->first().debug('Id Data Access Connection End')
		),
		connected_QUEUING_ID: AADLBA!ConnectedElement
		(
			connectionEnd<-QUEUING_PORT_ID.debug('Id Subcomponent Connection End')
		),
		accessIDConnection: AADLBA!AccessConnection
		(
			name<-p.name+'_to_ID',
			accessCategory<-#data,
			source<-connected_QUEUING_ID_Access,
			destination<-connected_QUEUING_ID
		),
		
		connectedParam_TIME_OUT: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='TIME_OUT').debug('TimeOut Parameter Connection End')
		),
		connectedSubcomponent_TIME_OUT: AADLBA!ConnectedElement
		(
			connectionEnd<-TIME_OUT.debug('TimeOut Subcomponent Connection End')
		),
		paramConnection_TIME_OUT: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_TimeOut',
			source<-connectedParam_TIME_OUT,
			destination<-connectedSubcomponent_TIME_OUT
		),
		
		connectedParam_MESSAGE_ADDR: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='MESSAGE_ADDR').debug('MsgAddr Parameter Connection End')
		),
		connectedSubcomponent_MESSAGE_ADDR: AADLBA!ConnectedElement
		(
			connectionEnd<-MESSAGE_ADDR.debug('MsgAddr Subcomponent Connection End')
		),
		paramConnection_MESSAGE_ADDR: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_MsgAddr',
			source<-connectedParam_MESSAGE_ADDR,
			destination<-connectedSubcomponent_MESSAGE_ADDR
		),
		
		connectedParam_LENGTH: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='LENGTH').debug('MessageAddr Parameter Connection End')
		),
		connectedSubcomponent_LENGTH: AADLBA!ConnectedElement
		(
			connectionEnd<-LENGTH.debug('TimeOut Subcomponent Connection End')
		),
		paramConnection_LENGTH: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_Length',
			source<-connectedParam_LENGTH,
			destination<-connectedSubcomponent_LENGTH
		),
		
		connectedParam_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='RETURN_CODE').debug('ReturnCode Parameter Connection End')
		),
		connectedSubcomponent_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-RETURN_CODE.debug('ReturnCode Subcomponent Connection End')
		),
		paramConnection_RETURN_CODE: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_ReturnCode',
			source<-connectedParam_RETURN_CODE,
			destination<-connectedSubcomponent_RETURN_CODE
		)
		
	do
	{
		
		connected_QUEUING_ID_Access.setContext(call);
		connectedParam_TIME_OUT.setContext(call);
		connectedParam_MESSAGE_ADDR.setContext(call);
		connectedParam_LENGTH.setContext(call);
		connectedParam_RETURN_CODE.setContext(call);
		
		implImg.getOwnedAccessConnections().add(accessIDConnection);
		implImg.getOwnedParameterConnections().add(paramConnection_TIME_OUT);
		implImg.getOwnedParameterConnections().add(paramConnection_MESSAGE_ADDR);
		implImg.getOwnedParameterConnections().add(paramConnection_LENGTH);
		implImg.getOwnedParameterConnections().add(paramConnection_RETURN_CODE);
		
		for(seq in implImg.getOwnedSubprogramCallSequences())
		{
			if(p.direction.toString()='in' or p.direction=#inOut)
				seq.getOwnedCallSpecifications().add(0, call);
			if (p.direction=#out or p.direction=#inOut)
				seq.getOwnedCallSpecifications().add(call);
		}

		
		call.debug('Created Call Sequence');
		call;
	}
}

rule addDisplayBlackBoardCallSpecification(spg: AADLBA!SubprogramType, p: AADLI!Port, implImg: AADLBA!ThreadImplementation)
{
	to
		call: AADLBA!SubprogramCall
		(
			name<-'call_'+spg.name,
			calledSubprogram<-spg
		)
	do
	{
		thisModule.addBlackBoardCallSpecification(call, spg, p, implImg);
	}
}

rule addReadBlackBoardCallSpecification(spg: AADLBA!SubprogramType, p: AADLI!Port, implImg: AADLBA!ThreadImplementation)
{
	using
	{
		TIME_OUT: AADLBA!DataSubcomponent = p.retreiveTimeOutValue(implImg);
	}
	to
		call: AADLBA!SubprogramCall
		(
			name<-'call_'+spg.name,
			calledSubprogram<-spg
		),
		connectedParam_TIME_OUT: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->first().debug('TimeOut Parameter Connection End')
		),
		connectedSubcomponent_TIME_OUT: AADLBA!ConnectedElement
		(
			connectionEnd<-TIME_OUT.debug('TimeOut Subcomponent Connection End')
		),
		paramConnection_TIME_OUT: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_TimeOut',
			source<-connectedParam_TIME_OUT,
			destination<-connectedSubcomponent_TIME_OUT
		)
	do
	{
		thisModule.addBlackBoardCallSpecification(call, spg, p, implImg);
		connectedParam_TIME_OUT.setContext(call);
		implImg.getOwnedParameterConnections().add(paramConnection_TIME_OUT);
	}
}

rule addBlackBoardCallSpecification(call: AADLBA!SubprogramCall, spg: AADLBA!SubprogramType, p: AADLI!Port, implImg: AADLBA!ThreadImplementation)
{
	using
	{
		BLACKBOARD_ID: AADLBA!DataAccess = p.retreiveIdAccess(implImg); 
		MESSAGE_ADDR: AADLBA!DataSubcomponent = p.retreiveMessageAddress(implImg);
		LENGTH: AADLBA!DataSubcomponent = p.retreiveLengthValue	(implImg);
		RETURN_CODE: AADLBA!DataSubcomponent = thisModule.retreiveReturnCodeValue(implImg);
	}
	to
		
		connected_BLACKBOARD_ID_Access: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedDataAccess->first().debug('Id Data Access Connection End')
		),
		connected_BLACKBOARD_ID: AADLBA!ConnectedElement
		(
			connectionEnd<-BLACKBOARD_ID.debug('Id Subcomponent Connection End')
		),
		accessIDConnection: AADLBA!AccessConnection
		(
			name<-p.name+'_to_ID',
			accessCategory<-#data,
			source<-connected_BLACKBOARD_ID_Access,
			destination<-connected_BLACKBOARD_ID
		),
		
		connectedParam_MESSAGE_ADDR: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='MESSAGE_ADDR').debug('MessageAddr Parameter Connection End')
		),
		connectedSubcomponent_MESSAGE_ADDR: AADLBA!ConnectedElement
		(
			connectionEnd<-MESSAGE_ADDR.debug('MessageAddr Subcomponent Connection End')
		),
		paramConnection_MESSAGE_ADDR: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_MessageAddr',
			source<-connectedParam_MESSAGE_ADDR,
			destination<-connectedSubcomponent_MESSAGE_ADDR
		),
		
		connectedParam_LENGTH: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='LENGTH').debug('Length Parameter Connection End')
		),
		connectedSubcomponent_LENGTH: AADLBA!ConnectedElement
		(
			connectionEnd<-LENGTH.debug('Length Subcomponent Connection End')
		),
		
		paramConnection_LENGTH: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_MessageLength',
			source<-connectedParam_LENGTH,
			destination<-connectedSubcomponent_LENGTH
		),
		
		connectedParam_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='RETURN_CODE').debug('Subprogram Parameter Connection End')
		),
		connectedSubcomponent_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-RETURN_CODE.debug('Subprogram Subcomponent Connection End')
		),
		paramConnection_RETURN_CODE: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_ReturnCode',
			source<-connectedParam_RETURN_CODE,
			destination<-connectedSubcomponent_RETURN_CODE
		)
		
	do
	{
		
		connectedParam_MESSAGE_ADDR.setContext(call);
		connected_BLACKBOARD_ID_Access.setContext(call);
		connectedParam_RETURN_CODE.setContext(call);
		connectedParam_LENGTH.setContext(call);
		
		implImg.getOwnedParameterConnections().add(paramConnection_MESSAGE_ADDR);
		implImg.getOwnedAccessConnections().add(accessIDConnection);
		implImg.getOwnedParameterConnections().add(paramConnection_RETURN_CODE);
		implImg.getOwnedParameterConnections().add(paramConnection_LENGTH);
		
		for(seq in implImg.getOwnedSubprogramCallSequences())
		{
			if(p.direction.toString()='in' or p.direction=#inOut)
				seq.getOwnedCallSpecifications().add(0, call);
			if (p.direction=#out or p.direction=#inOut)
				seq.getOwnedCallSpecifications().add(call);
		}

		
		call.debug('Created Call Sequence');
		call;
	}
}

rule addWriteSamplingMessageCallSpecification(spg: AADLBA!SubprogramType, p: AADLI!Port, implImg: AADLBA!ThreadImplementation)
{
	to
		call: AADLBA!SubprogramCall
		(
			name<-'call_'+spg.name,
			calledSubprogram<-spg
		)
	do
	{
		thisModule.addSamplingCallSpecification(call, spg, p, implImg);
	}
}

rule addReadSamplingMessageCallSpecification (spg: AADLBA!SubprogramType, p: AADLI!Port, implImg: AADLBA!ThreadImplementation)
{
	using
	{
		VALIDITY: AADLBA!DataSubcomponent = p.retreiveValidityValue(implImg);
	}
	to
		call: AADLBA!SubprogramCall
		(
			name<-'call_'+spg.name,
			calledSubprogram<-spg
		),
		connectedParam_VALIDITY: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='VALIDITY').debug('TimeOut Parameter Connection End')
		),
		connectedSubcomponent_VALIDITY: AADLBA!ConnectedElement
		(
			connectionEnd<-VALIDITY.debug('TimeOut Subcomponent Connection End')
		),
		paramConnection_VALIDITY: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_Validity',
			source<-connectedParam_VALIDITY,
			destination<-connectedSubcomponent_VALIDITY
		)
	do
	{
		thisModule.addSamplingCallSpecification(call, spg, p, implImg);
		connectedParam_VALIDITY.setContext(call);
		implImg.getOwnedParameterConnections().add(paramConnection_VALIDITY);
	}
}

rule addSamplingCallSpecification(call: AADLBA!SubprogramCall, spg: AADLBA!SubprogramType, p: AADLI!Port, implImg: AADLBA!ThreadImplementation)
{
	using
	{
		SAMPLING_ID: AADLBA!DataAccess = p.retreiveIdAccess(implImg); 
		MESSAGE_ADDR: AADLBA!DataSubcomponent = p.retreiveMessageAddress(implImg);
		LENGTH: AADLBA!DataSubcomponent = p.retreiveLengthValue	(implImg);
		RETURN_CODE: AADLBA!DataSubcomponent = thisModule.retreiveReturnCodeValue(implImg);
	}
	to
		
		connected_SAMPLING_ID_Access: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedDataAccess->first().debug('Id Data Access Connection End')
		),
		connected_SAMPLING_ID: AADLBA!ConnectedElement
		(
			connectionEnd<-SAMPLING_ID.debug('Id Subcomponent Connection End')
		),
		accessIDConnection: AADLBA!AccessConnection
		(
			name<-p.name+'_to_ID',
			accessCategory<-#data,
			source<-connected_SAMPLING_ID_Access,
			destination<-connected_SAMPLING_ID
		),
		
		connectedParam_MESSAGE_ADDR: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='MESSAGE_ADDR').debug('MessageAddr Parameter Connection End')
		),
		connectedSubcomponent_MESSAGE_ADDR: AADLBA!ConnectedElement
		(
			connectionEnd<-MESSAGE_ADDR.debug('MessageAddr Subcomponent Connection End')
		),
		paramConnection_MESSAGE_ADDR: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_MessageAddr',
			source<-connectedParam_MESSAGE_ADDR,
			destination<-connectedSubcomponent_MESSAGE_ADDR
		),
		
		connectedParam_LENGTH: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='LENGTH').debug('Length Parameter Connection End')
		),
		connectedSubcomponent_LENGTH: AADLBA!ConnectedElement
		(
			connectionEnd<-LENGTH.debug('Length Subcomponent Connection End')
		),
		
		paramConnection_LENGTH: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_MessageLength',
			source<-connectedParam_LENGTH,
			destination<-connectedSubcomponent_LENGTH
		),
		
		connectedParam_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-spg.ownedParameter->any(e|e.name='RETURN_CODE').debug('Subprogram Parameter Connection End')
		),
		connectedSubcomponent_RETURN_CODE: AADLBA!ConnectedElement
		(
			connectionEnd<-RETURN_CODE.debug('Subprogram Subcomponent Connection End')
		),
		paramConnection_RETURN_CODE: AADLBA!ParameterConnection
		(
			name<-p.name+'_to_ReturnCode',
			source<-connectedParam_RETURN_CODE,
			destination<-connectedSubcomponent_RETURN_CODE
		)
		
	do
	{
		
		connectedParam_MESSAGE_ADDR.setContext(call);
		connected_SAMPLING_ID_Access.setContext(call);
		connectedParam_RETURN_CODE.setContext(call);
		connectedParam_LENGTH.setContext(call);
		
		implImg.getOwnedParameterConnections().add(paramConnection_MESSAGE_ADDR);
		implImg.getOwnedAccessConnections().add(accessIDConnection);
		implImg.getOwnedParameterConnections().add(paramConnection_RETURN_CODE);
		implImg.getOwnedParameterConnections().add(paramConnection_LENGTH);
		
		for(seq in implImg.getOwnedSubprogramCallSequences())
		{
			if(p.direction.toString()='in' or p.direction=#inOut)
				seq.getOwnedCallSpecifications().add(0, call);
			if (p.direction=#out or p.direction=#inOut)
				seq.getOwnedCallSpecifications().add(call);
		}

		
		call.debug('Created Call Sequence');
		call;
	}
}

unique lazy rule createDataPortValueDataSubcomponent {
 from
 	p: AADLI!DataPort
 to
 	internalValue: AADLBA!DataSubcomponent
	(
		name<-p.name+'_InternalValue',
		dataSubcomponentType<-p.dataFeatureClassifier
	)
}

unique lazy rule PortInThread {
	from
		feature : AADLI!FeatureInstance,
		type : AADLI!DataSubcomponentType
	to
		dataAccess: AADLBA!DataAccess
		(
			name <- feature.name+'_PortIdAccess_'+feature.direction,
			kind <- #requires, -- required
			dataFeatureClassifier <- type
		)
	do
	{
		dataAccess.debug('  copy data port to data access');
	}
}

unique lazy rule ThreadPortIdInstance
{
	from
		feature : AADLI!FeatureInstance,
		type : AADLI!DataSubcomponentType
	to
		dataSubcomponent: AADLBA!DataSubcomponent
		(
			name<-feature.name+'_Instance',
			dataSubcomponentType<-type
		)
}


-- @atlcompiler atl2006
-- Generated by: $Id$
module Atl2DedicatedAtl4Aadl2Aadl;

create OUT : MM_ATL from IN : MM_ATL, IN2 : MM_TIP, IN3: AADLI;

helper def : inElements : Set(MM_ATL!LocatedElement) = MM_ATL!LocatedElement.allInstancesFrom('IN');

--returns module name of the IN model
helper def : getModuleName : String = MM_ATL!Module.allInstancesFrom('IN')->first().name;

helper def : getTransformationId(transformationName : String) : String =
	thisModule.getModuleName+'.'+transformationName;

-- gets TIP specification object
helper def : getTipSpecification() : MM_TIP!TipSpecification = 
MM_TIP!TipSpecification.allInstancesFrom('IN2')->last();

--gets the last iteration object
helper def : getLastIteration() : MM_TIP!Iteration = 
MM_TIP!Iteration.allInstancesFrom('IN2')->last();

--gets the output module object
helper def : getOutputModule() : MM_ATL!Module = 
thisModule.resolveTemp(MM_ATL!Module.allInstancesFrom('IN')->first(), 't')
;


--gets transformation Name from the transformation ID
helper def : getTransformationNameFromID(transformationID : String) : String = 
	transformationID.substring(transformationID.lastIndexOf('.')+1, transformationID.size());

--gets all the transformation names excluded from the last iteration elements
helper def : inExcludedTransformationsInTip : Set (String) = thisModule.getLastIteration().elements
	-> select (e| e.isExclusion = true)
	-> select (e | e.transformationId.substring(1, e.transformationId.lastIndexOf('.')) = thisModule.getModuleName)
	-> collect (e | e.transformationId.substring(e.transformationId.lastIndexOf('.')+2, e.transformationId.size()));

--gets all the transformation names selected from the last iteration elements 
helper def : inIncludedTransformationsInTip : Set (String) = thisModule.getLastIteration().elements
	-> select(e| e.isExclusion = false)
	-> select (e | e.transformationId.substring(1, e.transformationId.lastIndexOf('.')) = thisModule.getModuleName)
	-> collect (e | e.transformationId.substring(e.transformationId.lastIndexOf('.')+2, e.transformationId.size()));

--gets all the elements names which have the same transformation to be executed
helper def : getElementTransformationForTransfo(transformationID : String, exclusions: Boolean) : Set (MM_TIP!ElementTransformation) = 
	thisModule.getLastIteration().elements -> 
	select(e | e.isExclusion = exclusions) ->
	select(e | e.transformationId = transformationID)
;-->any(f| f.type=element.class).getInstanceObjectPath());


--helper def : getFilterExpression(ruleName : String) : Sequence (MM_ATL!OclExpression) = 
--		thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+ruleName) 
--		-> iterate (e ; expressionsSequence : Sequence (MM_ATL!OclExpression) = Sequence {} | expressionsSequence.append());
--
--
--
--helper def : assignVar(expressions : Set (MM_ATL!OclExpression), svar : MM_ATL!VariableExp ) : Set (MM_ATL!OclExpression) = 
--	expressions -> collect(e | e.arguments)

rule Unit {
    from s : MM_ATL!"ATL::Unit" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(MM_ATL!"ATL::Unit")
		else false endif)
    to t : MM_ATL!"ATL::Unit" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        --commentsAfter <- s.commentsAfter,
        name <- s.name,
        libraries <- s.libraries)
}

rule Library {
    from s : MM_ATL!"ATL::Library" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::Library" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        --commentsAfter <- s.commentsAfter,
        name <- s.name,
        libraries <- s.libraries,
        helpers <- s.helpers)
}

rule Query {
    from s : MM_ATL!"ATL::Query" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::Query" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        --commentsAfter <- s.commentsAfter,
        name <- s.name,
        libraries <- s.libraries,
        body <- s.body,
        helpers <- s.helpers)
}

rule Module {
    from s : MM_ATL!"ATL::Module" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::Module" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        --commentsAfter <- s.commentsAfter,
        name <- s.name+'_applied_'+thisModule.getLastIteration().id,
        isRefining <- s.isRefining,
        libraries <- s.libraries,
		inModels <- s.inModels,
        outModels <- s.outModels,
        elements <- s.elements)
}

--rule Helper {
--    from s : MM_ATL!"ATL::Helper" (thisModule.inElements->includes(s))
--    to t : MM_ATL!"ATL::Helper" (
--        location <- s.location,
--        commentsBefore <- s.commentsBefore,
--        --commentsAfter <- s.commentsAfter,
--        definition <- s.definition)
--}


--rule IncludedAndExcludedMatchedRule {
--    from 
--		s : MM_ATL!"ATL::MatchedRule" in IN
--		--here an argument for the transformationID matching should be added
--		(
--		 	(
--		 	if thisModule.inElements->includes(s) then
--				s.oclIsTypeOf(MM_ATL!"ATL::MatchedRule")
--			else false endif
--			) 
--    		and
--			(
--				(thisModule.inExcludedTransformationsInTip->includes(s.name)
--				and
--				thisModule.inIncludedTransformationsInTip->includes(s.name))
--			)
--		)
--	using
--	{
--		local: MM_ATL!OclExpression = OclUndefined;
--		local2: MM_ATL!OperatorCallExp = OclUndefined;
--	}
--	to
--		t : MM_ATL!"ATL::MatchedRule" (
--        	location <- s.location,
--        	commentsBefore <- s.commentsBefore,
--			name <- s.name,
--			isAbstract <- s.isAbstract,
--        	isRefining <- s.isRefining,
--        	isNoDefault <- s.isNoDefault,
--        	outPattern <- s.outPattern,
--        	actionBlock <- s.actionBlock,
--        	variables <- s.variables,
--			inPattern <- ip, 
--        	children <- s.children,
--        	superRule <- s.superRule
--		),
--		ip : MM_ATL!InPattern (
--			elements <- s.inPattern.elements->collect(e|thisModule.mapInputElement(e))
--			--filter <- ifilter
--		)
--	do
--	{
--		if(s.inPattern.filter.oclIsUndefined())
--		{
--			local <- thisModule.populateOrOperatorCall(
--									thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name, false),-->excluding(thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name)->first()) 
--									OclUndefined,
--									s.inPattern.elements
--								);
--			ip.filter <- thisModule.populateExclusion(
--					thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name, true), 
--					local,
--					s.inPattern.elements
--			);
--		}
--		else
--		{
--			local <- thisModule.populateOrOperatorCall(
--									thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name, false),-->excluding(thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name)->first()) 
--									OclUndefined,
--									s.inPattern.elements
--								);
--			--local2 <- thisModule.createAndOperatorCallExp(s.inPattern.filter, local);
--			ip.filter <- 
--				thisModule.populateExclusion
--				(
--					thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name, true), 
--					local,
--					s.inPattern.elements
--				);
--		}
--	}
--}



rule ExcludedAndNotIncludedMatchedRule {
    from 
		s : MM_ATL!"ATL::MatchedRule" in IN
		--here an argument for the transformationID matching should be added
		(
		 	(
		 	if thisModule.inElements->includes(s) then
				s.oclIsTypeOf(MM_ATL!"ATL::MatchedRule")
			else false endif
			) 
    		and
			(
				thisModule.inExcludedTransformationsInTip->includes(s.name)
--				and
--				not thisModule.inIncludedTransformationsInTip->includes(s.name)
			) 
		)
	using
	{
		local: MM_ATL!OclExpression = OclUndefined;
	}
	to
		t : MM_ATL!"ATL::MatchedRule" (
        	location <- s.location,
        	commentsBefore <- s.commentsBefore,
			name <- s.name,
			isAbstract <- s.isAbstract,
        	isRefining <- s.isRefining,
        	isNoDefault <- s.isNoDefault,
        	outPattern <- s.outPattern,
        	actionBlock <- s.actionBlock,
        	variables <- s.variables,
			inPattern <- thisModule.resolveTemp(s.inPattern, 't'), 
        	children <- s.children,
        	superRule <- s.superRule
		)
				
	do
	{
		if(s.inPattern.filter.oclIsUndefined())
		{
			t.inPattern.filter <- thisModule.populateExclusion(
					thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name, true), 
					OclUndefined,
					s.inPattern.elements
			);
		}
		else
		{
			local <- t.inPattern.filter;
			t.inPattern.filter <- 
				thisModule.populateExclusion
				(
					thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name, true), 
					local,
					s.inPattern.elements
				);
		}
	}
}


rule populateExclusion(ElementTransfos: Set(MM_TIP!ElementTransformation), filterElement : MM_ATL!OperatorCallExp, inputElems : Sequence(MM_ATL!"ATL::InPatternElement")) {
 using {
 	 local : MM_ATL!OperatorCallExp = OclUndefined;
 	 local2 : MM_ATL!OperatorCallExp = OclUndefined;
 	 init : MM_ATL!OperatorCallExp = if(ElementTransfos->size() > 0) then 
	 										thisModule.initOrOperatorCall(ElementTransfos, inputElems)
 	 									else
 	 										OclUndefined
										endif;
 	 result : MM_ATL!OperatorCallExp = filterElement;
 }	
 do {
 	if(inputElems.size()>1 and ElementTransfos->size() > 0){
 		local <- thisModule.createNandOperatorCall(ElementTransfos->first().elementName, inputElems);
 		thisModule.createAndOperatorHelper(ElementTransfos->first().elementId, ElementTransfos->first().elementName, init, inputElems);
 		if(not filterElement.oclIsUndefined())
 		{
	 		local2 <- thisModule.createAndOperatorCallExp(filterElement, local);
 			result <- thisModule.populateExclusion(ElementTransfos->excluding(ElementTransfos->first()), local2, inputElems);
 		}
 		else
 		{
 			result <- thisModule.populateExclusion(ElementTransfos->excluding(ElementTransfos->first()), local, inputElems);
 		}
 	}
 	else if (ElementTransfos->size() > 0) {
 		local <- thisModule.createNotEqualsOperatorCallExp(ElementTransfos->first().elementId->first(), ElementTransfos->first().elementName->first(), inputElems->first());
 		if(not filterElement.oclIsUndefined())
 		{
 			local2 <- thisModule.createAndOperatorCallExp(filterElement, local);
 			result <- thisModule.populateExclusion(ElementTransfos->excluding(ElementTransfos->first()), local2, inputElems);
 		}
 		else
 		{
 			result <- thisModule.populateExclusion(ElementTransfos->excluding(ElementTransfos->first()), local, inputElems);
 		}
 	}
 	result;
 }	
}


--rule IncludedAndNotExcludedMatchedRule {
--    from 
--		s : MM_ATL!"ATL::MatchedRule" in IN
--		--here an argument for the transformationID matching should be added
--		(
--		 	(
--		 	if thisModule.inElements->includes(s) then
--				s.oclIsTypeOf(MM_ATL!"ATL::MatchedRule")
--			else false endif
--			) 
--    		and
--			(
--				not thisModule.inExcludedTransformationsInTip->includes(s.name)
--				and
--				thisModule.inIncludedTransformationsInTip->includes(s.name)
--			) 
--		)
--    to t : MM_ATL!"ATL::MatchedRule" (
--        location <- s.location,
--        commentsBefore <- --s.commentsBefore,
--						if(s.commentsBefore->last().oclIsUndefined()) then
--        					'-- @extends ' + s.name
--						else
--							s.commentsBefore->excluding(s.commentsBefore->last())->append(s.commentsBefore->last()+','+s.name)
--						endif,
--        --commentsAfter <- s.commentsAfter,
--        name <- s.name +'_applied_'+thisModule.getLastIteration().id,
--        isAbstract <- s.isAbstract,
--        isRefining <- s.isRefining,
--        isNoDefault <- s.isNoDefault,
--        outPattern <- s.outPattern,
--        actionBlock <- s.actionBlock,
--        variables <- s.variables,
--		inPattern <- ip, 
--        children <- s.children,
--        superRule <- s.superRule),
--		
--		ip : MM_ATL!InPattern (
--			elements <- s.inPattern.elements->collect(e|thisModule.mapInputElement(e))
--			--filter <- ifilter
--		)
--	do
--	{
--		ip.filter <- thisModule.populateOrOperatorCall(
--									thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name, false),-->excluding(thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name)->first()) 
--									OclUndefined,
--									s.inPattern.elements
--								);
--	}
--}

unique lazy rule mapInputElement
{
	from
		sourceElement: MM_ATL!SimpleInPatternElement
	to
		element : MM_ATL!SimpleInPatternElement(
			varName <- sourceElement.varName,
			type <- ipet
		),
		ipet : MM_ATL!OclModelElement (
			name <- sourceElement.type.name,
			model <- sourceElement.type.model
		)
	do
	{
		element;
	}
}

--		<filter xsi:type="ocl:OperatorCallExp" location="51:4-55:44" operationName="or">
--          <source xsi:type="ocl:OperatorCallExp" location="51:4-53:44" operationName="or">
--            <source xsi:type="ocl:OperatorCallExp" location="51:5-51:41" operationName="and">
--              <source xsi:type="ocl:OperatorCallExp" location="51:5-51:16" operationName="=">
--                <source xsi:type="ocl:NavigationOrAttributeCallExp" location="51:5-51:12" name="name">
--                  <source xsi:type="ocl:VariableExp" location="51:5-51:7" referredVariable="/0/@elements.1/@inPattern/@elements.0"/>
--                </source>
--                <arguments xsi:type="ocl:StringExp" location="51:13-51:16" stringSymbol="t"/>
--              </source>
--              <arguments xsi:type="ocl:OperatorCallExp" location="51:21-51:41" operationName="=">
--                <source xsi:type="ocl:NavigationOrAttributeCallExp" location="51:21-51:32" name="name">
--                  <source xsi:type="ocl:VariableExp" location="51:21-51:27" referredVariable="/0/@elements.1/@inPattern/@elements.1"/>
--                </source>
--                <arguments xsi:type="ocl:StringExp" location="51:35-51:41" stringSymbol="null"/>
--              </arguments>
--            </source>
--            <arguments xsi:type="ocl:OperatorCallExp" location="53:5-53:43" operationName="and">
--              <source xsi:type="ocl:OperatorCallExp" location="53:5-53:17" operationName="=">
--                <source xsi:type="ocl:NavigationOrAttributeCallExp" location="53:5-53:12" name="name">
--                  <source xsi:type="ocl:VariableExp" location="53:5-53:7" referredVariable="/0/@elements.1/@inPattern/@elements.0"/>
--                </source>
--                <arguments xsi:type="ocl:StringExp" location="53:13-53:17" stringSymbol="t2"/>
--              </source>
--              <arguments xsi:type="ocl:OperatorCallExp" location="53:22-53:43" operationName="=">
--                <source xsi:type="ocl:NavigationOrAttributeCallExp" location="53:22-53:33" name="name">
--                  <source xsi:type="ocl:VariableExp" location="53:22-53:28" referredVariable="/0/@elements.1/@inPattern/@elements.1"/>
--                </source>
--                <arguments xsi:type="ocl:StringExp" location="53:36-53:43" stringSymbol="null2"/>
--              </arguments>
--            </arguments>
--          </source>
--          <arguments xsi:type="ocl:OperatorCallExp" location="55:5-55:43" operationName="and">
--            <source xsi:type="ocl:OperatorCallExp" location="55:5-55:17" operationName="=">
--              <source xsi:type="ocl:NavigationOrAttributeCallExp" location="55:5-55:12" name="name">
--                <source xsi:type="ocl:VariableExp" location="55:5-55:7" referredVariable="/0/@elements.1/@inPattern/@elements.0"/>
--              </source>
--              <arguments xsi:type="ocl:StringExp" location="55:13-55:17" stringSymbol="t2"/>
--            </source>
--            <arguments xsi:type="ocl:OperatorCallExp" location="55:22-55:43" operationName="=">
--              <source xsi:type="ocl:NavigationOrAttributeCallExp" location="55:22-55:33" name="name">
--                <source xsi:type="ocl:VariableExp" location="55:22-55:28" referredVariable="/0/@elements.1/@inPattern/@elements.1"/>
--              </source>
--              <arguments xsi:type="ocl:StringExp" location="55:36-55:43" stringSymbol="null2"/>
--            </arguments>
--          </arguments>
--        </filter>


rule initOrOperatorCall(ElementTransfos: Set(MM_TIP!ElementTransformation), inputElems : Sequence(MM_ATL!"ATL::InPatternElement"))
{
	to
		ifilter : MM_ATL!OperatorCallExp(
			operationName <- '=',
			source <- sourcecall,
			arguments <- argcall
		),
		sourcecall: MM_ATL!StringExp(
			stringSymbol <- ElementTransfos->first().elementName->first()
		),
		argcall: MM_ATL!OperationCallExp(
			operationName <- 'getInstanceObjectPathIfNE',
			source <- argcallsrc			
		),
		argcallsrc : MM_ATL!VariableExp(
			referredVariable <- thisModule.mapInputElement(inputElems->first())
		)
	do
	{
		ifilter;
	}
}

rule populateOrOperatorCall(ElementTransfos: Set(MM_TIP!ElementTransformation), filterElement : MM_ATL!OperatorCallExp, inputElems : Sequence(MM_ATL!"ATL::InPatternElement")) {
 using {
 	 local : MM_ATL!OperatorCallExp = OclUndefined;
 	 local2 : MM_ATL!OperatorCallExp = OclUndefined;
 	 init : MM_ATL!OperatorCallExp = if(ElementTransfos->size() > 0) then 
	 										thisModule.initOrOperatorCall(ElementTransfos, inputElems)
 	 									else
 	 										OclUndefined
										endif;
 	 result : MM_ATL!OperatorCallExp = filterElement;
 }	
 do {
 	if(inputElems.size()>1 and ElementTransfos->size() > 0){
 		local <- thisModule.createAndOperatorCall(ElementTransfos->first().elementName, inputElems);
 		thisModule.createAndOperatorHelper(ElementTransfos->first().elementId, ElementTransfos->first().elementName, init, inputElems);
 		if(not filterElement.oclIsUndefined())
 		{
	 		local2 <- thisModule.createOrOperatorCallExp(filterElement, local);
 			result <- thisModule.populateOrOperatorCall(ElementTransfos->excluding(ElementTransfos->first()), local2, inputElems);
 		}
 		else
 		{
 			result <- thisModule.populateOrOperatorCall(ElementTransfos->excluding(ElementTransfos->first()), local, inputElems);
 		}
 	}
 	else if (ElementTransfos->size() > 0) {
 		if(not filterElement.oclIsUndefined())
 		{
 			local <- thisModule.createOrOperatorCallExp(filterElement, init);
 			result <- thisModule.populateOrOperatorCall(ElementTransfos->excluding(ElementTransfos->first()), local, inputElems);
 		}
 		else
 		{
 			result <- thisModule.populateOrOperatorCall(ElementTransfos->excluding(ElementTransfos->first()), init, inputElems);
 		}
 	}
 	result;
 }	
}

lazy rule createNandOperatorCall {
	from 
		elementNames: Set(String),
		inputElems : Sequence(MM_ATL!"ATL::InPatternElement")
	to
		argcall: MM_ATL!OperatorCallExp
		(
			operationName<-'not',
			source <- thisModule.createAndOperatorCall(elementNames,inputElems)
		)
	do
	{
		argcall;
	}
}

lazy rule createAndOperatorCall {
	from 
		elementNames: Set(String),
		inputElems : Sequence(MM_ATL!"ATL::InPatternElement")
	to
		argcall: MM_ATL!OperationCallExp(
			operationName <- thisModule.getModuleName+thisModule.getAndOperatorCallUniqueId(elementNames),
			source <- currentModuleExp,
			arguments <- inputElems->collect(e | thisModule.createVariableExp(e))
		),
		currentModuleExp: MM_ATL!VariableExp
		(
			referredVariable <- currentModuleDecl
		),
		currentModuleDecl: MM_ATL!VariableDeclaration
		(
			varName <- 'thisModule'
		)
	do
	{
		argcall;
	}
}

lazy rule createVariableExp
{
	from
		s: MM_ATL!"ATL::InPatternElement"
	to
		t: MM_ATL!"OCL::VariableExp"
		(
			referredVariable <- s	
		)
	do
	{
		t;
	}
}


lazy rule createOrOperatorCallExp {
    from
		lhs : MM_ATL!OperatorCallExp,
		rhs : MM_ATL!OperatorCallExp
    to
		result: MM_ATL!OperatorCallExp (
        	operationName <- 'or',
			source <- lhs,
			arguments <- rhs
		)
	do
	{
		result;
	}
}

unique lazy rule createAndOperatorHelper
{
	from
		elements: Set(AADLI!NamedElement),
		elementNames: Set(String), 
		filterElement : MM_ATL!OperatorCallExp, 
		inputElems : Sequence(MM_ATL!"ATL::InPatternElement")
	to
		theHelper: MM_ATL!Helper
		(
			definition <- featureDef
		),
		featureDef: MM_ATL!OclFeatureDefinition
		(
			feature <- operation
		),
		operation: MM_ATL!Operation
		(
			name <- thisModule.getModuleName+thisModule.getAndOperatorCallUniqueId(elementNames),
			returnType <- boolType,
			body <- thisModule.populateAndOperatorCall(elements->excluding(elements->first()),elementNames->excluding(elementNames->first()), filterElement, inputElems->excluding(inputElems->first())),
			parameters <- inputElems->collect(e| thisModule.copyParameterElement(e))
		),
		boolType: MM_ATL!BooleanType
	do
	{
		if(thisModule.getOutputModule().elements
				->select(e|e.oclIsTypeOf(MM_ATL!Helper))
				->select( e | not e.definition.feature.oclIsUndefined())
				->exists(e|e.definition.feature.name = operation.name)
				=false)
		{
			thisModule.getOutputModule().elements.add(theHelper);
		}
		theHelper;
	}
}

lazy rule copyParameterElement
{
	from
		s: MM_ATL!"ATL::InPatternElement"
	to
		t: MM_ATL!Parameter
		(
			varName <- s.varName,
			type <- thisModule.copyType(s.type)
		)
	do
	{
		t;
	}
}

lazy rule copyType
{
	from
		s: MM_ATL!"OCL::OclType"
	to
		t: MM_ATL!"OCL::OclType"
		(
			name <- s.name,
			type <- s.type
		)
	do
	{
		t;
	}
}

helper def: getAndOperatorCallUniqueId(elementNames: Set(String)): String =
	if(elementNames.size()>1)then
		elementNames->first().replaceAll('::','__').replaceAll('.','_')+thisModule.getAndOperatorCallUniqueId(elementNames->excluding(elementNames->first()))
	else
		elementNames->first().replaceAll('::','__').replaceAll('.','_')
	endif
;

rule populateAndOperatorCall(elements: Set(AADLI!NamedElement), elementNames: Set(String), filterElement : MM_ATL!OperatorCallExp, inputElems : Sequence(MM_ATL!"ATL::InPatternElement")) {
 using {
 	 local : MM_ATL!OperatorCallExp = OclUndefined;
 	 result : MM_ATL!OperatorCallExp = filterElement;
 	 local2 : MM_ATL!OperatorCallExp = OclUndefined;
 }	
 do {
 	if(elementNames->size() > 0)
 	{
 		local <- thisModule.createEqualsOperatorCallExp(elements->first(), elementNames->first(), inputElems->first());
 		local2 <- thisModule.createAndOperatorCallExp(filterElement, local);	
  		result <- thisModule.populateAndOperatorCall(elements->excluding(elements->first()),elementNames->excluding(elementNames->first()), local2, inputElems->excluding(inputElems->first()));
 	}
 	result;
 }	
}

lazy rule createNotEqualsOperatorCallExp
{
	from
		elem: AADLI!NamedElement,
		s : String,
		inputElem : MM_ATL!"ATL::InPatternElement"
	to
		ifilter : MM_ATL!OperatorCallExp(
			operationName <- 'not',
			source <- thisModule.createEqualsOperatorCallExp(elem, s, inputElem)
		)
	do
	{
		ifilter;
	}
}


lazy rule createEqualsOperatorCallExp {
    from
		elem: AADLI!NamedElement,
		s : String,
		inputElem : MM_ATL!"ATL::InPatternElement"
	to
		new: MM_ATL!OperatorCallExp
		(
        	operationName <- '=',
			source <-sourcecall,
			arguments <- argcall
		),
		sourcecall: MM_ATL!StringExp(
			stringSymbol <- s
		),
		argcall: MM_ATL!OperationCallExp(
			operationName <- 'getInstanceObjectPathIfNE',
			source <- argcallsrc			
		),
		argcallsrc : MM_ATL!VariableExp(
			referredVariable <- thisModule.mapInputElement(inputElem)
		)
    do
    {
        new;
    }
}

lazy rule createAndOperatorCallExp {
    from
		lhs : MM_ATL!OperatorCallExp,
		rhs : MM_ATL!OperatorCallExp
	to
		new: MM_ATL!OperatorCallExp
		(
        	operationName <- 'and',
			source <-lhs,
			arguments <- rhs
		)
    do
    {
        new;
    }
}

--lazy rule fillOclExpression {
--    from
--    	s : MM_ATL!"ATL::MatchedRule"
--    to
--        result: MM_ATL!OperatorCallExp (
--        	operationName <- '=',
--			source <-sourcecall
--		),
--		sourcecall: MM_ATL!OperationCallExp(
--			operationName <- 'getInstanceObjectPath',
--			source <- argcallsrc			
--		),
--		argcallsrc : MM_ATL!VariableExp(
--			referredVariable <- s.inPattern.elements->first()
--		),
--		
--		argcall : MM_ATL!StringExp(
--			stringSymbol <- thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name)->first()
--		)
--    do
--    {
--        result;
--    }
--}

rule LazyMatchedRule {
    from s : MM_ATL!"ATL::LazyMatchedRule" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::LazyMatchedRule" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        -- commentsAfter <- s.commentsAfter,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isRefining <- s.isRefining,
        isNoDefault <- s.isNoDefault,
        isUnique <- s.isUnique,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
        inPattern <- s.inPattern,
        children <- s.children,
        superRule <- s.superRule)
}

rule CalledRule {
    from s : MM_ATL!"ATL::CalledRule" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::CalledRule" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        -- commentsAfter <- s.commentsAfter,
        name <- s.name,
        isEntrypoint <- s.isEntrypoint,
        isEndpoint <- s.isEndpoint,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
        parameters <- s.parameters)
}

rule InPattern {
    from s : MM_ATL!"ATL::InPattern" (thisModule.inElements->includes(s)
    		and not thisModule.inExcludedTransformationsInTip->includes(s.eContainer().name))
    to t : MM_ATL!"ATL::InPattern" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        elements <- s.elements,
        filter <- s.filter
		)
		
}

rule InExcludedPattern {
    from s : MM_ATL!"ATL::InPattern" (thisModule.inElements->includes(s)
    		and thisModule.inExcludedTransformationsInTip->includes(s.eContainer().name))
    to t : MM_ATL!"ATL::InPattern" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        elements <- s.elements,
        filter <- thisModule.populateExclusion
				(
					thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.eContainer().name, true), 
					s.filter,
					s.eContainer().inPattern.elements
				)
		)
		
}

rule OutPattern {
    from s : MM_ATL!"ATL::OutPattern" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::OutPattern" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        elements <- s.elements)
}

rule SimpleInPatternElement {
    from s : MM_ATL!"ATL::SimpleInPatternElement" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::SimpleInPatternElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        "mapsTo" <- s."mapsTo",
        models <- s.models)
}

rule SimpleOutPatternElement {
    from s : MM_ATL!"ATL::SimpleOutPatternElement" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::SimpleOutPatternElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        sourceElement <- s.sourceElement,
        bindings <- s.bindings,
        model <- s.model,
        reverseBindings <- s.reverseBindings)
}

rule ForEachOutPatternElement {
    from s : MM_ATL!"ATL::ForEachOutPatternElement" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::ForEachOutPatternElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        sourceElement <- s.sourceElement,
        bindings <- s.bindings,
        model <- s.model,
        collection <- s.collection,
        iterator <- s.iterator)
}

rule Binding {
    from s : MM_ATL!"ATL::Binding" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::Binding" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        propertyName <- s.propertyName,
        value <- s.value)
}

rule RuleVariableDeclaration {
    from s : MM_ATL!"ATL::RuleVariableDeclaration" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::RuleVariableDeclaration" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule LibraryRef {
    from s : MM_ATL!"ATL::LibraryRef" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::LibraryRef" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        -- commentsAfter <- s.commentsAfter,
        name <- s.name)
}

rule ActionBlock {
    from s : MM_ATL!"ATL::ActionBlock" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::ActionBlock" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        statements <- s.statements)
}

rule ExpressionStat {
    from s : MM_ATL!"ATL::ExpressionStat" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::ExpressionStat" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        expression <- s.expression)
}

rule BindingStat {
    from s : MM_ATL!"ATL::BindingStat" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::BindingStat" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        propertyName <- s.propertyName,
        source <- s.source,
        value <- s.value)
}

rule IfStat {
    from s : MM_ATL!"ATL::IfStat" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::IfStat" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        condition <- s.condition,
        thenStatements <- s.thenStatements,
        elseStatements <- s.elseStatements)
}

rule ForStat {
    from s : MM_ATL!"ATL::ForStat" (thisModule.inElements->includes(s))
    to t : MM_ATL!"ATL::ForStat" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        iterator <- s.iterator,
        collection <- s.collection,
        statements <- s.statements)
}

rule VariableExp {
    from s : MM_ATL!"OCL::VariableExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::VariableExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        referredVariable <- s.referredVariable)
}

rule SuperExp {
    from s : MM_ATL!"OCL::SuperExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::SuperExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type)
}

rule StringExp {
    from s : MM_ATL!"OCL::StringExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::StringExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        stringSymbol <- s.stringSymbol,
        type <- s.type)
}

rule BooleanExp {
    from s : MM_ATL!"OCL::BooleanExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::BooleanExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        booleanSymbol <- s.booleanSymbol,
        type <- s.type)
}

rule RealExp {
    from s : MM_ATL!"OCL::RealExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::RealExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        realSymbol <- s.realSymbol,
        type <- s.type)
}

rule IntegerExp {
    from s : MM_ATL!"OCL::IntegerExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::IntegerExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        integerSymbol <- s.integerSymbol,
        type <- s.type)
}

rule BagExp {
    from s : MM_ATL!"OCL::BagExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::BagExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule OrderedSetExp {
    from s : MM_ATL!"OCL::OrderedSetExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OrderedSetExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule SequenceExp {
    from s : MM_ATL!"OCL::SequenceExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::SequenceExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule SetExp {
    from s : MM_ATL!"OCL::SetExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::SetExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule TupleExp {
    from s : MM_ATL!"OCL::TupleExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::TupleExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        tuplePart <- s.tuplePart)
}

rule TuplePart {
    from s : MM_ATL!"OCL::TuplePart" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::TuplePart" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule MapExp {
    from s : MM_ATL!"OCL::MapExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::MapExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule MapElement {
    from s : MM_ATL!"OCL::MapElement" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::MapElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        key <- s.key,
        value <- s.value)
}

rule EnumLiteralExp {
    from s : MM_ATL!"OCL::EnumLiteralExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::EnumLiteralExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule OclUndefinedExp {
    from s : MM_ATL!"OCL::OclUndefinedExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OclUndefinedExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type)
}

rule NavigationOrAttributeCallExp {
    from s : MM_ATL!"OCL::NavigationOrAttributeCallExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::NavigationOrAttributeCallExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        source <- s.source)
}

rule OperationCallExp {
    from s : MM_ATL!"OCL::OperationCallExp" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(MM_ATL!"OCL::OperationCallExp")
		else false endif)
    to t : MM_ATL!"OCL::OperationCallExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        operationName <- s.operationName,
        type <- s.type,
        source <- s.source,
        arguments <- s.arguments)
}

rule OperatorCallExp {
    from s : MM_ATL!"OCL::OperatorCallExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OperatorCallExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        operationName <- s.operationName,
        type <- s.type,
        source <- s.source,
        arguments <- s.arguments)
}

rule CollectionOperationCallExp {
    from s : MM_ATL!"OCL::CollectionOperationCallExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::CollectionOperationCallExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        operationName <- s.operationName,
        type <- s.type,
        source <- s.source,
        arguments <- s.arguments)
}

rule IterateExp {
    from s : MM_ATL!"OCL::IterateExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::IterateExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        source <- s.source,
        body <- s.body,
        iterators <- s.iterators,
        result <- s.result)
}

rule IteratorExp {
    from s : MM_ATL!"OCL::IteratorExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::IteratorExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        source <- s.source,
        body <- s.body,
        iterators <- s.iterators)
}

rule LetExp {
    from s : MM_ATL!"OCL::LetExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::LetExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        variable <- s.variable,
        in_ <- s.in_)
}

rule IfExp {
    from s : MM_ATL!"OCL::IfExp" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::IfExp" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        thenExpression <- s.thenExpression,
        condition <- s.condition,
        elseExpression <- s.elseExpression)
}

rule VariableDeclaration {
    from s : MM_ATL!"OCL::VariableDeclaration" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(MM_ATL!"OCL::VariableDeclaration")
		else false endif)
    to t : MM_ATL!"OCL::VariableDeclaration" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule Iterator {
    from s : MM_ATL!"OCL::Iterator" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::Iterator" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule Parameter {
    from s : MM_ATL!"OCL::Parameter" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::Parameter" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule CollectionType {
    from s : MM_ATL!"OCL::CollectionType" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(MM_ATL!"OCL::CollectionType")
		else false endif)
    to t : MM_ATL!"OCL::CollectionType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule "OclType" {
    from s : MM_ATL!"OCL::OclType" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(MM_ATL!"OCL::OclType")
		else false endif)
    to t : MM_ATL!"OCL::OclType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule StringType {
    from s : MM_ATL!"OCL::StringType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::StringType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule BooleanType {
    from s : MM_ATL!"OCL::BooleanType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::BooleanType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule IntegerType {
    from s : MM_ATL!"OCL::IntegerType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::IntegerType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule RealType {
    from s : MM_ATL!"OCL::RealType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::RealType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule BagType {
    from s : MM_ATL!"OCL::BagType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::BagType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule OrderedSetType {
    from s : MM_ATL!"OCL::OrderedSetType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OrderedSetType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule SequenceType {
    from s : MM_ATL!"OCL::SequenceType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::SequenceType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule SetType {
    from s : MM_ATL!"OCL::SetType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::SetType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule OclAnyType {
    from s : MM_ATL!"OCL::OclAnyType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OclAnyType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule "TupleType" {
    from s : MM_ATL!"OCL::TupleType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::TupleType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        attributes <- s.attributes)
}

rule TupleTypeAttribute {
    from s : MM_ATL!"OCL::TupleTypeAttribute" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::TupleTypeAttribute" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule OclModelElement {
    from s : MM_ATL!"OCL::OclModelElement" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OclModelElement" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        model <- s.model)
}

rule MapType {
    from s : MM_ATL!"OCL::MapType" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::MapType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        valueType <- s.valueType,
        keyType <- s.keyType)
}

rule OclFeatureDefinition {
    from s : MM_ATL!"OCL::OclFeatureDefinition" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OclFeatureDefinition" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        feature <- s.feature,
        context_ <- s.context_)
}

rule OclContextDefinition {
    from s : MM_ATL!"OCL::OclContextDefinition" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OclContextDefinition" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        context_ <- s.context_)
}

rule Attribute {
    from s : MM_ATL!"OCL::Attribute" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::Attribute" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        initExpression <- s.initExpression,
        type <- s.type)
}

rule Operation {
    from s : MM_ATL!"OCL::Operation" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::Operation" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        parameters <- s.parameters,
        returnType <- s.returnType,
        body <- s.body)
}

rule OclModel {
    from s : MM_ATL!"OCL::OclModel" (thisModule.inElements->includes(s))
    to t : MM_ATL!"OCL::OclModel" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        metamodel <- s.metamodel,
        elements <- s.elements,
        model <- s.model)
}


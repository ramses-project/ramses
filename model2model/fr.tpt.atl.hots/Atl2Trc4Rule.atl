-- @atlcompiler atl2006
-- Generated by: $Id$
module Atl2Trc;

create OUT : MM_TRC from IN : MM_ATL;


rule Module {
    from s : MM_ATL!"ATL::Module"
    to t : MM_TRC!"TRC::Module" (
    	name  <- s.name,
    	path  <- s.location,
		rules <- s.elements) -- elements is a module element 
}

--rule Helper {
--    from s : MM_ATL!"ATL::Helper" (thisModule.inElements->includes(s))
--    to t : MM_ATL!"ATL::Helper" (
--        location <- s.location,
--        commentsBefore <- s.commentsBefore,
--        --commentsAfter <- s.commentsAfter,
--        definition <- s.definition)
--}


rule ModuleMatchedRule {
    from 
		s : MM_ATL!"ATL::MatchedRule" in IN
		--here an argument for the transformationID matching should be added
		(
		 	(
		 	if thisModule.inElements->includes(s) then
				s.oclIsTypeOf(MM_ATL!"ATL::MatchedRule")
			else false endif
			) 
    		and
			(
				(thisModule.inExcludedTransformationsInTip->includes(s.name)
				and
				thisModule.inIncludedTransformationsInTip->includes(s.name))
			)
		)
	using
	{
		local: MM_ATL!OclExpression = OclUndefined;
		local2: MM_ATL!OperatorCallExp = OclUndefined;
	}
	to
		t : MM_TRC!"TRC::trcRule" (
        	location <- s.location,
			name <- s.name,
			isAbstract <- s.isAbstract,
        	isRefining <- s.isRefining,
        	isNoDefault <- s.isNoDefault,
        	outPattern <- s.outPattern,
        	actionBlock <- s.actionBlock,
        	variables <- s.variables,
			inPattern <- ip, 
        	children <- s.children,
        	superRule <- s.superRule
		),
		ip : MM_TRC!InPattern (
			elements <- s.inPattern.elements->collect(e|thisModule.mapInputElement(e))
			--filter <- ifilter
		)
	do
	{
		if(s.inPattern.filter.oclIsUndefined())
		{
			local <- thisModule.populateOrOperatorCall(
									thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name, false),-->excluding(thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name)->first()) 
									OclUndefined,
									s.inPattern.elements
								);
			ip.filter <- thisModule.populateExclusion(
					thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name, true), 
					local,
					s.inPattern.elements
			);
		}
		else
		{
			local <- thisModule.populateOrOperatorCall(
									thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name, false),-->excluding(thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name)->first()) 
									OclUndefined,
									s.inPattern.elements
								);
			--local2 <- thisModule.createAndOperatorCallExp(s.inPattern.filter, local.debug(' !!!!!!!!!!!!!!!!! '+s.name));
			ip.filter <- 
				thisModule.populateExclusion
				(
					thisModule.getElementTransformationForTransfo(thisModule.getModuleName+'.'+s.name, true), 
					local,
					s.inPattern.elements
				);
		}
	}
}



--
--rule LazyMatchedRule {
--    from s : MM_ATL!"ATL::LazyMatchedRule" (thisModule.inElements->includes(s))
--    to t : MM_ATL!"ATL::LazyMatchedRule" (
--        location <- s.location,
--        commentsBefore <- s.commentsBefore,
--        -- commentsAfter <- s.commentsAfter,
--        name <- s.name,
--        isAbstract <- s.isAbstract,
--        isRefining <- s.isRefining,
--        isNoDefault <- s.isNoDefault,
--        isUnique <- s.isUnique,
--        outPattern <- s.outPattern,
--        actionBlock <- s.actionBlock,
--        variables <- s.variables,
--        inPattern <- s.inPattern,
--        children <- s.children,
--        superRule <- s.superRule)
--}

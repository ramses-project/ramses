-- AADL-BA-FrontEnd
 
-- Copyright © 2011 Télécom ParisTech and CNRS
 
-- Télécom ParisTech/LTCI

-- Authors: see AUTHORS
 
-- This program is free software: you can redistribute it and/or modify 
-- it under the terms of the Eclipse Public License as published by Eclipse,
-- either version 1.0 of the License, or (at your option) any later version.
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- Eclipse Public License for more details.
-- You should have received a copy of the Eclipse Public License
-- along with this program.  If not, see 
-- http://www.eclipse.org/org/documents/epl-v10.php

-- Behavior Annex names resolution.
-- Use only to test name resolution or parsing. This test hasn't any semantic meaning.

package NamesResolutionTest
public
   with Data_Model, Base_Types, DummyPropertySet, Dummy::Types, DummySubRoutine ;

subprogram procedure
end procedure ;

subprogram multiplication
prototypes
  proto : subprogram ;

features
  x : in parameter Base_Types::Integer ;
  y : in parameter MyInteger;
  z : out parameter MyInteger;

end multiplication;

subprogram implementation multiplication.impl
end multiplication.impl;

subprogram implementation multiplication.impl2 extends multiplication.impl
   (proto => subprogram multiplication)
 
end multiplication.impl2;

data MyInteger
  
features
  multiplicationAccess : provides subprogram access multiplication ;  
properties
  Data_Model::Data_Representation => Integer;
  Data_Model::Integer_Range => 0 .. Max_Target_Integer ;
end MyInteger;

data implementation MyInteger.impl
subcomponents
      length : data Base_Types::Integer ;
properties
  Data_Model::Initial_Value => ("25");
end MyInteger.impl ;

data MyInteger_Array
properties
	Data_Model::Data_Representation => Array ;
   	Data_Model::Base_Type => (classifier (MyInteger)) ;
	Data_Model::Dimension => (3,2, DummyPropertySet::aConstant) ;
end MyInteger_Array ;


data implementation MyInteger.impl2 extends  MyInteger.impl
subcomponents
      max : data Base_Types::Integer ;
end MyInteger.impl2 ;

process myprocess

features
  A : in event data port MyInteger;
  B : in event data port MyInteger;
  C : in event data port MyInteger;
   
annex behavior_specification {**

states
  m1 : initial state ;
  f1 : final state ;
   
transitions
  m1 -[]-> f1 ;
  
**};
end myprocess;

thread thread1
prototypes
  proto : subprogram multiplication ;

features
  mul : requires subprogram access multiplication;
  mulProvided : provides subprogram access multiplication ;
  inPortA : in event data port Base_Types::Integer ;
  inPortB : in event data port Base_Types::Integer;
  inPortC : in event data port Base_Types::Integer;
  inPortD : in event data port Base_Types::Integer;
  outPortA : out event data port MyInteger;
  outPortB : out event data port Base_Types::Boolean ;
  inPortArrayA : in event port[10] ;
  outPortArrayA : out event port[10] ;
  
  fakePort : out data port Dummy::Types::Opaque ;
  
  dataAccess : requires data access MyInteger.impl ;
  dataAccess2 : requires data access MyInteger.impl2 ;
  dataAccessArray : requires data access MyInteger.impl2[10] ;
  
end thread1;

thread implementation thread1.impl
 
subcomponents
  spg1 : subprogram procedure ;
  spg2 : subprogram multiplication;
  subData1: data MyInteger.impl ;
  float : data Base_Types::Float {Data_Model::Initial_Value => ("3.2");};
  floatArray : data Base_Types::Float[DummyPropertySet::aConstant] ;

properties
  Dispatch_Protocol => Timed ;
  Period => 1 sec;
  
annex behavior_specification {**

 -- *** VARIABLES *** 

variables 
 x : Base_Types::Integer;
 y : Base_Types::Integer;
 tmp, tmp0 : MyInteger ;
 tab[10] : MyInteger ;
 squareTab[130][DummyPropertySet::aConstant] : MyInteger ;
 tab2[DummyPropertySet::aConstant] : MyInteger ;
 tmp1 : Base_Types::Integer ;
 tmp2 : Dummy::Types::Opaque ;
 tmp3 : Dummy::Types::Opaque.v1 ;
 tmp4 : MyInteger.impl ;
 bool1, bool2 : Base_Types::Boolean ;
 
--  *** STATES ***
 
states
 a, b, c : state ;
 a2 : state ;
 a3 : state ;
 a4 : final state ;
 a5 : initial final state ;
 a6 : final state ;

-- *** TRANSITIONS ***

transitions

 -- Transition and source identifier variations
 a -[]-> a {for(i: MyInteger in squareTab) {tmp:=i+1}};
 a -[]-> a {tmp := 1} timeout 20 ms ;
 a -[]-> a {tmp := 1} timeout x ms ;
 a -[]-> a {tmp := 1} timeout DummyPropertySet::aConstant ms ;
 regular1: a -[]-> a ;
 regular2 [1] : a -[]-> a ;
 regular3 [1_2] : a -[]-> a ;
 a, b -[]-> c ;
 a -[]-> a ;

 -- Execute condition tests --
 
 a -[otherwise]-> a ;
 a -[2 > 1]-> a ;
 a -[x < y]-> a ;
 a -[x <= y]-> a ;
 a -[x >= y]-> a ;
 a -[tmp4 = subData1]-> a ;
 a -[1 != y]-> a ;
 a -[bool1 and bool2]-> a ;
 a -[2>1 xor x=y]-> a ;
 a -[not bool1 or x=y]-> a ;
 a -[bool1]-> a ;
 a -[not bool2]-> a ; 
 a -[true]-> a ;
 a -[false]-> a ;
 a -[-x > 0]-> a ;
 a -[(1+x) > 0]-> a ;
 a -[+x * 0 = 0]-> a ;
 a -[1 /x > 0]-> a ;
 a -[DummyPropertySet::aConstant mod x > 0 or true]-> a ;
 a -[DummyPropertySet::aValue > 0 or bool1]-> a ;
 a -[+y rem x > 0]-> a ;
 a -[x < -y + 3 and bool1 or bool2]-> a ;
 a -[abs x > 2]-> a ;-- Remember a numeric_literal can't be negative. So "abs -1" and "abs +1" are aadl behavior annex syntax errors.
 a -[-1 > 0]-> a ;
 a -[1+1 > 0]-> a ;
 a -[+1 * 0 = 0]-> a ;
 a -[1 /2 > 0]-> a ;
 a -[2 mod x > 0 or true]-> a ;
 
 
 -- Actions, sequences et action sets tests --
 
 a -[]-> a {tmp := 1 ; x := 1 ; y := 1} ;
 a -[]-> a {tmp := 1 & x := 1 & y := 1} ;
 a -[]-> a {tmp := 1 ; x := 1 ; y := 1} timeout 100 ms;
 a -[]-> a {tmp := 1 & x := 1 & y := 1} timeout x ms; 
 a -[]-> c {tmp := 1} timeout DummyPropertySet::aValue ms; 
   
   -- Basic action variations tests --
   
      -- Communication actions tests --
      
 a -[]-> a ;
 a -[]-> a {procedure !} ;
 a -[]-> a {mul ! (0, 0, tmp)} ;
 a -[]-> a {mul ! (x, tmp, outPortA)} ;
 a -[]-> a {spg1 !} ;
 a -[]-> a {spg2 ! (0, 1, tmp)} ; 
 a -[]-> a {procedure !} ;
 a -[]-> a {multiplication ! (0, 0, tmp)} ;
 a -[]-> a {multiplication.impl ! (0, 0, tmp)} ;
 a -[]-> a {NamesResolutionTest::procedure !} ;
 a -[]-> a {NamesResolutionTest::multiplication ! (0, 0, tmp)} ;
 a -[]-> a {DummySubRoutine::parameterLessProcedure !} ;
 a -[]-> a {DummySubRoutine::addition ! (1, 2, x)} ;
 a -[]-> a {DummySubRoutine::addition.impl ! (0, 1, x)} ;
 a -[]-> a {dataAccessArray[x].multiplicationAccess ! (1, 2, tmp)};
 a -[]-> a {dataAccess.multiplicationAccess ! (1, 2, tmp)} ;
 
      -- Assignement actions tests --

 a -[]-> a { {tmp :=1} } ;
 a -[]-> a { {tmp :=1 + 2} } ;
 a -[]-> a { {x := 1 + x} } ;
 a -[]-> a { {tmp :=any} } ;
 a -[]-> a { {tmp4 :=subData1} } ;
 a -[]-> a { tab[x] := 1 } ;
 
 -- Control structures tests --
 
 a -[]-> a { if(bool1) tmp := 1 end if} ;
 a -[]-> a { if(true) tmp := 1 ; tmp:= 1 end if} ;
 a -[]-> a { if(bool1) tmp := 1 else tmp := 2 end if} ;
 a -[]-> a { if(x > y or bool1) tmp := 1 end if} ;

 a -[]-> a { for(i : Base_Types::Integer in 0 .. 9) {tmp:=tmp+1} } ;
 a -[]-> a { for(i : Base_Types::Integer in y..9) {tmp:=5} } ; 
 a -[]-> a { for(i : MyInteger in tmp..tmp0) {tmp:= tmp0} } ;
 a -[]-> a { for(i : Base_Types::Integer in 0 .. 9) {tmp:=1} } ;
 a -[]-> a { for(i : Dummy::Types::Integer.v1 in 0 .. 9) {tmp:=1} } ;
 a -[]-> a { forall(i : Base_Types::Integer in 0_1 .. 9) {tmp:=1} } ;
 a -[]-> a { forall(i : Base_Types::Integer in 0 .. 9) {tmp:=1 ; tmp:=1} } ;
 a -[]-> a { forall(i : Base_Types::Integer in 0 .. 9) {tmp:=1 & x:=1} } ;
 a -[]-> a { forall(i : Base_Types::Integer in y .. 9) {tmp:=1} } ;
 a -[]-> a { forall(i : Base_Types::Integer in 0 .. 9) {tmp:=1} } ;
 a -[]-> a { forall(i : Dummy::Types::Integer.v1 in 0 .. 9) {tmp:=1} } ;
 a -[]-> a { while(true) {tmp:=1} } ;
 a -[]-> a { while(bool1) {tmp:=1 ; tmp:=1} } ;
 a -[]-> a { while(bool1) {tmp:=1 & x:=1} } ;
 a -[]-> a { while(bool1 and bool2) {tmp:=1} } ;
 a -[]-> a { do tmp:=1 until (true) };
 a -[]-> a { do tmp:=1 & x:=1 until (true) };
 a -[]-> a { do tmp:=1 ; tmp:=1 until (true) };
 a -[]-> a { do tmp:=1 until (bool1) };
 a -[]-> a { do tmp:=1 until (bool1 xor bool2) };
 a -[]-> a { do tmp:=1 until (bool1 or x +1 > -y) } ;
 a -[]-> a { for (i : MyInteger in 0 .. 9)
             {
               for (j : MyInteger in 0 .. 9) {tmp:= i + j} ;
               tmp := i 
             }
           } ;
             
 a -[]-> a {
             while(true)
             {
               for (i : Base_Types::Integer in 0 .. 9)
               {
                 if (true)
                 {
                   tmp := 1 
                 }
                 elsif (true) { tmp:= 1 }
                 else
                 {
                   for (j : Base_Types::Integer in 0 .. 9)
                   {
                     do { x := i + j } until (true) 
                   }
                 }
                   end if
                 }
               }
             } ;
             
 -- Value expression tests --

 a -[]-> a {bool1 := bool1 or bool1 or bool1} ;
 a -[]-> a {bool1 := bool1 and bool1 and bool1} ;
 a -[]-> a {bool1 := bool1 xor bool1 xor bool1} ;
   
   -- factor tests --
   
 a -[]-> a {tmp := tmp0 ** 1} ;
 a -[]-> a {tmp := abs tmp0} ;
 a -[]-> a {bool2 := not bool1} ; 
   
   -- term tests --

 a -[]-> a {x := x * x * x} ;  
 a -[]-> a {x := x / x / x} ;
 a -[]-> a {x := x mod x mod x} ;
 a -[]-> a {x := x rem x rem x} ;
 a -[]-> a {x := x * x / x mod x rem x} ;
  
   -- simple expression tests --
 
 a -[]-> a {x := +x + x + x} ;
 a -[]-> a {x := -x - x - x} ;
 a -[]-> a {x := +x - x + x} ;
   
   -- relation tests --
   
 a -[]-> a {bool1 := x = y } ;
 a -[]-> a {bool1 := bool2 = true } ;  
 a -[]-> a {bool1 := x != y } ;
 a -[]-> a {bool1 := bool2 != true } ;
 a -[]-> a {bool1 := x > y } ;
 a -[]-> a {bool1 := x < y } ;
 a -[]-> a {bool1 := x >= y } ;
 a -[]-> a {bool1 := x <= y } ;
   
   -- global tests --

 a -[]-> a {bool1 := not(abs x * x / y - x rem y <= 1) != (x ** (1 ** tmp) != ((abs x) + x - y))} ;

 -- real literal and based integer tests -- 
 
 a -[]-> a {tmp := 12 ; tmp := 0 ; tmp := 1E6 ; tmp := 1E+6 ; tmp := 123_456} ;
 a -[]-> a {float := 12.0 ; float := 0.0 ; float := 0.456 ; float := 3.14159_26 ; float := 1.0E-6 ; float := 1.0E+6} ;
 a -[]-> a {tmp := 2#1111_1111# ; tmp := 16#FF# ; tmp := 016#0ff# ; tmp := 16#0A#E+2} ;
 a -[]-> a {tmp := 2#1110_0000# ; tmp := 16#E#E1 ; tmp := 8#340#} ;
                
**};  

end thread1.impl;

end NamesResolutionTest;